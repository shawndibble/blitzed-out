{"version":3,"file":"chunk-B2GYjlo-.js","sources":["../../src/services/localPlayerService.ts","../../src/stores/localPlayerStore.ts","../../src/hooks/useLocalPlayers.ts"],"sourcesContent":["import { nanoid } from 'nanoid';\nimport db from '@/stores/store';\nimport type {\n  LocalPlayer,\n  LocalPlayerSession,\n  LocalSessionSettings,\n  DBLocalPlayerSession,\n} from '@/types';\n\n/**\n * Service for managing local player sessions in single-device multiplayer mode\n * Handles session creation, player management, and turn advancement\n */\nexport class LocalPlayerService {\n  private static instance: LocalPlayerService;\n  private currentSession: LocalPlayerSession | null = null;\n\n  private constructor() {\n    // Private constructor for singleton pattern\n  }\n\n  /**\n   * Get singleton instance of LocalPlayerService\n   */\n  public static getInstance(): LocalPlayerService {\n    if (!LocalPlayerService.instance) {\n      LocalPlayerService.instance = new LocalPlayerService();\n    }\n    return LocalPlayerService.instance;\n  }\n\n  /**\n   * Create a new local player session\n   * @param roomId - The room ID this session belongs to\n   * @param players - Array of local players\n   * @param settings - Session settings\n   * @returns Promise<LocalPlayerSession> - The created session\n   */\n  public async createSession(\n    roomId: string,\n    players: LocalPlayer[],\n    settings: LocalSessionSettings\n  ): Promise<LocalPlayerSession> {\n    try {\n      // Validate input\n      this.validateSessionInput(roomId, players, settings);\n\n      const sessionId = nanoid();\n      const now = Date.now();\n\n      // Initialize players with starting positions\n      const initializedPlayers = players.map((player) => ({\n        ...player,\n        location: player.location ?? 0, // Start at position 0 if not specified\n        isFinished: player.isFinished ?? false, // Not finished by default\n      }));\n\n      const session: LocalPlayerSession = {\n        id: sessionId,\n        roomId,\n        players: initializedPlayers,\n        currentPlayerIndex: 0,\n        isActive: true,\n        createdAt: now,\n        updatedAt: now,\n        settings: { ...settings },\n      };\n\n      // Prepare database entry\n      const dbSession: DBLocalPlayerSession = {\n        sessionId: session.id,\n        roomId: session.roomId,\n        players: session.players,\n        currentPlayerIndex: session.currentPlayerIndex,\n        isActive: session.isActive,\n        createdAt: session.createdAt,\n        updatedAt: session.updatedAt,\n        settings: session.settings,\n      };\n\n      // Save to database\n      await db.localPlayerSessions.add(dbSession);\n\n      // Set as current session\n      this.currentSession = session;\n\n      return session;\n    } catch (error) {\n      throw new Error(\n        `Failed to create local player session: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Get an existing local player session by ID\n   * @param sessionId - The session ID to retrieve\n   * @returns Promise<LocalPlayerSession | null> - The session or null if not found\n   */\n  public async getSession(sessionId: string): Promise<LocalPlayerSession | null> {\n    try {\n      if (!sessionId) {\n        throw new Error('Session ID is required');\n      }\n\n      const dbSession = await db.localPlayerSessions.where('sessionId').equals(sessionId).first();\n\n      if (!dbSession) {\n        return null;\n      }\n\n      return this.convertDbSessionToSession(dbSession);\n    } catch (error) {\n      throw new Error(\n        `Failed to get session: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Update an existing local player session\n   * @param sessionId - The session ID to update\n   * @param updates - Partial session data to update\n   * @returns Promise<LocalPlayerSession> - The updated session\n   */\n  public async updateSession(\n    sessionId: string,\n    updates: Partial<Omit<LocalPlayerSession, 'id' | 'createdAt'>>\n  ): Promise<LocalPlayerSession> {\n    try {\n      if (!sessionId) {\n        throw new Error('Session ID is required');\n      }\n\n      const existingSession = await this.getSession(sessionId);\n      if (!existingSession) {\n        throw new Error('Session not found');\n      }\n\n      const updatedSession: LocalPlayerSession = {\n        ...existingSession,\n        ...updates,\n        id: sessionId, // Ensure ID cannot be changed\n        createdAt: existingSession.createdAt, // Ensure createdAt cannot be changed\n        updatedAt: Date.now(),\n      };\n\n      // Prepare database update\n      const dbUpdate: Partial<DBLocalPlayerSession> = {\n        roomId: updatedSession.roomId,\n        players: updatedSession.players,\n        currentPlayerIndex: updatedSession.currentPlayerIndex,\n        isActive: updatedSession.isActive,\n        updatedAt: updatedSession.updatedAt,\n        settings: updatedSession.settings,\n      };\n\n      // Update in database\n      await db.localPlayerSessions.where('sessionId').equals(sessionId).modify(dbUpdate);\n\n      // Update current session if it's the same\n      if (this.currentSession?.id === sessionId) {\n        this.currentSession = updatedSession;\n      }\n\n      return updatedSession;\n    } catch (error) {\n      throw new Error(\n        `Failed to update session: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Advance to the next local player in turn order\n   * @param sessionId - The session ID to advance turn for\n   * @returns Promise<LocalPlayer> - The next active player\n   */\n  public async advanceLocalTurn(sessionId: string): Promise<LocalPlayer> {\n    try {\n      if (!sessionId) {\n        throw new Error('Session ID is required');\n      }\n\n      const session = await this.getSession(sessionId);\n      if (!session) {\n        throw new Error('Session not found');\n      }\n\n      if (!session.isActive) {\n        throw new Error('Cannot advance turn on inactive session');\n      }\n\n      if (session.players.length === 0) {\n        throw new Error('No players in session');\n      }\n\n      // Calculate next player index (wrap around)\n      const nextIndex = (session.currentPlayerIndex + 1) % session.players.length;\n\n      // Update current player active states\n      const updatedPlayers = session.players.map((player, index) => ({\n        ...player,\n        isActive: index === nextIndex,\n      }));\n\n      // Update session\n      const updatedSession = await this.updateSession(sessionId, {\n        players: updatedPlayers,\n        currentPlayerIndex: nextIndex,\n      });\n\n      return updatedSession.players[nextIndex];\n    } catch (error) {\n      throw new Error(\n        `Failed to advance turn: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Get the current active session\n   * @returns LocalPlayerSession | null - The current session or null\n   */\n  public getCurrentSession(): LocalPlayerSession | null {\n    return this.currentSession;\n  }\n\n  /**\n   * Update a specific local player's position on the game board\n   * @param sessionId - The session ID containing the player\n   * @param playerId - The local player ID to update\n   * @param newLocation - New board position (0-based index)\n   * @param isFinished - Whether the player has finished the game\n   * @returns Promise<LocalPlayer> - The updated player\n   */\n  public async updatePlayerPosition(\n    sessionId: string,\n    playerId: string,\n    newLocation: number,\n    isFinished: boolean = false\n  ): Promise<LocalPlayer> {\n    try {\n      if (!sessionId) {\n        throw new Error('Session ID is required');\n      }\n      if (!playerId) {\n        throw new Error('Player ID is required');\n      }\n      if (newLocation < 0) {\n        throw new Error('Location must be non-negative');\n      }\n\n      const session = await this.getSession(sessionId);\n      if (!session) {\n        throw new Error('Session not found');\n      }\n\n      if (!session.isActive) {\n        throw new Error('Cannot update player position on inactive session');\n      }\n\n      // Find and update the specific player\n      const playerIndex = session.players.findIndex((p) => p.id === playerId);\n      if (playerIndex === -1) {\n        throw new Error(`Player with ID ${playerId} not found in session`);\n      }\n\n      const updatedPlayers = [...session.players];\n      updatedPlayers[playerIndex] = {\n        ...updatedPlayers[playerIndex],\n        location: newLocation,\n        isFinished,\n      };\n\n      // Update session\n      await this.updateSession(sessionId, {\n        players: updatedPlayers,\n      });\n\n      return updatedPlayers[playerIndex];\n    } catch (error) {\n      throw new Error(\n        `Failed to update player position: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Clear the current session (does not delete from database)\n   */\n  public clearCurrentSession(): void {\n    this.currentSession = null;\n  }\n\n  /**\n   * Validate session input parameters\n   * @private\n   */\n  private validateSessionInput(\n    roomId: string,\n    players: LocalPlayer[],\n    settings: LocalSessionSettings\n  ): void {\n    if (!roomId || typeof roomId !== 'string') {\n      throw new Error('Valid room ID is required');\n    }\n\n    if (!Array.isArray(players) || players.length < 2 || players.length > 4) {\n      throw new Error('Session must have between 2 and 4 players');\n    }\n\n    // Validate each player\n    players.forEach((player, index) => {\n      if (!player.id || typeof player.id !== 'string') {\n        throw new Error(`Player at index ${index} must have a valid ID`);\n      }\n      if (!player.name || typeof player.name !== 'string') {\n        throw new Error(`Player at index ${index} must have a valid name`);\n      }\n      if (!['sub', 'dom', 'vers'].includes(player.role)) {\n        throw new Error(`Player at index ${index} must have a valid role`);\n      }\n      if (\n        typeof player.location !== 'undefined' &&\n        (typeof player.location !== 'number' || player.location < 0)\n      ) {\n        throw new Error(\n          `Player at index ${index} must have a valid location (non-negative number)`\n        );\n      }\n    });\n\n    // Check for duplicate player IDs\n    const playerIds = players.map((p) => p.id);\n    const uniqueIds = new Set(playerIds);\n    if (playerIds.length !== uniqueIds.size) {\n      throw new Error('All players must have unique IDs');\n    }\n\n    // Check for duplicate player names\n    const playerNames = players.map((p) => p.name.toLowerCase());\n    const uniqueNames = new Set(playerNames);\n    if (playerNames.length !== uniqueNames.size) {\n      throw new Error('All players must have unique names');\n    }\n\n    if (!settings || typeof settings !== 'object') {\n      throw new Error('Valid settings object is required');\n    }\n  }\n\n  /**\n   * Convert database session to session object\n   * @private\n   */\n  private convertDbSessionToSession(dbSession: DBLocalPlayerSession): LocalPlayerSession {\n    return {\n      id: dbSession.sessionId,\n      roomId: dbSession.roomId,\n      players: dbSession.players,\n      currentPlayerIndex: dbSession.currentPlayerIndex,\n      isActive: dbSession.isActive,\n      createdAt: dbSession.createdAt,\n      updatedAt: dbSession.updatedAt,\n      settings: dbSession.settings,\n    };\n  }\n}\n\n// Export singleton instance\nexport const localPlayerService = LocalPlayerService.getInstance();\n","import type { LocalPlayer, LocalPlayerSession, LocalSessionSettings } from '@/types';\n\nimport { create } from 'zustand';\nimport { localPlayerService } from '@/services/localPlayerService';\nimport { persist } from 'zustand/middleware';\n\n/**\n * State interface for local player store\n */\ninterface LocalPlayerState {\n  // Current session data\n  session: LocalPlayerSession | null;\n\n  // Error state\n  error: string | null;\n\n  // Loading state\n  isLoading: boolean;\n\n  // Getters\n  hasLocalPlayers: () => boolean;\n  isLocalPlayerRoom: () => boolean;\n  getCurrentPlayer: () => LocalPlayer | null;\n\n  // Actions\n  setSession: (session: LocalPlayerSession | null) => void;\n  clearSession: () => void;\n  setError: (error: string | null) => void;\n  setLoading: (loading: boolean) => void;\n\n  // Async actions\n  initSession: (\n    roomId: string,\n    players: LocalPlayer[],\n    settings: LocalSessionSettings\n  ) => Promise<void>;\n  loadSession: (sessionId: string) => Promise<void>;\n  nextLocalPlayer: () => Promise<void>;\n  updateSessionSettings: (settings: LocalSessionSettings) => Promise<void>;\n\n  // Internal helpers\n  _migrateSession: (rawSession: any) => LocalPlayerSession | null;\n}\n\n/**\n * Zustand store for local player state management\n * Handles session state, player management, and turn advancement\n */\nexport const useLocalPlayerStore = create<LocalPlayerState>()(\n  persist(\n    (set, get) => ({\n      // Initial state\n      session: null,\n      error: null,\n      isLoading: false,\n\n      // Getters\n      hasLocalPlayers: () => {\n        const session = get().session;\n        return session?.isActive === true && session.players.length > 0;\n      },\n\n      isLocalPlayerRoom: () => {\n        const session = get().session;\n        return session?.isActive === true;\n      },\n\n      getCurrentPlayer: () => {\n        const session = get().session;\n        if (!session?.isActive || !session.players || session.players.length === 0) {\n          return null;\n        }\n\n        const currentIndex = session.currentPlayerIndex || 0;\n        const player = session.players[currentIndex];\n        if (!player) return null;\n\n        // Migration: Ensure player has required fields (create copy to maintain immutability)\n        const migratedPlayer = { ...player };\n        if (typeof migratedPlayer.location !== 'number') {\n          migratedPlayer.location = 0;\n        }\n        if (typeof migratedPlayer.isFinished !== 'boolean') {\n          migratedPlayer.isFinished = false;\n        }\n\n        return migratedPlayer;\n      },\n\n      // Basic actions\n      setSession: (session) => {\n        // Migrate session if needed\n        const migratedSession = session ? get()._migrateSession(session) : null;\n        set({ session: migratedSession, error: null });\n      },\n\n      // Internal migration helper\n      _migrateSession: (rawSession: any): LocalPlayerSession | null => {\n        if (!rawSession || !rawSession.players) {\n          return rawSession;\n        }\n\n        // Migrate players to ensure they have required fields\n        const migratedPlayers = rawSession.players.map((player: any) => ({\n          ...player,\n          location: typeof player.location === 'number' ? player.location : 0,\n          isFinished: typeof player.isFinished === 'boolean' ? player.isFinished : false,\n          sound: player.sound || '',\n        }));\n\n        return {\n          ...rawSession,\n          players: migratedPlayers,\n        };\n      },\n\n      clearSession: () => {\n        localPlayerService.clearCurrentSession();\n        set({ session: null, error: null });\n      },\n\n      setError: (error) => {\n        set({ error, isLoading: false });\n      },\n\n      setLoading: (isLoading) => {\n        set({ isLoading });\n      },\n\n      // Async actions\n      initSession: async (roomId, players, settings) => {\n        try {\n          set({ isLoading: true, error: null });\n\n          const session = await localPlayerService.createSession(roomId, players, settings);\n\n          set({\n            session,\n            isLoading: false,\n            error: null,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to create session';\n          set({\n            error: errorMessage,\n            isLoading: false,\n            session: null,\n          });\n        }\n      },\n\n      loadSession: async (sessionId) => {\n        try {\n          set({ isLoading: true, error: null });\n\n          const session = await localPlayerService.getSession(sessionId);\n\n          set({\n            session,\n            isLoading: false,\n            error: null,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to load session';\n          set({\n            error: errorMessage,\n            isLoading: false,\n            session: null,\n          });\n        }\n      },\n\n      nextLocalPlayer: async () => {\n        try {\n          set({ isLoading: true, error: null });\n\n          const currentSession = get().session;\n          if (!currentSession) {\n            throw new Error('No active session');\n          }\n\n          // Advance turn through service\n          await localPlayerService.advanceLocalTurn(currentSession.id);\n\n          // Reload session to get updated state\n          const updatedSession = await localPlayerService.getSession(currentSession.id);\n\n          set({\n            session: updatedSession,\n            isLoading: false,\n            error: null,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to advance turn';\n          set({\n            error: errorMessage,\n            isLoading: false,\n          });\n        }\n      },\n\n      updateSessionSettings: async (settings) => {\n        try {\n          set({ isLoading: true, error: null });\n\n          const currentSession = get().session;\n          if (!currentSession) {\n            throw new Error('No active session');\n          }\n\n          // Update session settings through service\n          const updatedSession = await localPlayerService.updateSession(currentSession.id, {\n            settings,\n          });\n\n          set({\n            session: updatedSession,\n            isLoading: false,\n            error: null,\n          });\n        } catch (error) {\n          const errorMessage =\n            error instanceof Error ? error.message : 'Failed to update session settings';\n          set({\n            error: errorMessage,\n            isLoading: false,\n          });\n        }\n      },\n    }),\n    {\n      name: 'local-player-store',\n      // Only persist session data, not loading/error states\n      partialize: (state) => ({\n        session: state.session,\n      }),\n      // Skip hydration of loading/error states\n      onRehydrateStorage: () => (state) => {\n        if (state) {\n          state.isLoading = false;\n          state.error = null;\n        }\n      },\n    }\n  )\n);\n","import { useCallback, useMemo } from 'react';\nimport { useLocalPlayerStore } from '@/stores/localPlayerStore';\nimport type { LocalPlayer, LocalSessionSettings } from '@/types';\n\n/**\n * Hook for local player management in single-device multiplayer mode\n * Provides easy access to local player state and actions\n */\nexport function useLocalPlayers() {\n  // Get state from store\n  const {\n    session,\n    error,\n    isLoading,\n    hasLocalPlayers,\n    isLocalPlayerRoom,\n    getCurrentPlayer,\n    setSession,\n    clearSession,\n    setError,\n    setLoading,\n    initSession,\n    loadSession,\n    nextLocalPlayer,\n    updateSessionSettings,\n  } = useLocalPlayerStore();\n\n  // Memoized getters\n  const localPlayers = useMemo(() => session?.players || [], [session?.players]);\n  const currentPlayer = getCurrentPlayer();\n  const currentPlayerIndex = session?.currentPlayerIndex ?? -1;\n  const sessionSettings = session?.settings;\n\n  // Memoized actions\n  const createLocalSession = useCallback(\n    async (roomId: string, players: LocalPlayer[], settings: LocalSessionSettings) => {\n      await initSession(roomId, players, settings);\n    },\n    [initSession]\n  );\n\n  const loadLocalSession = useCallback(\n    async (sessionId: string) => {\n      await loadSession(sessionId);\n    },\n    [loadSession]\n  );\n\n  const advanceToNextPlayer = useCallback(async () => {\n    await nextLocalPlayer();\n  }, [nextLocalPlayer]);\n\n  const clearLocalSession = useCallback(() => {\n    clearSession();\n  }, [clearSession]);\n\n  const updateSettings = useCallback(\n    async (settings: LocalSessionSettings) => {\n      await updateSessionSettings(settings);\n    },\n    [updateSessionSettings]\n  );\n\n  // Utility functions\n  const getPlayerByIndex = useCallback(\n    (index: number): LocalPlayer | null => {\n      if (index >= 0 && index < localPlayers.length) {\n        return localPlayers[index];\n      }\n      return null;\n    },\n    [localPlayers]\n  );\n\n  const getPlayerById = useCallback(\n    (playerId: string): LocalPlayer | null => {\n      return localPlayers.find((player) => player.id === playerId) || null;\n    },\n    [localPlayers]\n  );\n\n  const isPlayerActive = useCallback(\n    (playerId: string): boolean => {\n      const player = getPlayerById(playerId);\n      return player?.isActive === true;\n    },\n    [getPlayerById]\n  );\n\n  const getNextPlayer = useCallback((): LocalPlayer | null => {\n    if (localPlayers.length === 0) return null;\n    const nextIndex = (currentPlayerIndex + 1) % localPlayers.length;\n    return getPlayerByIndex(nextIndex);\n  }, [localPlayers, currentPlayerIndex, getPlayerByIndex]);\n\n  const getPreviousPlayer = useCallback((): LocalPlayer | null => {\n    if (localPlayers.length === 0) return null;\n    const prevIndex = currentPlayerIndex === 0 ? localPlayers.length - 1 : currentPlayerIndex - 1;\n    return getPlayerByIndex(prevIndex);\n  }, [localPlayers, currentPlayerIndex, getPlayerByIndex]);\n\n  return {\n    // State\n    session,\n    localPlayers,\n    currentPlayer,\n    currentPlayerIndex,\n    sessionSettings,\n    error,\n    isLoading,\n\n    // Computed state\n    hasLocalPlayers: hasLocalPlayers(),\n    isLocalPlayerRoom: isLocalPlayerRoom(),\n    playerCount: localPlayers.length,\n    isValidSession: session?.isActive === true && localPlayers.length >= 2,\n\n    // Actions\n    createLocalSession,\n    loadLocalSession,\n    clearLocalSession,\n    advanceToNextPlayer,\n    updateSettings,\n\n    // Utilities\n    getPlayerByIndex,\n    getPlayerById,\n    isPlayerActive,\n    getNextPlayer,\n    getPreviousPlayer,\n\n    // Direct store access (for advanced use cases)\n    setSession,\n    setError,\n    setLoading,\n  };\n}\n"],"names":["_LocalPlayerService","__publicField","roomId","players","settings","sessionId","nanoid","now","initializedPlayers","player","session","dbSession","db","error","updates","existingSession","updatedSession","dbUpdate","nextIndex","updatedPlayers","index","playerId","newLocation","isFinished","playerIndex","p","playerIds","uniqueIds","playerNames","uniqueNames","LocalPlayerService","localPlayerService","useLocalPlayerStore","create","persist","set","get","currentIndex","migratedPlayer","migratedSession","rawSession","migratedPlayers","isLoading","errorMessage","currentSession","state","useLocalPlayers","hasLocalPlayers","isLocalPlayerRoom","getCurrentPlayer","setSession","clearSession","setError","setLoading","initSession","loadSession","nextLocalPlayer","updateSessionSettings","localPlayers","useMemo","currentPlayer","currentPlayerIndex","sessionSettings","createLocalSession","useCallback","loadLocalSession","advanceToNextPlayer","clearLocalSession","updateSettings","getPlayerByIndex","getPlayerById","isPlayerActive","getNextPlayer","getPreviousPlayer","prevIndex"],"mappings":"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"}