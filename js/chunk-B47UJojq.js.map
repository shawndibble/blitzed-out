{"version":3,"file":"chunk-B47UJojq.js","sources":["../../src/services/localPlayerService.ts","../../src/stores/localPlayerStore.ts","../../src/hooks/useLocalPlayers.ts"],"sourcesContent":["import { nanoid } from 'nanoid';\nimport db from '@/stores/store';\nimport type {\n  LocalPlayer,\n  LocalPlayerSession,\n  LocalSessionSettings,\n  DBLocalPlayerSession,\n} from '@/types';\n\n/**\n * Service for managing local player sessions in single-device multiplayer mode\n * Handles session creation, player management, and turn advancement\n */\nexport class LocalPlayerService {\n  private static instance: LocalPlayerService;\n  private currentSession: LocalPlayerSession | null = null;\n\n  private constructor() {\n    // Private constructor for singleton pattern\n  }\n\n  /**\n   * Get singleton instance of LocalPlayerService\n   */\n  public static getInstance(): LocalPlayerService {\n    if (!LocalPlayerService.instance) {\n      LocalPlayerService.instance = new LocalPlayerService();\n    }\n    return LocalPlayerService.instance;\n  }\n\n  /**\n   * Create a new local player session\n   * @param roomId - The room ID this session belongs to\n   * @param players - Array of local players\n   * @param settings - Session settings\n   * @returns Promise<LocalPlayerSession> - The created session\n   */\n  public async createSession(\n    roomId: string,\n    players: LocalPlayer[],\n    settings: LocalSessionSettings\n  ): Promise<LocalPlayerSession> {\n    try {\n      // Validate input\n      this.validateSessionInput(roomId, players, settings);\n\n      const sessionId = nanoid();\n      const now = Date.now();\n\n      // Initialize players with starting positions\n      const initializedPlayers = players.map((player) => ({\n        ...player,\n        location: player.location ?? 0, // Start at position 0 if not specified\n        isFinished: player.isFinished ?? false, // Not finished by default\n      }));\n\n      const session: LocalPlayerSession = {\n        id: sessionId,\n        roomId,\n        players: initializedPlayers,\n        currentPlayerIndex: 0,\n        isActive: true,\n        createdAt: now,\n        updatedAt: now,\n        settings: { ...settings },\n      };\n\n      // Prepare database entry\n      const dbSession: DBLocalPlayerSession = {\n        sessionId: session.id,\n        roomId: session.roomId,\n        players: session.players,\n        currentPlayerIndex: session.currentPlayerIndex,\n        isActive: session.isActive,\n        createdAt: session.createdAt,\n        updatedAt: session.updatedAt,\n        settings: session.settings,\n      };\n\n      // Save to database\n      await db.localPlayerSessions.add(dbSession);\n\n      // Set as current session\n      this.currentSession = session;\n\n      return session;\n    } catch (error) {\n      throw new Error(\n        `Failed to create local player session: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Get an existing local player session by ID\n   * @param sessionId - The session ID to retrieve\n   * @returns Promise<LocalPlayerSession | null> - The session or null if not found\n   */\n  public async getSession(sessionId: string): Promise<LocalPlayerSession | null> {\n    try {\n      if (!sessionId) {\n        throw new Error('Session ID is required');\n      }\n\n      const dbSession = await db.localPlayerSessions.where('sessionId').equals(sessionId).first();\n\n      if (!dbSession) {\n        return null;\n      }\n\n      return this.convertDbSessionToSession(dbSession);\n    } catch (error) {\n      throw new Error(\n        `Failed to get session: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Update an existing local player session\n   * @param sessionId - The session ID to update\n   * @param updates - Partial session data to update\n   * @returns Promise<LocalPlayerSession> - The updated session\n   */\n  public async updateSession(\n    sessionId: string,\n    updates: Partial<Omit<LocalPlayerSession, 'id' | 'createdAt'>>\n  ): Promise<LocalPlayerSession> {\n    try {\n      if (!sessionId) {\n        throw new Error('Session ID is required');\n      }\n\n      const existingSession = await this.getSession(sessionId);\n      if (!existingSession) {\n        throw new Error('Session not found');\n      }\n\n      const updatedSession: LocalPlayerSession = {\n        ...existingSession,\n        ...updates,\n        id: sessionId, // Ensure ID cannot be changed\n        createdAt: existingSession.createdAt, // Ensure createdAt cannot be changed\n        updatedAt: Date.now(),\n      };\n\n      // Prepare database update\n      const dbUpdate: Partial<DBLocalPlayerSession> = {\n        roomId: updatedSession.roomId,\n        players: updatedSession.players,\n        currentPlayerIndex: updatedSession.currentPlayerIndex,\n        isActive: updatedSession.isActive,\n        updatedAt: updatedSession.updatedAt,\n        settings: updatedSession.settings,\n      };\n\n      // Update in database\n      await db.localPlayerSessions.where('sessionId').equals(sessionId).modify(dbUpdate);\n\n      // Update current session if it's the same\n      if (this.currentSession?.id === sessionId) {\n        this.currentSession = updatedSession;\n      }\n\n      return updatedSession;\n    } catch (error) {\n      throw new Error(\n        `Failed to update session: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Advance to the next local player in turn order\n   * @param sessionId - The session ID to advance turn for\n   * @returns Promise<LocalPlayer> - The next active player\n   */\n  public async advanceLocalTurn(sessionId: string): Promise<LocalPlayer> {\n    try {\n      if (!sessionId) {\n        throw new Error('Session ID is required');\n      }\n\n      const session = await this.getSession(sessionId);\n      if (!session) {\n        throw new Error('Session not found');\n      }\n\n      if (!session.isActive) {\n        throw new Error('Cannot advance turn on inactive session');\n      }\n\n      if (session.players.length === 0) {\n        throw new Error('No players in session');\n      }\n\n      // Calculate next player index (wrap around)\n      const nextIndex = (session.currentPlayerIndex + 1) % session.players.length;\n\n      // Update current player active states\n      const updatedPlayers = session.players.map((player, index) => ({\n        ...player,\n        isActive: index === nextIndex,\n      }));\n\n      // Update session\n      const updatedSession = await this.updateSession(sessionId, {\n        players: updatedPlayers,\n        currentPlayerIndex: nextIndex,\n      });\n\n      return updatedSession.players[nextIndex];\n    } catch (error) {\n      throw new Error(\n        `Failed to advance turn: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Get the current active session\n   * @returns LocalPlayerSession | null - The current session or null\n   */\n  public getCurrentSession(): LocalPlayerSession | null {\n    return this.currentSession;\n  }\n\n  /**\n   * Update a specific local player's position on the game board\n   * @param sessionId - The session ID containing the player\n   * @param playerId - The local player ID to update\n   * @param newLocation - New board position (0-based index)\n   * @param isFinished - Whether the player has finished the game\n   * @returns Promise<LocalPlayer> - The updated player\n   */\n  public async updatePlayerPosition(\n    sessionId: string,\n    playerId: string,\n    newLocation: number,\n    isFinished: boolean = false\n  ): Promise<LocalPlayer> {\n    try {\n      if (!sessionId) {\n        throw new Error('Session ID is required');\n      }\n      if (!playerId) {\n        throw new Error('Player ID is required');\n      }\n      if (newLocation < 0) {\n        throw new Error('Location must be non-negative');\n      }\n\n      const session = await this.getSession(sessionId);\n      if (!session) {\n        throw new Error('Session not found');\n      }\n\n      if (!session.isActive) {\n        throw new Error('Cannot update player position on inactive session');\n      }\n\n      // Find and update the specific player\n      const playerIndex = session.players.findIndex((p) => p.id === playerId);\n      if (playerIndex === -1) {\n        throw new Error(`Player with ID ${playerId} not found in session`);\n      }\n\n      const updatedPlayers = [...session.players];\n      updatedPlayers[playerIndex] = {\n        ...updatedPlayers[playerIndex],\n        location: newLocation,\n        isFinished,\n      };\n\n      // Update session\n      await this.updateSession(sessionId, {\n        players: updatedPlayers,\n      });\n\n      return updatedPlayers[playerIndex];\n    } catch (error) {\n      throw new Error(\n        `Failed to update player position: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Clear the current session (does not delete from database)\n   */\n  public clearCurrentSession(): void {\n    this.currentSession = null;\n  }\n\n  /**\n   * Validate session input parameters\n   * @private\n   */\n  private validateSessionInput(\n    roomId: string,\n    players: LocalPlayer[],\n    settings: LocalSessionSettings\n  ): void {\n    if (!roomId || typeof roomId !== 'string') {\n      throw new Error('Valid room ID is required');\n    }\n\n    if (!Array.isArray(players) || players.length < 2 || players.length > 4) {\n      throw new Error('Session must have between 2 and 4 players');\n    }\n\n    // Validate each player\n    players.forEach((player, index) => {\n      if (!player.id || typeof player.id !== 'string') {\n        throw new Error(`Player at index ${index} must have a valid ID`);\n      }\n      if (!player.name || typeof player.name !== 'string') {\n        throw new Error(`Player at index ${index} must have a valid name`);\n      }\n      if (!['sub', 'dom', 'vers'].includes(player.role)) {\n        throw new Error(`Player at index ${index} must have a valid role`);\n      }\n      if (\n        typeof player.location !== 'undefined' &&\n        (typeof player.location !== 'number' || player.location < 0)\n      ) {\n        throw new Error(\n          `Player at index ${index} must have a valid location (non-negative number)`\n        );\n      }\n    });\n\n    // Check for duplicate player IDs\n    const playerIds = players.map((p) => p.id);\n    const uniqueIds = new Set(playerIds);\n    if (playerIds.length !== uniqueIds.size) {\n      throw new Error('All players must have unique IDs');\n    }\n\n    // Check for duplicate player names\n    const playerNames = players.map((p) => p.name.toLowerCase());\n    const uniqueNames = new Set(playerNames);\n    if (playerNames.length !== uniqueNames.size) {\n      throw new Error('All players must have unique names');\n    }\n\n    if (!settings || typeof settings !== 'object') {\n      throw new Error('Valid settings object is required');\n    }\n  }\n\n  /**\n   * Convert database session to session object\n   * @private\n   */\n  private convertDbSessionToSession(dbSession: DBLocalPlayerSession): LocalPlayerSession {\n    return {\n      id: dbSession.sessionId,\n      roomId: dbSession.roomId,\n      players: dbSession.players,\n      currentPlayerIndex: dbSession.currentPlayerIndex,\n      isActive: dbSession.isActive,\n      createdAt: dbSession.createdAt,\n      updatedAt: dbSession.updatedAt,\n      settings: dbSession.settings,\n    };\n  }\n}\n\n// Export singleton instance\nexport const localPlayerService = LocalPlayerService.getInstance();\n","import type { LocalPlayer, LocalPlayerSession, LocalSessionSettings } from '@/types';\n\nimport { create } from 'zustand';\nimport { localPlayerService } from '@/services/localPlayerService';\nimport { persist } from 'zustand/middleware';\n\n/**\n * State interface for local player store\n */\ninterface LocalPlayerState {\n  // Current session data\n  session: LocalPlayerSession | null;\n\n  // Error state\n  error: string | null;\n\n  // Loading state\n  isLoading: boolean;\n\n  // Getters\n  hasLocalPlayers: () => boolean;\n  isLocalPlayerRoom: () => boolean;\n  getCurrentPlayer: () => LocalPlayer | null;\n\n  // Actions\n  setSession: (session: LocalPlayerSession | null) => void;\n  clearSession: () => void;\n  setError: (error: string | null) => void;\n  setLoading: (loading: boolean) => void;\n\n  // Async actions\n  initSession: (\n    roomId: string,\n    players: LocalPlayer[],\n    settings: LocalSessionSettings\n  ) => Promise<void>;\n  loadSession: (sessionId: string) => Promise<void>;\n  nextLocalPlayer: () => Promise<void>;\n  updateSessionSettings: (settings: LocalSessionSettings) => Promise<void>;\n\n  // Internal helpers\n  _migrateSession: (rawSession: any) => LocalPlayerSession | null;\n}\n\n/**\n * Zustand store for local player state management\n * Handles session state, player management, and turn advancement\n */\nexport const useLocalPlayerStore = create<LocalPlayerState>()(\n  persist(\n    (set, get) => ({\n      // Initial state\n      session: null,\n      error: null,\n      isLoading: false,\n\n      // Getters\n      hasLocalPlayers: () => {\n        const session = get().session;\n        return session?.isActive === true && session.players.length > 0;\n      },\n\n      isLocalPlayerRoom: () => {\n        const session = get().session;\n        return session?.isActive === true;\n      },\n\n      getCurrentPlayer: () => {\n        const session = get().session;\n        if (!session?.isActive || !session.players || session.players.length === 0) {\n          return null;\n        }\n\n        const currentIndex = session.currentPlayerIndex || 0;\n        const player = session.players[currentIndex];\n        if (!player) return null;\n\n        // Migration: Ensure player has required fields (create copy to maintain immutability)\n        const migratedPlayer = { ...player };\n        if (typeof migratedPlayer.location !== 'number') {\n          migratedPlayer.location = 0;\n        }\n        if (typeof migratedPlayer.isFinished !== 'boolean') {\n          migratedPlayer.isFinished = false;\n        }\n\n        return migratedPlayer;\n      },\n\n      // Basic actions\n      setSession: (session) => {\n        // Migrate session if needed\n        const migratedSession = session ? get()._migrateSession(session) : null;\n        set({ session: migratedSession, error: null });\n      },\n\n      // Internal migration helper\n      _migrateSession: (rawSession: any): LocalPlayerSession | null => {\n        if (!rawSession || !rawSession.players) {\n          return rawSession;\n        }\n\n        // Migrate players to ensure they have required fields\n        const migratedPlayers = rawSession.players.map((player: any) => ({\n          ...player,\n          location: typeof player.location === 'number' ? player.location : 0,\n          isFinished: typeof player.isFinished === 'boolean' ? player.isFinished : false,\n          sound: player.sound || '',\n        }));\n\n        return {\n          ...rawSession,\n          players: migratedPlayers,\n        };\n      },\n\n      clearSession: () => {\n        localPlayerService.clearCurrentSession();\n        set({ session: null, error: null });\n      },\n\n      setError: (error) => {\n        set({ error, isLoading: false });\n      },\n\n      setLoading: (isLoading) => {\n        set({ isLoading });\n      },\n\n      // Async actions\n      initSession: async (roomId, players, settings) => {\n        try {\n          set({ isLoading: true, error: null });\n\n          const session = await localPlayerService.createSession(roomId, players, settings);\n\n          set({\n            session,\n            isLoading: false,\n            error: null,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to create session';\n          set({\n            error: errorMessage,\n            isLoading: false,\n            session: null,\n          });\n        }\n      },\n\n      loadSession: async (sessionId) => {\n        try {\n          set({ isLoading: true, error: null });\n\n          const session = await localPlayerService.getSession(sessionId);\n\n          set({\n            session,\n            isLoading: false,\n            error: null,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to load session';\n          set({\n            error: errorMessage,\n            isLoading: false,\n            session: null,\n          });\n        }\n      },\n\n      nextLocalPlayer: async () => {\n        try {\n          set({ isLoading: true, error: null });\n\n          const currentSession = get().session;\n          if (!currentSession) {\n            throw new Error('No active session');\n          }\n\n          // Advance turn through service\n          await localPlayerService.advanceLocalTurn(currentSession.id);\n\n          // Reload session to get updated state\n          const updatedSession = await localPlayerService.getSession(currentSession.id);\n\n          set({\n            session: updatedSession,\n            isLoading: false,\n            error: null,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to advance turn';\n          set({\n            error: errorMessage,\n            isLoading: false,\n          });\n        }\n      },\n\n      updateSessionSettings: async (settings) => {\n        try {\n          set({ isLoading: true, error: null });\n\n          const currentSession = get().session;\n          if (!currentSession) {\n            throw new Error('No active session');\n          }\n\n          // Update session settings through service\n          const updatedSession = await localPlayerService.updateSession(currentSession.id, {\n            settings,\n          });\n\n          set({\n            session: updatedSession,\n            isLoading: false,\n            error: null,\n          });\n        } catch (error) {\n          const errorMessage =\n            error instanceof Error ? error.message : 'Failed to update session settings';\n          set({\n            error: errorMessage,\n            isLoading: false,\n          });\n        }\n      },\n    }),\n    {\n      name: 'local-player-store',\n      // Only persist session data, not loading/error states\n      partialize: (state) => ({\n        session: state.session,\n      }),\n      // Skip hydration of loading/error states\n      onRehydrateStorage: () => (state) => {\n        if (state) {\n          state.isLoading = false;\n          state.error = null;\n        }\n      },\n    }\n  )\n);\n","import { useCallback, useMemo } from 'react';\nimport { useLocalPlayerStore } from '@/stores/localPlayerStore';\nimport type { LocalPlayer, LocalSessionSettings } from '@/types';\n\n/**\n * Hook for local player management in single-device multiplayer mode\n * Provides easy access to local player state and actions\n */\nexport function useLocalPlayers() {\n  // Get state from store\n  const {\n    session,\n    error,\n    isLoading,\n    hasLocalPlayers,\n    isLocalPlayerRoom,\n    getCurrentPlayer,\n    setSession,\n    clearSession,\n    setError,\n    setLoading,\n    initSession,\n    loadSession,\n    nextLocalPlayer,\n    updateSessionSettings,\n  } = useLocalPlayerStore();\n\n  // Memoized getters\n  const localPlayers = useMemo(() => session?.players || [], [session?.players]);\n  const currentPlayer = getCurrentPlayer();\n  const currentPlayerIndex = session?.currentPlayerIndex ?? -1;\n  const sessionSettings = session?.settings;\n\n  // Memoized actions\n  const createLocalSession = useCallback(\n    async (roomId: string, players: LocalPlayer[], settings: LocalSessionSettings) => {\n      await initSession(roomId, players, settings);\n    },\n    [initSession]\n  );\n\n  const loadLocalSession = useCallback(\n    async (sessionId: string) => {\n      await loadSession(sessionId);\n    },\n    [loadSession]\n  );\n\n  const advanceToNextPlayer = useCallback(async () => {\n    await nextLocalPlayer();\n  }, [nextLocalPlayer]);\n\n  const clearLocalSession = useCallback(() => {\n    clearSession();\n  }, [clearSession]);\n\n  const updateSettings = useCallback(\n    async (settings: LocalSessionSettings) => {\n      await updateSessionSettings(settings);\n    },\n    [updateSessionSettings]\n  );\n\n  // Utility functions\n  const getPlayerByIndex = useCallback(\n    (index: number): LocalPlayer | null => {\n      if (index >= 0 && index < localPlayers.length) {\n        return localPlayers[index];\n      }\n      return null;\n    },\n    [localPlayers]\n  );\n\n  const getPlayerById = useCallback(\n    (playerId: string): LocalPlayer | null => {\n      return localPlayers.find((player) => player.id === playerId) || null;\n    },\n    [localPlayers]\n  );\n\n  const isPlayerActive = useCallback(\n    (playerId: string): boolean => {\n      const player = getPlayerById(playerId);\n      return player?.isActive === true;\n    },\n    [getPlayerById]\n  );\n\n  const getNextPlayer = useCallback((): LocalPlayer | null => {\n    if (localPlayers.length === 0) return null;\n    const nextIndex = (currentPlayerIndex + 1) % localPlayers.length;\n    return getPlayerByIndex(nextIndex);\n  }, [localPlayers, currentPlayerIndex, getPlayerByIndex]);\n\n  const getPreviousPlayer = useCallback((): LocalPlayer | null => {\n    if (localPlayers.length === 0) return null;\n    const prevIndex = currentPlayerIndex === 0 ? localPlayers.length - 1 : currentPlayerIndex - 1;\n    return getPlayerByIndex(prevIndex);\n  }, [localPlayers, currentPlayerIndex, getPlayerByIndex]);\n\n  return {\n    // State\n    session,\n    localPlayers,\n    currentPlayer,\n    currentPlayerIndex,\n    sessionSettings,\n    error,\n    isLoading,\n\n    // Computed state\n    hasLocalPlayers: hasLocalPlayers(),\n    isLocalPlayerRoom: isLocalPlayerRoom(),\n    playerCount: localPlayers.length,\n    isValidSession: session?.isActive === true && localPlayers.length >= 2,\n\n    // Actions\n    createLocalSession,\n    loadLocalSession,\n    clearLocalSession,\n    advanceToNextPlayer,\n    updateSettings,\n\n    // Utilities\n    getPlayerByIndex,\n    getPlayerById,\n    isPlayerActive,\n    getNextPlayer,\n    getPreviousPlayer,\n\n    // Direct store access (for advanced use cases)\n    setSession,\n    setError,\n    setLoading,\n  };\n}\n"],"names":["_LocalPlayerService","__publicField","roomId","players","settings","sessionId","nanoid","now","initializedPlayers","player","_a","_b","session","dbSession","db","error","updates","existingSession","updatedSession","dbUpdate","nextIndex","updatedPlayers","index","playerId","newLocation","isFinished","playerIndex","p","playerIds","uniqueIds","playerNames","uniqueNames","LocalPlayerService","localPlayerService","useLocalPlayerStore","create","persist","set","get","currentIndex","migratedPlayer","migratedSession","rawSession","migratedPlayers","isLoading","errorMessage","currentSession","state","useLocalPlayers","hasLocalPlayers","isLocalPlayerRoom","getCurrentPlayer","setSession","clearSession","setError","setLoading","initSession","loadSession","nextLocalPlayer","updateSessionSettings","localPlayers","useMemo","currentPlayer","currentPlayerIndex","sessionSettings","createLocalSession","useCallback","loadLocalSession","advanceToNextPlayer","clearLocalSession","updateSettings","getPlayerByIndex","getPlayerById","isPlayerActive","getNextPlayer","getPreviousPlayer","prevIndex"],"mappings":"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"}