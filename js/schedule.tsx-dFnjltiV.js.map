{"version":3,"file":"schedule.tsx-dFnjltiV.js","sources":["../../src/stores/scheduleStore.ts","../../src/context/schedule.tsx"],"sourcesContent":["import { create } from 'zustand';\nimport { ScheduleItem } from '@/context/schedule';\nimport dayjs from 'dayjs';\n\n// Performance tracking and caching\ninterface ScheduleCache {\n  upcomingSchedule: { data: ScheduleItem[]; timestamp: number; limit: number };\n  roomSchedule: Record<string, { data: ScheduleItem[]; timestamp: number }>;\n}\n\ninterface PerformanceMetrics {\n  lastUpdateTime: number;\n  updateCount: number;\n  cacheHitRate: number;\n}\n\ninterface ScheduleStore {\n  // State\n  schedule: ScheduleItem[];\n  loading: boolean;\n  error: string | null;\n  _cache: ScheduleCache;\n  _performanceMetrics: PerformanceMetrics;\n  _pendingUpdates: ScheduleItem[];\n  _batchTimeout: NodeJS.Timeout | null;\n\n  // Actions\n  loadSchedule: (schedule: ScheduleItem[]) => void;\n  addScheduleItem: (item: ScheduleItem) => void;\n  removeScheduleItem: (id: string) => void;\n  clearSchedule: () => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n\n  // Performance optimized actions\n  batchAddScheduleItems: (items: ScheduleItem[]) => void;\n  flushPendingScheduleUpdates: () => void;\n  invalidateCache: () => void;\n\n  // Selectors with caching\n  getUpcomingSchedule: (limit?: number) => ScheduleItem[];\n  getScheduleByRoom: (room: string) => ScheduleItem[];\n  getPerformanceMetrics: () => PerformanceMetrics;\n}\n\n// Cache timeout for schedule data (5 minutes)\nconst CACHE_TIMEOUT = 5 * 60 * 1000;\nconst SCHEDULE_BATCH_DELAY = 100; // 100ms debounce for schedule updates\n\nexport const useScheduleStore = create<ScheduleStore>((set, get) => ({\n  // State\n  schedule: [],\n  loading: false,\n  error: null,\n  _cache: {\n    upcomingSchedule: { data: [], timestamp: 0, limit: 0 },\n    roomSchedule: {},\n  },\n  _performanceMetrics: {\n    lastUpdateTime: Date.now(),\n    updateCount: 0,\n    cacheHitRate: 0,\n  },\n  _pendingUpdates: [],\n  _batchTimeout: null,\n\n  // Actions\n  loadSchedule: (schedule) => {\n    const now = Date.now();\n    set((state) => {\n      const newUpdateCount = state._performanceMetrics.updateCount + 1;\n\n      return {\n        schedule,\n        loading: false,\n        error: null,\n        _performanceMetrics: {\n          lastUpdateTime: now,\n          updateCount: newUpdateCount,\n          cacheHitRate: state._performanceMetrics.cacheHitRate,\n        },\n      };\n    });\n\n    // Invalidate cache when new data is loaded\n    get().invalidateCache();\n  },\n\n  addScheduleItem: (item) => {\n    const state = get();\n\n    // Add item to pending updates\n    set((prevState) => ({\n      _pendingUpdates: [...prevState._pendingUpdates, item],\n    }));\n\n    // Clear existing timeout and set new one\n    if (state._batchTimeout) {\n      clearTimeout(state._batchTimeout);\n    }\n\n    const newTimeout = setTimeout(() => {\n      get().flushPendingScheduleUpdates();\n    }, SCHEDULE_BATCH_DELAY);\n\n    set(() => ({ _batchTimeout: newTimeout }));\n  },\n\n  batchAddScheduleItems: (items) =>\n    set((state) => {\n      const newSchedule = [...state.schedule, ...items];\n      const now = Date.now();\n      const newUpdateCount = state._performanceMetrics.updateCount + 1;\n\n      return {\n        schedule: newSchedule,\n        _performanceMetrics: {\n          lastUpdateTime: now,\n          updateCount: newUpdateCount,\n          cacheHitRate: state._performanceMetrics.cacheHitRate,\n        },\n      };\n    }),\n\n  flushPendingScheduleUpdates: () => {\n    const state = get();\n    if (state._pendingUpdates.length === 0) return;\n\n    // Clear the timeout as we're flushing now\n    if (state._batchTimeout) {\n      clearTimeout(state._batchTimeout);\n    }\n\n    state.batchAddScheduleItems(state._pendingUpdates);\n    set(() => ({\n      _pendingUpdates: [],\n      _batchTimeout: null,\n    }));\n    state.invalidateCache();\n  },\n\n  removeScheduleItem: (id) => {\n    set((state) => ({\n      schedule: state.schedule.filter((item) => item.id !== id),\n    }));\n    get().invalidateCache();\n  },\n\n  clearSchedule: () => {\n    const state = get();\n\n    // Clear any pending timeout\n    if (state._batchTimeout) {\n      clearTimeout(state._batchTimeout);\n    }\n\n    set(() => ({\n      schedule: [],\n      loading: false,\n      error: null,\n      _pendingUpdates: [],\n      _batchTimeout: null,\n    }));\n    get().invalidateCache();\n  },\n\n  invalidateCache: () =>\n    set(() => ({\n      _cache: {\n        upcomingSchedule: { data: [], timestamp: 0, limit: 0 },\n        roomSchedule: {},\n      },\n    })),\n\n  setLoading: (loading) => set(() => ({ loading })),\n\n  setError: (error) => set(() => ({ error, loading: false })),\n\n  // Selectors with caching\n  getUpcomingSchedule: (limit = 10) => {\n    const state = get();\n    const now = Date.now();\n\n    // Check cache validity\n    const cache = state._cache.upcomingSchedule;\n    const isCacheValid =\n      cache.timestamp > 0 && now - cache.timestamp < CACHE_TIMEOUT && cache.limit >= limit;\n\n    if (isCacheValid) {\n      // Update cache hit rate\n      const totalRequests = state._performanceMetrics.updateCount + 1;\n      const currentHits = state._performanceMetrics.cacheHitRate * (totalRequests - 1);\n      const newHitRate = (currentHits + 1) / totalRequests;\n\n      set((prevState) => ({\n        _performanceMetrics: {\n          ...prevState._performanceMetrics,\n          cacheHitRate: newHitRate,\n        },\n      }));\n\n      return cache.data.slice(0, limit);\n    }\n\n    // Calculate and cache result\n    const currentTime = dayjs();\n    const upcoming = state.schedule\n      .filter((item) => item.dateTime.isAfter(currentTime))\n      .sort((a, b) => a.dateTime.valueOf() - b.dateTime.valueOf())\n      .slice(0, Math.max(limit, 20)); // Cache extra items for future requests\n\n    // Update cache\n    set((prevState) => ({\n      _cache: {\n        ...prevState._cache,\n        upcomingSchedule: {\n          data: upcoming,\n          timestamp: now,\n          limit: Math.max(limit, 20),\n        },\n      },\n    }));\n\n    return upcoming.slice(0, limit);\n  },\n\n  getScheduleByRoom: (room) => {\n    const state = get();\n    const now = Date.now();\n\n    // Check cache validity\n    const cache = state._cache.roomSchedule[room];\n    const isCacheValid = cache && cache.timestamp > 0 && now - cache.timestamp < CACHE_TIMEOUT;\n\n    if (isCacheValid) {\n      // Update cache hit rate\n      const totalRequests = state._performanceMetrics.updateCount + 1;\n      const currentHits = state._performanceMetrics.cacheHitRate * (totalRequests - 1);\n      const newHitRate = (currentHits + 1) / totalRequests;\n\n      set((prevState) => ({\n        _performanceMetrics: {\n          ...prevState._performanceMetrics,\n          cacheHitRate: newHitRate,\n        },\n      }));\n\n      return cache.data;\n    }\n\n    // Calculate and cache result\n    const roomSchedule = state.schedule.filter((item) => item.room === room);\n\n    // Update cache\n    set((prevState) => ({\n      _cache: {\n        ...prevState._cache,\n        roomSchedule: {\n          ...prevState._cache.roomSchedule,\n          [room]: {\n            data: roomSchedule,\n            timestamp: now,\n          },\n        },\n      },\n    }));\n\n    return roomSchedule;\n  },\n\n  getPerformanceMetrics: () => {\n    const state = get();\n    return state._performanceMetrics;\n  },\n}));\n\n// Compatibility selectors for optimized subscriptions\nexport const useScheduleItems = () => useScheduleStore((state) => state.schedule);\nexport const useScheduleLoading = () => useScheduleStore((state) => state.loading);\nexport const useScheduleError = () => useScheduleStore((state) => state.error);\nexport const useUpcomingSchedule = (limit?: number) =>\n  useScheduleStore((state) => state.getUpcomingSchedule(limit));\n\n// Performance-optimized hooks\nexport const useSchedulePerformance = () =>\n  useScheduleStore((state) => state.getPerformanceMetrics());\n\n// Memoized selectors for better performance\nexport const useScheduleCount = () => useScheduleStore((state) => state.schedule.length);\nexport const useHasSchedule = () => useScheduleStore((state) => state.schedule.length > 0);\nexport const useScheduleByRoom = (room: string) =>\n  useScheduleStore((state) => state.getScheduleByRoom(room));\n\n// Cached selectors that prevent recalculation\nexport const useCachedUpcomingSchedule = (limit = 10) =>\n  useScheduleStore((state) => {\n    const cached = state._cache.upcomingSchedule;\n    const now = Date.now();\n    const isCacheValid =\n      cached.timestamp > 0 && now - cached.timestamp < 5 * 60 * 1000 && cached.limit >= limit;\n\n    return isCacheValid ? cached.data.slice(0, limit) : state.getUpcomingSchedule(limit);\n  });\n\n// Specific schedule item selectors\nexport const useScheduleItem = (id: string) =>\n  useScheduleStore((state) => state.schedule.find((item) => item.id === id));\n","import React, { useMemo, useEffect, useCallback, ReactNode, useRef } from 'react';\nimport { getSchedule, addSchedule } from '@/services/firebase';\nimport { DocumentReference, DocumentData } from 'firebase/firestore';\nimport dayjs from 'dayjs';\nimport { useScheduleStore } from '@/stores/scheduleStore';\n\nexport interface ScheduleItem {\n  id?: string;\n  dateTime: dayjs.Dayjs;\n  url: string;\n  room: string;\n  [key: string]: any;\n}\n\nexport interface ScheduleContextType {\n  schedule: ScheduleItem[];\n  addToSchedule: (\n    dateTime: Date,\n    url: string,\n    room?: string\n  ) => Promise<undefined | DocumentReference<DocumentData>>;\n}\n\n// eslint-disable-next-line react-refresh/only-export-components\nexport const ScheduleContext = React.createContext<ScheduleContextType | undefined>(undefined);\n\ninterface ScheduleProviderProps {\n  children: ReactNode;\n  [key: string]: any;\n}\n\nfunction ScheduleProvider(props: ScheduleProviderProps): JSX.Element {\n  const { schedule, loadSchedule, flushPendingScheduleUpdates } = useScheduleStore();\n  const unsubscribeRef = useRef<(() => void) | null>(null);\n\n  // Optimized schedule update handler\n  const handleScheduleUpdate = useCallback(\n    (newSchedule: Array<Record<string, unknown>>) => {\n      loadSchedule(newSchedule as unknown as ScheduleItem[]);\n    },\n    [loadSchedule]\n  );\n\n  // Memoized addToSchedule function to prevent unnecessary re-renders\n  const memoizedAddToSchedule = useCallback(\n    async (\n      dateTime: Date,\n      url: string,\n      room?: string\n    ): Promise<undefined | DocumentReference<DocumentData>> => {\n      try {\n        const result = await addSchedule(dateTime, url, room);\n        // Flush any pending updates after adding\n        flushPendingScheduleUpdates();\n        return result || undefined;\n      } catch (error) {\n        console.error('Error adding to schedule:', error);\n        throw error;\n      }\n    },\n    [flushPendingScheduleUpdates]\n  );\n\n  // Cleanup function for Firebase listener\n  const cleanup = useCallback(() => {\n    if (unsubscribeRef.current) {\n      unsubscribeRef.current();\n      unsubscribeRef.current = null;\n    }\n    // Flush any pending updates before cleanup\n    flushPendingScheduleUpdates();\n  }, [flushPendingScheduleUpdates]);\n\n  useEffect(() => {\n    // Clean up previous listener\n    cleanup();\n\n    // Set up new listener\n    unsubscribeRef.current = getSchedule(handleScheduleUpdate);\n\n    // Cleanup on unmount\n    return cleanup;\n  }, [handleScheduleUpdate, cleanup]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return cleanup;\n  }, [cleanup]);\n\n  // Memoized context value with stable references\n  const value: ScheduleContextType = useMemo(\n    () => ({\n      schedule,\n      addToSchedule: memoizedAddToSchedule,\n    }),\n    [schedule, memoizedAddToSchedule]\n  );\n\n  return <ScheduleContext.Provider value={value} {...props} />;\n}\n\nexport { ScheduleProvider };\n"],"names":["CACHE_TIMEOUT","SCHEDULE_BATCH_DELAY","useScheduleStore","create","set","get","schedule","now","state","newUpdateCount","item","prevState","newTimeout","items","newSchedule","id","loading","error","limit","cache","totalRequests","newHitRate","currentTime","dayjs","upcoming","a","b","room","roomSchedule","ScheduleContext","React","ScheduleProvider","props","loadSchedule","flushPendingScheduleUpdates","unsubscribeRef","useRef","handleScheduleUpdate","useCallback","memoizedAddToSchedule","dateTime","url","result","addSchedule","cleanup","useEffect","getSchedule","value","useMemo"],"mappings":"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"}