{"version":3,"mappings":"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","names":["parseMessageTimestamp","timestamp","date","timestampMs","timestampObj","error","normalSortedMessages","messages","a","b","aDate","bDate","sortedMessages","latestMessageByType","type","m","orderedMessagesByType","order","sorted","latestMessageBy","callback","latestMessage","initialState","useMessagesStore","create","persist","set","get","message","msg","newMessages","id","updates","hasChanges","updatedMessages","updatedMsg","key","loading","currentLoading","currentError","room","currentRoom","cursor","currentCursor","filtered","i","predicate","state","twentyFourHoursAgo","validMessages","messageTime","MessagesContext","React","MessagesProvider","props","useParams","isLoading","loadMessages","setLoading","setRoom","clearMessages","useEffect","getMessages","value","UserListProvider","lazy","UnauthenticatedApp","__vitePreload","Cast","Room","n","UppercaseRedirect","children","navigate","useNavigate","location","useLocation","newPath","AppRoutes","auth","useContext","AuthContext","AppSkeleton","Routes","jsx","Route","Navigate","Suspense","RouterSetup","BrowserRouter"],"ignoreList":[],"sources":["../../src/helpers/timestamp.ts","../../src/helpers/messages.ts","../../src/stores/messagesStore.ts","../../src/context/messages.tsx","../../src/components/RouterSetup/index.tsx"],"sourcesContent":["/**\n * Parses various timestamp formats into a Date object\n * @param timestamp - The timestamp to parse (Firebase Timestamp, string, number, object, or Date)\n * @returns Date object if parsing succeeds, null if it fails\n */\nexport function parseMessageTimestamp(timestamp: any): Date | null {\n  if (!timestamp) {\n    return null;\n  }\n\n  try {\n    if (typeof timestamp.toDate === 'function') {\n      // Firebase Timestamp format\n      return timestamp.toDate();\n    } else if (typeof timestamp === 'string') {\n      // Serialized timestamp format\n      const date = new Date(timestamp);\n      if (isNaN(date.getTime())) {\n        throw new Error('Invalid serialized timestamp format');\n      }\n      return date;\n    } else if (typeof timestamp === 'number') {\n      // Unix timestamp (milliseconds or seconds)\n      // If timestamp is less than year 3000 in seconds, convert to milliseconds\n      const timestampMs = timestamp < 32503680000 ? timestamp * 1000 : timestamp;\n      const date = new Date(timestampMs);\n      if (isNaN(date.getTime())) {\n        throw new Error('Invalid numeric timestamp format');\n      }\n      return date;\n    } else if (typeof timestamp === 'object' && timestamp.seconds !== undefined) {\n      // Firestore Timestamp serialized object format {seconds: number, nanoseconds: number}\n      const timestampObj = timestamp as { seconds: number; nanoseconds?: number };\n      const date = new Date(\n        timestampObj.seconds * 1000 + (timestampObj.nanoseconds || 0) / 1000000\n      );\n      if (isNaN(date.getTime())) {\n        throw new Error('Invalid Firestore timestamp object format');\n      }\n      return date;\n    } else if (timestamp instanceof Date) {\n      // Already a Date object\n      return timestamp;\n    } else {\n      // Log the actual timestamp value for debugging\n      console.warn('Unsupported timestamp format:', typeof timestamp, timestamp);\n      throw new Error(`Unsupported timestamp format: ${typeof timestamp}`);\n    }\n  } catch (error) {\n    console.warn('Failed to parse timestamp:', error);\n    return null;\n  }\n}\n","import { Message, MessageType } from '@/types/Message';\nimport { parseMessageTimestamp } from '@/helpers/timestamp';\n\n// chat box\nexport function normalSortedMessages(messages: Message[]): Message[] {\n  return messages.sort((a, b) => {\n    const aDate = parseMessageTimestamp(a.timestamp);\n    const bDate = parseMessageTimestamp(b.timestamp);\n    if (!aDate || !bDate) return 0;\n    return aDate.getTime() - bDate.getTime();\n  });\n}\n\n// latest on top\nexport function sortedMessages(messages: Message[]): Message[] {\n  const newMessage = JSON.parse(JSON.stringify(messages));\n  return newMessage.reverse();\n}\n\nexport default function latestMessageByType(\n  messages: Message[],\n  type: MessageType\n): Message | undefined {\n  return sortedMessages(messages).find((m) => m.type === type);\n}\n\nexport function orderedMessagesByType(\n  messages: Message[],\n  type: string,\n  order: 'ASC' | 'DESC' = 'ASC'\n): Message[] {\n  let sorted = sortedMessages(messages);\n  if (order === 'DESC') {\n    sorted = sorted.reverse();\n  }\n  return sorted.filter((m) => m.type === type);\n}\n\nexport function latestMessageBy(\n  messages: Message[],\n  callback: (message: Message) => boolean\n): Message | undefined {\n  return sortedMessages(messages).find(callback);\n}\n\nexport function latestMessage(messages: Message[]): Message | undefined {\n  return sortedMessages(messages)[0];\n}\n","import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { Message, MessageType } from '@/types/Message';\nimport latestMessageByType, {\n  normalSortedMessages,\n  orderedMessagesByType,\n  latestMessage,\n} from '@/helpers/messages';\nimport { parseMessageTimestamp } from '@/helpers/timestamp';\n\ninterface MessagesState {\n  messages: Message[];\n  loading: boolean;\n  error: string | null;\n  room: string | null;\n  paginationCursor: string | null;\n}\n\ninterface MessagesActions {\n  loadMessages: (messages: Message[]) => void;\n  addMessage: (message: Message) => void;\n  updateMessage: (id: string, updates: Partial<Message>) => void;\n  clearMessages: () => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n  setRoom: (room: string | null) => void;\n  setPaginationCursor: (cursor: string | null) => void;\n}\n\ninterface MessagesSelectors {\n  getMessagesByType: (type: MessageType) => Message[];\n  getLatestMessage: () => Message | undefined;\n  getLatestMessageByType: (type: MessageType) => Message | undefined;\n  getFilteredMessages: (predicate: (message: Message) => boolean) => Message[];\n  getOrderedMessagesByType: (type: string, order?: 'ASC' | 'DESC') => Message[];\n}\n\ninterface MessagesStore extends MessagesState, MessagesActions, MessagesSelectors {}\n\nconst initialState: MessagesState = {\n  messages: [],\n  loading: true,\n  error: null,\n  room: null,\n  paginationCursor: null,\n};\n\nexport const useMessagesStore = create<MessagesStore>()(\n  persist(\n    (set, get) => ({\n      ...initialState,\n\n      // Actions\n      loadMessages: (messages) => {\n        // Cast messages to proper type since Firebase returns any[]\n        const typedMessages = messages as Message[];\n        const sortedMessages = normalSortedMessages(typedMessages);\n        set({\n          messages: sortedMessages,\n          loading: false,\n          error: null,\n        });\n      },\n\n      addMessage: (message) => {\n        const { messages } = get();\n        // Check for duplicate messages to prevent unnecessary updates\n        const existingMessage = messages.find((msg) => msg.id === message.id);\n        if (existingMessage) {\n          return; // Message already exists, no update needed\n        }\n\n        const newMessages = [...messages, message];\n        const sortedMessages = normalSortedMessages(newMessages);\n        set({ messages: sortedMessages });\n      },\n\n      updateMessage: (id, updates) => {\n        const { messages } = get();\n        let hasChanges = false;\n        const updatedMessages = messages.map((msg) => {\n          if (msg.id === id) {\n            // Check if updates actually change anything\n            const updatedMsg = { ...msg, ...updates } as Message;\n            const hasActualChanges = Object.keys(updates).some(\n              (key) => (msg as any)[key] !== (updates as any)[key]\n            );\n            if (hasActualChanges) {\n              hasChanges = true;\n              return updatedMsg;\n            }\n          }\n          return msg;\n        });\n\n        // Only update state if there were actual changes\n        if (hasChanges) {\n          const sortedMessages = normalSortedMessages(updatedMessages);\n          set({ messages: sortedMessages });\n        }\n      },\n\n      clearMessages: () => {\n        set({ messages: [], loading: false, error: null });\n      },\n\n      setLoading: (loading) => {\n        const { loading: currentLoading } = get();\n        if (currentLoading !== loading) {\n          set({ loading });\n        }\n      },\n\n      setError: (error) => {\n        const { error: currentError } = get();\n        if (currentError !== error) {\n          set({ error });\n        }\n      },\n\n      setRoom: (room) => {\n        const { room: currentRoom } = get();\n        if (currentRoom !== room) {\n          set({ room });\n        }\n      },\n\n      setPaginationCursor: (cursor) => {\n        const { paginationCursor: currentCursor } = get();\n        if (currentCursor !== cursor) {\n          set({ paginationCursor: cursor });\n        }\n      },\n\n      // Selectors - Optimized for performance\n      getMessagesByType: (type) => {\n        const { messages } = get();\n        // Use a more efficient filter approach for large message arrays\n        const filtered: Message[] = [];\n        for (let i = 0; i < messages.length; i++) {\n          if (messages[i].type === type) {\n            filtered.push(messages[i]);\n          }\n        }\n        return filtered;\n      },\n\n      getLatestMessage: () => {\n        const { messages } = get();\n        return latestMessage(messages);\n      },\n\n      getLatestMessageByType: (type) => {\n        const { messages } = get();\n        return latestMessageByType(messages, type);\n      },\n\n      getFilteredMessages: (predicate) => {\n        const { messages } = get();\n        // Use for loop for better performance on large arrays\n        const filtered: Message[] = [];\n        for (let i = 0; i < messages.length; i++) {\n          if (predicate(messages[i])) {\n            filtered.push(messages[i]);\n          }\n        }\n        return filtered;\n      },\n\n      getOrderedMessagesByType: (type, order = 'ASC') => {\n        const { messages } = get();\n        return orderedMessagesByType(messages, type, order);\n      },\n    }),\n    {\n      name: 'messages-storage', // localStorage key\n      partialize: (state) => ({\n        messages: state.messages,\n        room: state.room,\n        paginationCursor: state.paginationCursor,\n      }),\n      // Add TTL functionality\n      onRehydrateStorage: () => {\n        return (state) => {\n          if (state) {\n            // Clear messages older than 24 hours on rehydration\n            const twentyFourHoursAgo = new Date();\n            twentyFourHoursAgo.setHours(twentyFourHoursAgo.getHours() - 24);\n\n            const validMessages = state.messages.filter((msg) => {\n              try {\n                const messageTime = parseMessageTimestamp(msg.timestamp);\n                if (!messageTime) {\n                  console.warn(\n                    `Failed to parse timestamp for message ${msg.id}:`,\n                    typeof msg.timestamp,\n                    msg.timestamp\n                  );\n                  throw new Error(`Failed to parse timestamp for message ${msg.id}`);\n                }\n\n                return messageTime > twentyFourHoursAgo;\n              } catch (error) {\n                // Log specific error messages for debugging\n                console.warn(\n                  `Failed to parse message timestamp for message ID ${msg.id}:`,\n                  (error as Error).message\n                );\n                return true; // Keep the message if parsing fails\n              }\n            });\n\n            if (validMessages.length !== state.messages.length) {\n              state.loadMessages(validMessages);\n            }\n          }\n        };\n      },\n    }\n  )\n);\n\n// Compatibility hook for existing useMessages pattern\nexport const useMessages = () => {\n  const { messages, loading: isLoading } = useMessagesStore();\n  return { messages, isLoading };\n};\n","import React, { ReactNode, useEffect } from 'react';\nimport { Params, useParams } from 'react-router-dom';\nimport { getMessages } from '@/services/firebase';\nimport { Message } from '@/types/Message';\nimport { useMessagesStore } from '@/stores/messagesStore';\n\nexport interface MessagesContextType {\n  messages: Message[];\n  isLoading: boolean;\n}\n\n// eslint-disable-next-line react-refresh/only-export-components\nexport const MessagesContext = React.createContext<MessagesContextType | undefined>(undefined);\n\ninterface MessagesProviderProps {\n  children: ReactNode;\n  [key: string]: any;\n}\n\nexport function MessagesProvider(props: MessagesProviderProps): JSX.Element {\n  const { id: room } = useParams<Params>();\n\n  const {\n    messages,\n    loading: isLoading,\n    loadMessages,\n    setLoading,\n    setRoom,\n    clearMessages,\n  } = useMessagesStore();\n\n  useEffect(() => {\n    setLoading(true);\n    setRoom(room || null);\n\n    if (!room) {\n      clearMessages();\n      return;\n    }\n\n    return getMessages(room, (newMessages: Array<Record<string, unknown>>) => {\n      loadMessages(newMessages as unknown as Message[]);\n    });\n  }, [room, loadMessages, setLoading, setRoom, clearMessages]);\n\n  const value = { messages, isLoading };\n\n  return <MessagesContext.Provider value={value} {...props} />;\n}\n","import {\n  BrowserRouter,\n  Navigate,\n  Route,\n  Routes,\n  useLocation,\n  useNavigate,\n  useParams,\n} from 'react-router-dom';\nimport { Suspense, lazy, useContext, useEffect } from 'react';\nimport { WindowWithAuth } from '../../types/app';\nimport { AuthContext } from '../../context/auth';\nimport { MessagesProvider } from '../../context/messages';\nimport AppSkeleton from '../AppSkeleton';\n\n// Lazy load UserListProvider\nconst UserListProvider = lazy(() =>\n  import('../../context/userList').then((m) => ({ default: m.UserListProvider }))\n);\n\n// Lazy load main views\nconst UnauthenticatedApp = lazy(() => import('../../views/UnauthenticatedApp'));\nconst Cast = lazy(() => import('../../views/Cast'));\nconst Room = lazy(() => import('../../views/Room'));\n\n// Component to ensure the room ID is always uppercase\nfunction UppercaseRedirect({ children }: { children: React.ReactNode }) {\n  const { id } = useParams();\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  useEffect(() => {\n    if (id && id !== id.toUpperCase()) {\n      const newPath = location.pathname.replace(id, id.toUpperCase());\n      navigate(newPath + location.search + location.hash, { replace: true });\n    }\n  }, [id, navigate, location]);\n\n  return <>{children}</>;\n}\n\nfunction AppRoutes() {\n  const auth = useContext(AuthContext);\n\n  // Make auth context available to the middleware\n  useEffect(() => {\n    if (auth) {\n      (window as unknown as WindowWithAuth).authContext = auth;\n    }\n    return () => {\n      (window as unknown as WindowWithAuth).authContext = null;\n    };\n  }, [auth]);\n\n  // Show skeleton during initial auth loading\n  if (!auth || auth.initializing) {\n    return <AppSkeleton />;\n  }\n\n  const room = auth.user ? <Room /> : <UnauthenticatedApp />;\n\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Navigate replace to=\"/PUBLIC\" />} />\n      <Route\n        path=\"/:id/cast\"\n        element={\n          <UppercaseRedirect>\n            <Suspense fallback={<AppSkeleton />}>\n              <UserListProvider>\n                <MessagesProvider>\n                  <Cast />\n                </MessagesProvider>\n              </UserListProvider>\n            </Suspense>\n          </UppercaseRedirect>\n        }\n      />\n      <Route\n        path=\"/:id\"\n        element={\n          <UppercaseRedirect>\n            <Suspense fallback={<AppSkeleton />}>\n              <UserListProvider>\n                <MessagesProvider>{room}</MessagesProvider>\n              </UserListProvider>\n            </Suspense>\n          </UppercaseRedirect>\n        }\n      />\n    </Routes>\n  );\n}\n\nexport default function RouterSetup() {\n  return (\n    <BrowserRouter>\n      <AppRoutes />\n    </BrowserRouter>\n  );\n}\n"],"file":"js/chunk-DWzmHgJq.js"}