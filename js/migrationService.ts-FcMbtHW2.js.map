{"version":3,"mappings":"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","names":["SUPPORTED_LANGUAGES","MIGRATION_VERSION","MIGRATION_KEY","BACKGROUND_MIGRATION_KEY","MIGRATION_IN_PROGRESS_KEY","CURRENT_LANGUAGE_MIGRATION_KEY","BACKGROUND_MIGRATION_IN_PROGRESS_KEY","isMigrationInProgress","status","data","error","setMigrationInProgress","inProgress","isLanguageMigrationInProgress","locale","setLanguageMigrationInProgress","l","isBackgroundMigrationInProgress","setBackgroundMigrationInProgress","checkAndHandleVersionChange","oldVersion","isMigrationCompleted","versionChanged","migrationStatus","isCurrentLanguageMigrationCompleted","bgStatus","backgroundStatus","lang","verifyMigrationIntegrity","gameMode","localStorageComplete","getAllAvailableGroups","__vitePreload","n","groups","fixMigrationStatusCorruption","getCurrentLanguage","resolved","i18n","currentLang","storedLanguage","browserLang","markMigrationComplete","markLanguageMigrated","bgStatusStr","completedSet","markBackgroundMigrationInProgress","importActionFile","groupName","actionFile","__variableDynamicImportRuntimeHelper","label","type","actions","intensities","key","intensityName","index","customGroup","customTiles","actionList","intensity","i","action","getAvailableLocales","locales","existingLocales","e","getAvailableGameModes","gameModes","existingGameModes","getActionGroupNames","allActionFiles","existingGroups","targetPath","filePath","variant","fileName","importGroupsForLocaleAndGameMode","groupNames","groupsImported","tilesImported","getCustomGroupByName","result","addCustomGroup","getTiles","existingTiles","newTiles","tile","existing","importCustomTiles","tileError","importError","migrateActionGroups","removeDuplicateGroups","cleanupDuplicateGroups","totalDuplicatesRemoved","duplicatesRemoved","migrateCurrentLanguage","currentLocale","startTime","timeoutMs","resolve","migrateRemainingLanguages","excludeLocale","remainingLocales","completedLanguages","queueBackgroundMigration","ensureLanguageMigrated","runMigrationIfNeeded","success","getMigrationStatus","mainStatus","resetMigrationStatus","forceFreshMigration","db","cleanupDuplicatesIfNeeded","_a","_b","_c"],"ignoreList":[],"sources":["../../src/services/migrationService.ts"],"sourcesContent":["import { addCustomGroup, getCustomGroupByName, removeDuplicateGroups } from '@/stores/customGroups';\n\nimport { CustomGroupBase } from '@/types/customGroups';\nimport { CustomTileBase } from '@/types/customTiles';\nimport i18n from '@/i18n';\nimport { importCustomTiles } from '@/stores/customTiles';\n\n/**\n * Migration service to convert JSON action files to custom groups and custom tiles in Dexie.\n * Uses Vite's import.meta.glob() for automatic file discovery at build time.\n */\n\n// Supported languages for migration\nconst SUPPORTED_LANGUAGES = ['en', 'es', 'fr', 'zh', 'hi'] as const;\n\n// ============================================================================\n// MIGRATION VERSION CONFIGURATION\n// ============================================================================\n//\n// VERSION HISTORY:\n// - 2.1.0: Initial migration system\n// - 2.1.1: Fixed import path matching (@/locales vs /src/locales)\n// - 2.1.2: Added corruption detection and auto-recovery\n// --2.2.0: Added body worship group\n//\nconst MIGRATION_VERSION = '2.2.0';\n// ============================================================================\n\n// Configuration\nconst MIGRATION_KEY = 'blitzed-out-action-groups-migration';\nconst BACKGROUND_MIGRATION_KEY = 'blitzed-out-background-migration';\n\n// localStorage-based concurrency control keys for better reliability in hot module reloading environments\nconst MIGRATION_IN_PROGRESS_KEY = 'blitzed-out-migration-in-progress';\nconst CURRENT_LANGUAGE_MIGRATION_KEY = 'blitzed-out-current-language-migration';\nconst BACKGROUND_MIGRATION_IN_PROGRESS_KEY = 'blitzed-out-background-migration-in-progress';\n\ninterface MigrationStatus {\n  version: string;\n  completed: boolean;\n  completedAt?: Date;\n  currentLanguageOnly?: boolean;\n}\n\ninterface BackgroundMigrationStatus {\n  version: string;\n  completedLanguages: string[];\n  inProgress: boolean;\n  startedAt?: Date;\n  completedAt?: Date;\n}\n\n// Helper functions for localStorage-based concurrency control\nconst isMigrationInProgress = (): boolean => {\n  try {\n    const status = localStorage.getItem(MIGRATION_IN_PROGRESS_KEY);\n    if (!status) return false;\n    const data = JSON.parse(status);\n    // Auto-cleanup stale locks (older than 5 minutes)\n    if (Date.now() - new Date(data.startedAt).getTime() > 5 * 60 * 1000) {\n      localStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n      return false;\n    }\n    return data.inProgress;\n  } catch (error) {\n    console.warn('Failed to check migration in progress status:', error);\n    return false;\n  }\n};\n\nconst setMigrationInProgress = (inProgress: boolean): void => {\n  try {\n    if (inProgress) {\n      localStorage.setItem(\n        MIGRATION_IN_PROGRESS_KEY,\n        JSON.stringify({\n          inProgress: true,\n          startedAt: new Date().toISOString(),\n        })\n      );\n    } else {\n      localStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n    }\n  } catch (error) {\n    console.warn('Failed to update migration in progress status:', error);\n  }\n};\n\nconst isLanguageMigrationInProgress = (locale: string): boolean => {\n  try {\n    const status = localStorage.getItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    if (!status) return false;\n    const data = JSON.parse(status);\n    // Auto-cleanup stale locks (older than 5 minutes)\n    if (Date.now() - new Date(data.startedAt).getTime() > 5 * 60 * 1000) {\n      localStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n      return false;\n    }\n    return data.locales && data.locales.includes(locale);\n  } catch (error) {\n    console.warn('Failed to check language migration in progress status:', error);\n    return false;\n  }\n};\n\nconst setLanguageMigrationInProgress = (locale: string, inProgress: boolean): void => {\n  try {\n    const status = localStorage.getItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    let data = status ? JSON.parse(status) : { locales: [], startedAt: new Date().toISOString() };\n\n    if (inProgress) {\n      if (!data.locales.includes(locale)) {\n        data.locales.push(locale);\n        data.startedAt = new Date().toISOString();\n      }\n    } else {\n      data.locales = data.locales.filter((l: string) => l !== locale);\n      if (data.locales.length === 0) {\n        localStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n        return;\n      }\n    }\n\n    localStorage.setItem(CURRENT_LANGUAGE_MIGRATION_KEY, JSON.stringify(data));\n  } catch (error) {\n    console.warn('Failed to update language migration in progress status:', error);\n  }\n};\n\nconst isBackgroundMigrationInProgress = (): boolean => {\n  try {\n    const status = localStorage.getItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n    if (!status) return false;\n    const data = JSON.parse(status);\n    // Auto-cleanup stale locks (older than 10 minutes)\n    if (Date.now() - new Date(data.startedAt).getTime() > 10 * 60 * 1000) {\n      localStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n      return false;\n    }\n    return data.inProgress;\n  } catch (error) {\n    console.warn('Failed to check background migration in progress status:', error);\n    return false;\n  }\n};\n\nconst setBackgroundMigrationInProgress = (inProgress: boolean): void => {\n  try {\n    if (inProgress) {\n      localStorage.setItem(\n        BACKGROUND_MIGRATION_IN_PROGRESS_KEY,\n        JSON.stringify({\n          inProgress: true,\n          startedAt: new Date().toISOString(),\n        })\n      );\n    } else {\n      localStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n    }\n  } catch (error) {\n    console.warn('Failed to update background migration in progress status:', error);\n  }\n};\n\n/**\n * Check if migration version has changed and clear outdated data\n */\nexport const checkAndHandleVersionChange = (): { versionChanged: boolean; oldVersion?: string } => {\n  try {\n    const status = localStorage.getItem(MIGRATION_KEY);\n    if (!status) {\n      return { versionChanged: false };\n    }\n\n    const migrationStatus: MigrationStatus = JSON.parse(status);\n    const oldVersion = migrationStatus.version;\n    const versionChanged = oldVersion !== MIGRATION_VERSION;\n\n    if (versionChanged) {\n      // Clear all migration-related localStorage\n      localStorage.removeItem(MIGRATION_KEY);\n      localStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n      localStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n      localStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n      localStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n\n      return { versionChanged: true, oldVersion };\n    }\n\n    return { versionChanged: false, oldVersion };\n  } catch (error) {\n    console.error('Error checking migration version:', error);\n    return { versionChanged: false };\n  }\n};\n\n/**\n * Check if migration has been completed\n */\nexport const isMigrationCompleted = (): boolean => {\n  try {\n    // First check for version changes\n    const { versionChanged } = checkAndHandleVersionChange();\n    if (versionChanged) {\n      return false; // Force fresh migration after version change\n    }\n\n    const status = localStorage.getItem(MIGRATION_KEY);\n    if (!status) return false;\n\n    const migrationStatus: MigrationStatus = JSON.parse(status);\n    return migrationStatus.completed && migrationStatus.version === MIGRATION_VERSION;\n  } catch (error) {\n    console.error('Error checking migration status:', error);\n    return false;\n  }\n};\n\n/**\n * Check if current language migration has been completed\n */\nexport const isCurrentLanguageMigrationCompleted = (locale: string): boolean => {\n  try {\n    // First check for version changes - this will clear outdated data automatically\n    const { versionChanged } = checkAndHandleVersionChange();\n    if (versionChanged) {\n      return false; // Force fresh migration after version change\n    }\n\n    // Check background migration status for specific language\n    const bgStatus = localStorage.getItem(BACKGROUND_MIGRATION_KEY);\n    let backgroundStatus: BackgroundMigrationStatus | null = null;\n\n    if (bgStatus) {\n      backgroundStatus = JSON.parse(bgStatus);\n      const isCompleted = backgroundStatus!.completedLanguages.includes(locale);\n      if (isCompleted) {\n        return true;\n      }\n    }\n\n    // Fallback: check if full migration is complete AND all languages are done\n    const status = localStorage.getItem(MIGRATION_KEY);\n    if (status) {\n      const migrationStatus: MigrationStatus = JSON.parse(status);\n\n      if (migrationStatus.completed && migrationStatus.version === MIGRATION_VERSION) {\n        // Only return true if this is a full migration (not just current language)\n        // Check if background migration has completed all languages\n        if (backgroundStatus) {\n          const allLanguagesCompleted = SUPPORTED_LANGUAGES.every((lang) =>\n            backgroundStatus!.completedLanguages.includes(lang)\n          );\n          return allLanguagesCompleted;\n        }\n        // If no background status, assume full migration means all languages are done\n        return true;\n      }\n    }\n\n    return false;\n  } catch (error) {\n    console.error('Error checking current language migration status:', error);\n    return false;\n  }\n};\n\n/**\n * Verify that migration status matches actual database content\n * This detects corrupted migration status where localStorage says complete but Dexie is empty\n */\nexport const verifyMigrationIntegrity = async (\n  locale: string,\n  gameMode: string = 'online'\n): Promise<boolean> => {\n  try {\n    // Check if localStorage claims migration is complete\n    const localStorageComplete = isCurrentLanguageMigrationCompleted(locale);\n\n    if (!localStorageComplete) {\n      // If localStorage says not complete, that's fine - migration will run\n      return true;\n    }\n\n    // If localStorage says complete, verify database actually has data\n    const { getAllAvailableGroups } = await import('@/stores/customGroups');\n    const groups = await getAllAvailableGroups(locale, gameMode);\n\n    // If localStorage says complete but database is empty, we have corruption\n    if (localStorageComplete && groups.length === 0) {\n      return false;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Failed to verify migration integrity:', error);\n    return false;\n  }\n};\n\n/**\n * Fix corrupted migration status by clearing localStorage\n */\nexport const fixMigrationStatusCorruption = (): void => {\n  try {\n    localStorage.removeItem(MIGRATION_KEY);\n    localStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n  } catch (error) {\n    console.error('Failed to fix migration status corruption:', error);\n  }\n};\n\n/**\n * Get current user language from i18next\n */\nconst getCurrentLanguage = async (): Promise<string> => {\n  try {\n    // First try: get current language from i18next using proper API\n    const resolved = i18n.resolvedLanguage;\n    if (resolved && resolved !== 'undefined') {\n      return resolved;\n    }\n\n    // Second try: get language from i18next instance\n    const currentLang = i18n.language;\n    if (currentLang && currentLang !== 'undefined') {\n      return currentLang;\n    }\n\n    // Third try: localStorage fallback\n    const storedLanguage = localStorage.getItem('i18nextLng');\n    if (storedLanguage && storedLanguage !== 'undefined') {\n      return storedLanguage;\n    }\n\n    // Fourth try: browser language with proper validation\n    if (typeof navigator !== 'undefined' && navigator.language) {\n      const browserLang = navigator.language.split('-')[0];\n      if (SUPPORTED_LANGUAGES.includes(browserLang as (typeof SUPPORTED_LANGUAGES)[number])) {\n        return browserLang;\n      }\n    }\n\n    // Final fallback: English\n    return 'en';\n  } catch (error) {\n    console.error('Error detecting current language:', error);\n    return 'en'; // Safe fallback\n  }\n};\n\n/**\n * Mark migration as completed\n */\nconst markMigrationComplete = (): void => {\n  const status: MigrationStatus = {\n    version: MIGRATION_VERSION,\n    completed: true,\n    completedAt: new Date(),\n  };\n  localStorage.setItem(MIGRATION_KEY, JSON.stringify(status));\n};\n\n/**\n * Mark a specific language as migrated in background status\n */\nconst markLanguageMigrated = (locale: string): void => {\n  try {\n    const bgStatusStr = localStorage.getItem(BACKGROUND_MIGRATION_KEY);\n    let bgStatus: BackgroundMigrationStatus;\n\n    if (bgStatusStr) {\n      bgStatus = JSON.parse(bgStatusStr);\n    } else {\n      bgStatus = {\n        version: MIGRATION_VERSION,\n        completedLanguages: [],\n        inProgress: false,\n      };\n    }\n\n    // Use Set to ensure uniqueness and atomic update\n    const completedSet = new Set(bgStatus.completedLanguages);\n    completedSet.add(locale);\n    bgStatus.completedLanguages = Array.from(completedSet);\n\n    localStorage.setItem(BACKGROUND_MIGRATION_KEY, JSON.stringify(bgStatus));\n  } catch (error) {\n    console.error('Error marking language as migrated:', error);\n  }\n};\n\n/**\n * Mark background migration as in progress\n */\nconst markBackgroundMigrationInProgress = (inProgress: boolean): void => {\n  try {\n    const bgStatusStr = localStorage.getItem(BACKGROUND_MIGRATION_KEY);\n    let bgStatus: BackgroundMigrationStatus;\n\n    if (bgStatusStr) {\n      bgStatus = JSON.parse(bgStatusStr);\n    } else {\n      bgStatus = {\n        version: MIGRATION_VERSION,\n        completedLanguages: [],\n        inProgress: false,\n      };\n    }\n\n    bgStatus.inProgress = inProgress;\n    if (inProgress) {\n      bgStatus.startedAt = new Date();\n    } else {\n      bgStatus.completedAt = new Date();\n    }\n\n    localStorage.setItem(BACKGROUND_MIGRATION_KEY, JSON.stringify(bgStatus));\n  } catch (error) {\n    console.error('Error updating background migration status:', error);\n  }\n};\n\n/**\n * Import a single action file and convert it to a custom group with custom tiles\n */\nconst importActionFile = async (\n  groupName: string,\n  locale: string,\n  gameMode: string\n): Promise<{ customGroup: CustomGroupBase; customTiles: CustomTileBase[] } | null> => {\n  try {\n    // Import the action file\n    const actionFile = await import(`@/locales/${locale}/${gameMode}/${groupName}.json`);\n\n    // Extract data from the JSON file\n    const label = actionFile.label || groupName;\n    const type = actionFile.type || 'action';\n    const actions = actionFile.actions || {};\n\n    // Convert actions object to intensities array\n    const intensities = Object.keys(actions)\n      .filter((key) => key !== 'None') // Skip 'None' as it's always included\n      .map((intensityName, index) => ({\n        id: `${groupName}-${index + 1}`,\n        label: intensityName,\n        value: index + 1,\n        isDefault: true,\n      }));\n\n    // Create the custom group\n    const customGroup: CustomGroupBase = {\n      name: groupName,\n      label,\n      intensities,\n      type,\n      isDefault: true,\n      locale,\n      gameMode,\n    };\n\n    // Create custom tiles from the actions\n    const customTiles: CustomTileBase[] = [];\n\n    for (const [intensityName, actionList] of Object.entries(actions)) {\n      if (intensityName === 'None' || !Array.isArray(actionList)) continue;\n\n      // Find the intensity value for this intensity name\n      const intensity = intensities.find((i) => i.label === intensityName);\n      if (!intensity) continue;\n\n      // Create a tile for each action in this intensity\n      for (const action of actionList) {\n        if (typeof action === 'string' && action.trim()) {\n          customTiles.push({\n            group: groupName,\n            intensity: intensity.value,\n            action: action.trim(),\n            tags: ['default'], // Mark as default tiles from JSON files\n            isEnabled: 1,\n            isCustom: 0, // These are default tiles, not custom\n            gameMode,\n            locale,\n          });\n        }\n      }\n    }\n\n    return { customGroup, customTiles };\n  } catch (error) {\n    // Failed to import action file - skip silently\n    console.debug('Failed to import action file:', error);\n    return null;\n  }\n};\n\n/**\n * Dynamically discover available locales from the filesystem\n */\nconst getAvailableLocales = async (): Promise<string[]> => {\n  const locales = [...SUPPORTED_LANGUAGES]; // All supported locales\n  const existingLocales: string[] = [];\n\n  for (const locale of locales) {\n    try {\n      // Test if locale exists by trying to import translation file\n      await import(`@/locales/${locale}/translation.json`);\n      existingLocales.push(locale);\n    } catch {\n      // Locale doesn't exist, skip it\n    }\n  }\n\n  return existingLocales;\n};\n\n/**\n * Dynamically discover available game modes for a locale\n */\nconst getAvailableGameModes = async (locale: string): Promise<string[]> => {\n  const gameModes = ['local', 'online']; // Known game modes\n  const existingGameModes: string[] = [];\n\n  for (const gameMode of gameModes) {\n    try {\n      // Test if gameMode exists by trying to import any known file\n      await import(`@/locales/${locale}/${gameMode}/alcohol.json`);\n      existingGameModes.push(gameMode);\n    } catch {\n      // Game mode doesn't exist for this locale, skip it\n    }\n  }\n\n  return existingGameModes;\n};\n\n/**\n * Dynamically discover action group names for a specific locale and game mode\n * Uses Vite's import.meta.glob to automatically discover all JSON files at build time\n */\nconst getActionGroupNames = async (locale: string, gameMode: string): Promise<string[]> => {\n  // Use Vite's glob import to get all action group files for all locales and game modes\n  // This automatically discovers files at build time, eliminating the need for hardcoded lists\n  // IMPROVEMENT: Replaced hardcoded array with dynamic discovery using import.meta.glob\n  const allActionFiles = import.meta.glob('@/locales/*/*/*.json');\n\n  const existingGroups: string[] = [];\n  const targetPath = `@/locales/${locale}/${gameMode}/`;\n\n  // Filter for files matching the current locale and game mode\n  for (const filePath of Object.keys(allActionFiles)) {\n    // Check both @/ prefixed paths and resolved paths\n    const pathVariants = [\n      targetPath, // @/locales/en/online/\n      targetPath.replace('@/', '/src/'), // /src/locales/en/online/\n      `/${locale}/${gameMode}/`, // /en/online/\n      `locales/${locale}/${gameMode}/`, // locales/en/online/\n    ];\n\n    const pathMatches = pathVariants.some((variant) => filePath.includes(variant));\n    if (pathMatches) {\n      // Extract the group name from the file path\n      const fileName = filePath.split('/').pop();\n      if (fileName?.endsWith('.json')) {\n        const groupName = fileName.replace('.json', '');\n\n        try {\n          // Verify the file can be imported (additional safety check)\n          await allActionFiles[filePath]();\n          existingGroups.push(groupName);\n        } catch (error) {\n          // File exists but can't be imported, skip it\n          console.warn(\n            `Found ${groupName} file for ${locale}/${gameMode} but failed to import it:`,\n            error\n          );\n        }\n      }\n    }\n  }\n\n  const sortedGroups = existingGroups.sort(); // Sort for consistent ordering\n  return sortedGroups;\n};\n\n/**\n * Import all action groups for a specific locale and game mode\n */\nconst importGroupsForLocaleAndGameMode = async (\n  locale: string,\n  gameMode: string\n): Promise<{ groupsImported: number; tilesImported: number }> => {\n  const groupNames = await getActionGroupNames(locale, gameMode);\n\n  let groupsImported = 0;\n  let tilesImported = 0;\n\n  for (const groupName of groupNames) {\n    // Check if group already exists to prevent duplicates\n    const existingGroup = await getCustomGroupByName(groupName, locale, gameMode);\n    if (existingGroup) {\n      // Group already exists, skip\n      continue;\n    }\n\n    const result = await importActionFile(groupName, locale, gameMode);\n\n    if (result) {\n      const { customGroup, customTiles } = result;\n\n      try {\n        // Add the custom group with error handling for duplicates\n        try {\n          await addCustomGroup(customGroup);\n          groupsImported++;\n          // Successfully imported group\n        } catch (error) {\n          // Handle case where group was added by concurrent migration\n          if (error instanceof Error && error.message.includes('already exists')) {\n            // Group was already added by concurrent process\n          } else {\n            throw error; // Re-throw other errors\n          }\n        }\n\n        // Add the custom tiles if there are any\n        if (customTiles.length > 0) {\n          // Filter out any tiles that might already exist to prevent duplicates\n          try {\n            const { getTiles } = await import('@/stores/customTiles');\n            const existingTiles = await getTiles({\n              locale,\n              gameMode,\n              group: groupName,\n            });\n\n            const newTiles = customTiles.filter((tile) => {\n              // Handle case where existingTiles might be undefined or not an array\n              if (!existingTiles || !Array.isArray(existingTiles)) {\n                return true; // If no existing tiles, all tiles are new\n              }\n\n              return !existingTiles.some(\n                (existing) =>\n                  existing.group === tile.group &&\n                  existing.intensity === tile.intensity &&\n                  existing.action === tile.action &&\n                  existing.gameMode === tile.gameMode &&\n                  existing.locale === tile.locale\n              );\n            });\n\n            if (newTiles.length > 0) {\n              try {\n                await importCustomTiles(newTiles);\n                tilesImported += newTiles.length;\n              } catch (error) {\n                // Handle case where tiles were added by concurrent migration\n                console.warn(`Some tiles may have been added by concurrent process:`, error);\n                // Continue processing, don't fail the entire migration\n              }\n            }\n          } catch (tileError) {\n            // If tile checking fails, import anyway to ensure migration succeeds\n            console.warn(\n              `Tile deduplication failed for ${groupName}, importing all tiles:`,\n              tileError\n            );\n            try {\n              await importCustomTiles(customTiles);\n              tilesImported += customTiles.length;\n            } catch (importError) {\n              console.warn(`Tile import failed for ${groupName}, continuing:`, importError);\n              // Continue with migration even if some tiles fail\n            }\n          }\n        }\n      } catch (error) {\n        console.error(`Failed to import group ${groupName} for ${locale}/${gameMode}:`, error);\n      }\n    }\n  }\n\n  return { groupsImported, tilesImported };\n};\n\n/**\n * Main migration function with dynamic discovery\n */\nexport const migrateActionGroups = async (): Promise<boolean> => {\n  try {\n    // Starting action groups migration\n\n    // Dynamically discover available locales\n    const locales = await getAvailableLocales();\n    // Available locales discovered\n\n    for (const locale of locales) {\n      // Dynamically discover available game modes for this locale\n      const gameModes = await getAvailableGameModes(locale);\n      // Processing game modes for locale\n\n      for (const gameMode of gameModes) {\n        try {\n          // Processing locale/gameMode\n          await importGroupsForLocaleAndGameMode(locale, gameMode);\n          // Completed locale/gameMode\n        } catch (error) {\n          console.error(`Error importing groups for ${locale}/${gameMode}:`, error);\n        }\n      }\n    }\n\n    // Migration completed successfully\n\n    // Clean up any duplicates that might exist from previous migrations\n    for (const locale of locales) {\n      const gameModes = await getAvailableGameModes(locale);\n      for (const gameMode of gameModes) {\n        await removeDuplicateGroups(locale, gameMode);\n      }\n    }\n\n    // Migration completed successfully\n    markMigrationComplete();\n    return true;\n  } catch (error) {\n    console.error('Migration failed:', error);\n    return false;\n  }\n};\n\n/**\n * Clean up duplicate groups across all locales and game modes\n * Can be called independently of migration\n */\nexport const cleanupDuplicateGroups = async (): Promise<number> => {\n  try {\n    const locales = await getAvailableLocales();\n    let totalDuplicatesRemoved = 0;\n\n    // Starting duplicate cleanup\n\n    for (const locale of locales) {\n      const gameModes = await getAvailableGameModes(locale);\n      for (const gameMode of gameModes) {\n        const duplicatesRemoved = await removeDuplicateGroups(locale, gameMode);\n        if (duplicatesRemoved > 0) {\n          // Removed duplicates from locale/gameMode\n        }\n        totalDuplicatesRemoved += duplicatesRemoved;\n      }\n    }\n\n    // Cleanup completed\n    return totalDuplicatesRemoved;\n  } catch (error) {\n    console.error('Error in cleanupDuplicateGroups:', error);\n    return 0;\n  }\n};\n\n/**\n * Migration function for current language only (fast path)\n */\nexport const migrateCurrentLanguage = async (locale?: string): Promise<boolean> => {\n  const currentLocale = locale || (await getCurrentLanguage());\n\n  try {\n    // Check if this language is already migrated\n    if (isCurrentLanguageMigrationCompleted(currentLocale)) {\n      return true;\n    }\n\n    // Prevent concurrent migrations for the same language\n    if (isLanguageMigrationInProgress(currentLocale)) {\n      // Wait for the current migration to complete with timeout\n      const startTime = Date.now();\n      const timeoutMs = 30 * 1000; // 30 seconds\n\n      while (isLanguageMigrationInProgress(currentLocale)) {\n        if (Date.now() - startTime > timeoutMs) {\n          console.warn(\n            `Migration timeout: ${currentLocale} migration took longer than ${timeoutMs}ms, proceeding anyway`\n          );\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 50));\n      }\n      // Re-check if migration is now completed\n      return isCurrentLanguageMigrationCompleted(currentLocale);\n    }\n\n    setLanguageMigrationInProgress(currentLocale, true);\n    // Starting current language migration\n\n    try {\n      const gameModes = await getAvailableGameModes(currentLocale);\n      // Processing game modes for current locale\n\n      for (const gameMode of gameModes) {\n        try {\n          // Processing current locale/gameMode\n          await importGroupsForLocaleAndGameMode(currentLocale, gameMode);\n          // Completed current locale/gameMode\n        } catch (error) {\n          console.error(`Error importing groups for ${currentLocale}/${gameMode}:`, error);\n        }\n      }\n\n      // Clean up duplicates for current language\n      for (const gameMode of gameModes) {\n        try {\n          await removeDuplicateGroups(currentLocale, gameMode);\n        } catch (error) {\n          console.warn(`Cleanup failed for ${currentLocale}/${gameMode}:`, error);\n          // Continue even if cleanup fails\n        }\n      }\n\n      // Mark this language as migrated\n      markLanguageMigrated(currentLocale);\n\n      // Don't mark main migration as complete yet - only mark complete when ALL languages are done\n      // The main migration completion is handled in background migration\n\n      // Current language migration completed\n\n      return true;\n    } finally {\n      setLanguageMigrationInProgress(currentLocale, false);\n    }\n  } catch (error) {\n    console.error('Current language migration failed:', error);\n    setLanguageMigrationInProgress(currentLocale, false);\n    return false;\n  }\n};\n\n/**\n * Background migration for remaining languages\n */\nexport const migrateRemainingLanguages = async (excludeLocale?: string): Promise<void> => {\n  try {\n    // Prevent concurrent background migrations\n    if (isBackgroundMigrationInProgress()) {\n      return;\n    }\n\n    setBackgroundMigrationInProgress(true);\n    const currentLocale = excludeLocale || (await getCurrentLanguage());\n    markBackgroundMigrationInProgress(true);\n\n    // Background migration starting for other languages\n\n    const allLocales = await getAvailableLocales();\n    const remainingLocales = allLocales.filter((locale) => locale !== currentLocale);\n\n    for (const locale of remainingLocales) {\n      // Check if already migrated\n      if (isCurrentLanguageMigrationCompleted(locale)) {\n        continue;\n      }\n\n      try {\n        const gameModes = await getAvailableGameModes(locale);\n\n        for (const gameMode of gameModes) {\n          // Background migration processing locale/gameMode\n          await importGroupsForLocaleAndGameMode(locale, gameMode);\n\n          // Add small delay to prevent blocking the main thread\n          await new Promise((resolve) => setTimeout(resolve, 10));\n        }\n\n        // Clean up duplicates\n        for (const gameMode of gameModes) {\n          await removeDuplicateGroups(locale, gameMode);\n        }\n\n        markLanguageMigrated(locale);\n      } catch (error) {\n        console.warn(`Background migration failed for ${locale}:`, error);\n        // Continue with other languages even if one fails\n      }\n    }\n\n    markBackgroundMigrationInProgress(false);\n\n    // Check if all languages are now migrated\n    const bgStatus = JSON.parse(localStorage.getItem(BACKGROUND_MIGRATION_KEY) || '{}');\n    const completedLanguages = new Set(bgStatus.completedLanguages || []);\n    const allLanguagesCompleted = SUPPORTED_LANGUAGES.every((lang) => completedLanguages.has(lang));\n\n    if (allLanguagesCompleted) {\n      markMigrationComplete(); // Mark full migration as complete\n    }\n\n    // Background migration: All remaining languages completed\n  } catch (error) {\n    console.error('Background migration failed:', error);\n    markBackgroundMigrationInProgress(false);\n    setBackgroundMigrationInProgress(false);\n  } finally {\n    setBackgroundMigrationInProgress(false);\n  }\n};\n\n/**\n * Queue background migration for remaining languages\n */\nexport const queueBackgroundMigration = (excludeLocale?: string): void => {\n  try {\n    if (typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function') {\n      window.requestIdleCallback(\n        () => migrateRemainingLanguages(excludeLocale),\n        { timeout: 5000 } // 5 second timeout\n      );\n    } else {\n      // Fallback for browsers without requestIdleCallback\n      setTimeout(() => migrateRemainingLanguages(excludeLocale), 1000);\n    }\n  } catch (error) {\n    console.error('Error queuing background migration:', error);\n  }\n};\n\n/**\n * Force migration for a specific language (useful when switching languages)\n */\nexport const ensureLanguageMigrated = async (locale: string): Promise<boolean> => {\n  try {\n    // Quick check first\n    const isCompleted = isCurrentLanguageMigrationCompleted(locale);\n\n    if (isCompleted) {\n      return true;\n    }\n\n    // If migration is in progress for this language, wait for it\n    if (isLanguageMigrationInProgress(locale)) {\n      const startTime = Date.now();\n      const timeoutMs = 30 * 1000; // 30 seconds\n\n      while (isLanguageMigrationInProgress(locale)) {\n        if (Date.now() - startTime > timeoutMs) {\n          console.warn(\n            `Migration timeout: ${locale} migration took longer than ${timeoutMs}ms, proceeding anyway`\n          );\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 50));\n      }\n      return isCurrentLanguageMigrationCompleted(locale);\n    }\n\n    // Ensuring locale is migrated\n    return await migrateCurrentLanguage(locale);\n  } catch (error) {\n    console.error(`Error ensuring ${locale} migration:`, error);\n\n    // Graceful fallback: allow the app to continue even if migration fails\n    console.warn(`Migration failed for ${locale}, but app will continue with available data`);\n    return false;\n  }\n};\n\n/**\n * Run migration if needed (optimized for current language first)\n */\nexport const runMigrationIfNeeded = async (): Promise<boolean> => {\n  try {\n    const currentLocale = await getCurrentLanguage();\n\n    // Check if the current language is already migrated\n    if (isCurrentLanguageMigrationCompleted(currentLocale)) {\n      return true;\n    }\n\n    // Prevent concurrent migrations\n    if (isMigrationInProgress()) {\n      // Wait for the current migration to complete with timeout\n      const startTime = Date.now();\n      const timeoutMs = 30 * 1000; // 30 seconds\n\n      while (isMigrationInProgress()) {\n        if (Date.now() - startTime > timeoutMs) {\n          console.warn(\n            `Migration timeout: main migration took longer than ${timeoutMs}ms, proceeding anyway`\n          );\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 50));\n      }\n      // Re-check if migration is now completed\n      return (\n        isMigrationCompleted() || isCurrentLanguageMigrationCompleted(await getCurrentLanguage())\n      );\n    }\n\n    setMigrationInProgress(true);\n\n    try {\n      // Fast path: migrate current language only\n      const success = await migrateCurrentLanguage(currentLocale);\n\n      if (success) {\n        // Don't mark main migration as complete yet - only mark the current language as complete\n        // The main migration will be marked complete when all languages are done in background migration\n\n        // Queue background migration for other languages\n        queueBackgroundMigration(currentLocale);\n      }\n\n      return success;\n    } finally {\n      setMigrationInProgress(false);\n    }\n  } catch (error) {\n    console.error('Error in runMigrationIfNeeded:', error);\n    setMigrationInProgress(false);\n    // Graceful fallback: allow app to continue even if migration fails\n    console.warn('Migration failed, but app will continue with existing data');\n    return false;\n  }\n};\n\n/**\n * Get migration status for debugging\n */\nexport const getMigrationStatus = (): {\n  main: MigrationStatus | null;\n  background: BackgroundMigrationStatus | null;\n} => {\n  try {\n    const mainStatus = localStorage.getItem(MIGRATION_KEY);\n    const bgStatus = localStorage.getItem(BACKGROUND_MIGRATION_KEY);\n\n    return {\n      main: mainStatus ? JSON.parse(mainStatus) : null,\n      background: bgStatus ? JSON.parse(bgStatus) : null,\n    };\n  } catch (error) {\n    console.error('Error getting migration status:', error);\n    return { main: null, background: null };\n  }\n};\n\n/**\n * Reset migration status (for debugging/development)\n */\nexport const resetMigrationStatus = (): void => {\n  try {\n    localStorage.removeItem(MIGRATION_KEY);\n    localStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n    localStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n    localStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    localStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n  } catch (error) {\n    console.error('Error resetting migration status:', error);\n  }\n};\n\n/**\n * Developer utility: Force a fresh migration by clearing all data\n * This is equivalent to bumping the migration version\n */\nexport const forceFreshMigration = async (): Promise<void> => {\n  try {\n    // Clear all localStorage\n    resetMigrationStatus();\n\n    // Optionally clear Dexie database too for a completely fresh start\n    const db = await import('@/stores/store');\n    await db.default.customGroups.clear();\n    await db.default.customTiles.clear();\n  } catch (error) {\n    console.error('Error forcing fresh migration:', error);\n  }\n};\n\n/**\n * Clean up any potential duplicates that may have been created during concurrent migrations\n */\nexport const cleanupDuplicatesIfNeeded = async (): Promise<void> => {\n  try {\n    const status = getMigrationStatus();\n    if (status.main?.completed || status.background?.completedLanguages?.length) {\n      const duplicatesRemoved = await cleanupDuplicateGroups();\n      if (duplicatesRemoved > 0) {\n        // Cleaned up duplicate entries\n      }\n    }\n  } catch (error) {\n    console.warn('Cleanup operation failed:', error);\n  }\n};\n"],"file":"js/migrationService.ts-FcMbtHW2.js"}