{"version":3,"mappings":"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","names":["db","getFirestore","deleteAllCustomTiles","deleteAllIsCustomTiles","async","cleanupDuplicateTiles","allTiles","getTiles","tileGroups","Map","forEach","tile","key","group_id","intensity","action","has","set","get","push","tiles","length","sort","a","b","id","original","duplicates","slice","wasDisabled","some","isEnabled","duplicate","deleteCustomTile","updateCustomTile","error","clearUserCustomGroups","deletePromises","getCustomGroups","isDefault","map","group","deleteCustomGroup","Promise","all","resetDisabledDefaults","updatePromises","isCustom","filter","applyDisabledDefaults","disabledDefaults","allDefaultTiles","defaultTilesMap","disabledTile","matchedId","syncCustomTilesToFirebase","user","getAuth","currentUser","customTiles","MAX_REASONABLE_DISABLED_DEFAULTS","splice","setDoc","doc","uid","lastUpdated","Date","merge","syncCustomGroupsToFirebase","customGroups","syncGameBoardsToFirebase","gameBoards","getBoards","syncSettingsToFirebase","settings","useSettingsStore","getState","localPlayers","settingsForFirebase","cleanSettings","Object","fromEntries","entries","value","syncAllDataToFirebase","intelligentSync","success","conflicts","userDocRef","userDoc","getDoc","localCustomTiles","localCustomGroups","exists","userData","data","firebaseCustomTiles","firebaseCustomGroups","syncDataFromFirebase","options","SyncOrchestrator","__vitePreload","import","__VITE_PRELOAD__","syncFromFirebase","syncIntervalId","startPeriodicSync","intervalMinutes","stopPeriodicSync","intervalMs","window","setInterval","auth","isAnonymous","clearInterval","cleanupTiles"],"ignoreList":[],"sources":["../../src/services/syncService.ts"],"sourcesContent":["import {\n  deleteAllIsCustomTiles,\n  deleteCustomTile,\n  getTiles,\n  updateCustomTile,\n} from '@/stores/customTiles';\nimport { deleteCustomGroup, getCustomGroups } from '@/stores/customGroups';\nimport { doc, getDoc, setDoc } from 'firebase/firestore';\n\nimport { CustomGroupPull } from '@/types/customGroups';\nimport { CustomTilePull } from '@/types/customTiles';\nimport { getAuth } from 'firebase/auth';\nimport { getBoards } from '@/stores/gameBoard';\nimport { getFirestore } from 'firebase/firestore';\nimport { useSettingsStore } from '@/stores/settingsStore';\n\n// Updated to use inline type instead of separate interface to avoid unused warning\n\nconst db = getFirestore();\n\n// Export function for sync modules (avoid naming conflict with import)\nexport const deleteAllCustomTiles = deleteAllIsCustomTiles;\n\n// Helper function to clean up ALL duplicate tiles created by sync bug\nexport async function cleanupDuplicateTiles(): Promise<boolean> {\n  try {\n    // Get all tiles to analyze duplicates\n    const allTiles = await getTiles({});\n\n    // Group tiles by composite key to find duplicates\n    const tileGroups = new Map<string, typeof allTiles>();\n\n    allTiles.forEach((tile) => {\n      const key = `${tile.group_id}|${tile.intensity}|${tile.action}`;\n      if (!tileGroups.has(key)) {\n        tileGroups.set(key, []);\n      }\n      tileGroups.get(key)!.push(tile);\n    });\n\n    // For each group, keep only the original (lowest ID) and remove ALL duplicates\n    for (const [, tiles] of tileGroups) {\n      if (tiles.length > 1) {\n        // Sort by ID to find original (lowest ID)\n        tiles.sort((a, b) => (a.id || 0) - (b.id || 0));\n        const original = tiles[0];\n        const duplicates = tiles.slice(1);\n\n        // Check if any duplicate was disabled (user's intent)\n        const wasDisabled = duplicates.some((tile) => tile.isEnabled === 0);\n\n        // Delete ALL duplicates regardless of enabled state\n        for (const duplicate of duplicates) {\n          if (duplicate.id) {\n            await deleteCustomTile(duplicate.id);\n          }\n        }\n\n        // If any duplicate was disabled, disable the original (preserve user intent)\n        if (wasDisabled && original.isEnabled === 1) {\n          await updateCustomTile(original.id!, { isEnabled: 0 });\n        }\n      }\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error cleaning up duplicate tiles:', error);\n    return false;\n  }\n}\n\n// Helper function to clear only user-created custom groups (preserve default groups)\nexport async function clearUserCustomGroups(): Promise<boolean> {\n  try {\n    const userGroups = await getCustomGroups({ isDefault: false });\n\n    // Convert serial deleteCustomGroup calls to concurrent operations\n    const deletePromises = userGroups.map((group) => deleteCustomGroup(group.id));\n    await Promise.all(deletePromises);\n\n    return true;\n  } catch (error) {\n    console.error('Error deleting user custom groups:', error);\n    return false;\n  }\n}\n\n// Helper function to reset disabled defaults back to enabled state before restoring from Firebase\nexport async function resetDisabledDefaults(): Promise<boolean> {\n  try {\n    const disabledDefaults = await getTiles({ isCustom: 0, isEnabled: 0 });\n\n    // Filter out tiles without IDs and batch updateCustomTile operations concurrently\n    const validTiles = disabledDefaults.filter((tile) => tile.id);\n    const updatePromises = validTiles.map(\n      (tile) => updateCustomTile(tile.id!, { isEnabled: 1 }) // Reset to enabled state - Firebase will restore the correct disabled state\n    );\n    await Promise.all(updatePromises);\n\n    return true;\n  } catch (error) {\n    console.error('Error resetting disabled default tiles:', error);\n    return false;\n  }\n}\n\n// Helper function to apply disabled defaults from Firebase to existing default tiles\nexport async function applyDisabledDefaults(disabledDefaults: CustomTilePull[]): Promise<boolean> {\n  try {\n    // Prefetch all existing default tiles in a single query\n    const allDefaultTiles = await getTiles({ isCustom: 0 });\n\n    // Build an in-memory map keyed by composite key (gameMode|group|intensity|action) for O(1) lookups\n    const defaultTilesMap = new Map<string, number>();\n    allDefaultTiles.forEach((tile) => {\n      const key = `${tile.group_id}|${tile.intensity}|${tile.action}`;\n      defaultTilesMap.set(key, tile.id);\n    });\n\n    // Iterate disabledDefaults and collect update calls only for matched IDs\n    const updatePromises: Promise<number>[] = [];\n    disabledDefaults.forEach((disabledTile) => {\n      const key = `${disabledTile.group_id}|${disabledTile.intensity}|${disabledTile.action}`;\n      const matchedId = defaultTilesMap.get(key);\n\n      if (matchedId) {\n        updatePromises.push(updateCustomTile(matchedId, { isEnabled: 0 }));\n      }\n    });\n\n    // Run updates in a single batch using Promise.all\n    await Promise.all(updatePromises);\n    return true;\n  } catch (error) {\n    console.error('Error applying disabled defaults:', error);\n    return false;\n  }\n}\n\n// Sync custom tiles and disabled defaults to Firebase\nexport async function syncCustomTilesToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get custom tiles (user-created content)\n    const customTiles = await getTiles({ isCustom: 1 });\n\n    // Get disabled default tiles (user disabled these defaults)\n    const disabledDefaults = await getTiles({ isCustom: 0, isEnabled: 0 });\n\n    // Add validation to prevent uploading excessive disabled defaults\n    const MAX_REASONABLE_DISABLED_DEFAULTS = 100;\n    if (disabledDefaults.length > MAX_REASONABLE_DISABLED_DEFAULTS) {\n      console.warn(\n        `⚠️  Attempting to sync ${disabledDefaults.length} disabled defaults, which seems excessive.`\n      );\n      console.warn(\n        'This may indicate corrupted local data. Limiting to first 100 disabled defaults.'\n      );\n\n      // Limit to first 100 to prevent Firebase corruption\n      disabledDefaults.splice(MAX_REASONABLE_DISABLED_DEFAULTS);\n    }\n\n    // Create a document in Firebase with both custom tiles and disabled defaults\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        customTiles,\n        disabledDefaults,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing custom tiles:', error);\n    return false;\n  }\n}\n\n// Utility function to clean up corrupted disabled defaults in Firebase\nexport async function cleanupCorruptedDisabledDefaults(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get only genuinely user-disabled tiles (reasonable count)\n    const disabledDefaults = await getTiles({ isCustom: 0, isEnabled: 0 });\n\n    // If still excessive, something is wrong locally too\n    if (disabledDefaults.length > 100) {\n      console.warn(\n        '⚠️  Local disabled defaults count is also excessive. This suggests system-wide data corruption.'\n      );\n      console.warn('Consider using the reset disabled defaults function in the app settings.');\n      return false;\n    }\n\n    // Get current Firebase data to preserve other fields\n    const userDocRef = doc(db, 'user-data', user.uid);\n    const userDoc = await getDoc(userDocRef);\n\n    if (!userDoc.exists()) {\n      return true;\n    }\n\n    const userData = userDoc.data();\n\n    // Update only the disabledDefaults field with the cleaned data\n    await setDoc(userDocRef, {\n      ...userData,\n      disabledDefaults,\n      lastUpdated: new Date(),\n    });\n\n    return true;\n  } catch (error) {\n    console.error('❌ Error cleaning up corrupted disabled defaults:', error);\n    return false;\n  }\n}\n\n// Sync only user-created custom groups to Firebase (NOT default groups)\nexport async function syncCustomGroupsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get only user-created custom groups (not default groups)\n    const customGroups = await getCustomGroups({ isDefault: false });\n\n    // Create a document in Firebase with only user-created custom groups\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        customGroups,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing custom groups:', error);\n    return false;\n  }\n}\n\n// Sync game boards to Firebase\nexport async function syncGameBoardsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get all game boards from Dexie\n    const gameBoards = await getBoards();\n\n    if (!gameBoards.length) {\n      return true;\n    }\n\n    // Create a document in Firebase with all game boards\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        gameBoards,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing game boards:', error);\n    return false;\n  }\n}\n\n// Sync user settings (including theme preferences) to Firebase\nexport async function syncSettingsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get current settings from store\n    const { settings } = useSettingsStore.getState();\n\n    // Filter out local player settings and any undefined values - they should stay in React app only\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { localPlayers, ...settingsForFirebase } = settings;\n\n    // Remove any undefined values from settings to prevent Firebase errors\n    const cleanSettings = Object.fromEntries(\n      Object.entries(settingsForFirebase).filter(([, value]) => value !== undefined)\n    );\n\n    // Create a document in Firebase with filtered user settings\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        settings: cleanSettings,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing settings:', error);\n    return false;\n  }\n}\n\n// Sync all data to Firebase\nexport async function syncAllDataToFirebase(): Promise<boolean> {\n  await syncCustomTilesToFirebase();\n  await syncCustomGroupsToFirebase();\n  await syncGameBoardsToFirebase();\n  await syncSettingsToFirebase();\n  return true;\n}\n\n// Intelligent sync that handles conflicts - meant for user-initiated sync\nexport async function intelligentSync(): Promise<{ success: boolean; conflicts?: string[] }> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    return { success: false, conflicts: ['No user logged in'] };\n  }\n\n  try {\n    // Get both local and Firebase data\n    const userDocRef = doc(db, 'user-data', user.uid);\n    const userDoc = await getDoc(userDocRef);\n\n    const localCustomTiles = await getTiles({ isCustom: 1 });\n    const localCustomGroups = await getCustomGroups({ isDefault: false });\n\n    const conflicts: string[] = [];\n\n    if (!userDoc.exists()) {\n      // No Firebase data - sync local to Firebase\n      await syncAllDataToFirebase();\n      return { success: true };\n    }\n\n    const userData = userDoc.data();\n    const firebaseCustomTiles = (userData.customTiles as CustomTilePull[]) || [];\n    const firebaseCustomGroups = (userData.customGroups as CustomGroupPull[]) || [];\n\n    // Check for conflicts\n    if (localCustomTiles.length > 0 && firebaseCustomTiles.length > 0) {\n      conflicts.push(\n        `Custom tiles: Local has ${localCustomTiles.length}, Firebase has ${firebaseCustomTiles.length}`\n      );\n    }\n\n    if (localCustomGroups.length > 0 && firebaseCustomGroups.length > 0) {\n      conflicts.push(\n        `Custom groups: Local has ${localCustomGroups.length}, Firebase has ${firebaseCustomGroups.length}`\n      );\n    }\n\n    if (conflicts.length > 0) {\n      return { success: false, conflicts };\n    }\n\n    // No conflicts - proceed with normal sync\n    const result = await syncDataFromFirebase();\n    return { success: result };\n  } catch (error) {\n    console.error('Error in intelligent sync:', error);\n    return { success: false, conflicts: ['Sync failed due to error'] };\n  }\n}\n\n// Enhanced sync with conflict resolution - preserves local data when Firebase is empty\nexport async function syncDataFromFirebase(\n  options: { forceSync?: boolean } = {}\n): Promise<boolean> {\n  // Use the new sync orchestrator for better maintainability\n  const { SyncOrchestrator } = await import('./sync/syncOrchestrator');\n  return await SyncOrchestrator.syncFromFirebase(options);\n}\n\n// Variable to store the interval ID for periodic syncing\nlet syncIntervalId: number | null = null;\n\n// Start periodic syncing from Firebase (every 5 minutes)\nexport function startPeriodicSync(intervalMinutes = 5): boolean {\n  // Clear any existing interval first\n  stopPeriodicSync();\n\n  // Convert minutes to milliseconds\n  const intervalMs = intervalMinutes * 60 * 1000;\n\n  // Set up the interval\n  syncIntervalId = window.setInterval(async () => {\n    const auth = getAuth();\n    if (auth.currentUser && !auth.currentUser.isAnonymous) {\n      await syncDataFromFirebase();\n    }\n  }, intervalMs);\n\n  return true;\n}\n\n// Stop periodic syncing\nexport function stopPeriodicSync(): boolean {\n  if (syncIntervalId) {\n    window.clearInterval(syncIntervalId);\n    syncIntervalId = null;\n    return true;\n  }\n  return false;\n}\n\n// Check if periodic sync is active\nexport function isPeriodicSyncActive(): boolean {\n  return syncIntervalId !== null;\n}\n\n// Manual cleanup function that can be called from console for immediate cleanup\n(window as any).cleanupTiles = cleanupDuplicateTiles;\n"],"file":"syncService.ts-rRhqAAU_.js"}