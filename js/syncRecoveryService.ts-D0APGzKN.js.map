{"version":3,"file":"syncRecoveryService.ts-D0APGzKN.js","sources":["../../src/services/syncRecoveryService.ts"],"sourcesContent":["/**\n * Sync Recovery Service\n *\n * Detects and recovers from sync service data loss bug.\n * Runs on app startup to identify users with corrupted local databases\n * and trigger recovery through migration system.\n */\n\nimport { forceFreshMigration } from '@/services/migrationService';\nimport { getCustomGroups } from '@/stores/customGroups';\nimport { getTiles } from '@/stores/customTiles';\nimport { safeLocalStorage } from '@/services/migration/errorHandling';\nimport { MIGRATION_VERSION } from '@/services/migration/constants';\n\n// Recovery tracking\nconst RECOVERY_STATUS_KEY = 'blitzed-out-sync-recovery-status';\nconst RECOVERY_VERSION = MIGRATION_VERSION;\nconst MIN_DEFAULT_TILE_COUNT = 50; // Should have hundreds of default actions\n\ninterface RecoveryStatus {\n  version: string;\n  recoveryPerformed: boolean;\n  detectedCorruption: boolean;\n  recoveryTimestamp: number;\n}\n\n// Promise guard to prevent concurrent duplicate recoveries\nlet recoveryInFlight: Promise<boolean> | null = null;\n\n/**\n * Main recovery function - call this on app startup\n */\nexport async function runSyncRecovery(): Promise<boolean> {\n  // Check if recovery is already in flight\n  if (recoveryInFlight) {\n    return await recoveryInFlight;\n  }\n\n  // Create and assign new recovery promise\n  recoveryInFlight = (async (): Promise<boolean> => {\n    try {\n      // Check if recovery already performed for this version\n      const recoveryStatus = getRecoveryStatus();\n      if (recoveryStatus?.recoveryPerformed && recoveryStatus?.version === RECOVERY_VERSION) {\n        return false; // Recovery already done\n      }\n\n      // Detect corruption\n      const isCorrupted = await detectDatabaseCorruption();\n\n      if (isCorrupted) {\n        // Force fresh migration to rebuild everything\n        await forceFreshMigration();\n\n        // Mark recovery as completed\n        markRecoveryCompleted(true);\n        return true;\n      } else {\n        // Mark recovery as checked (no corruption found)\n        markRecoveryCompleted(false);\n        return false;\n      }\n    } catch (error) {\n      console.error('[Sync Recovery] Error during recovery:', error);\n      return false;\n    } finally {\n      // Clear the in-flight promise so future calls can run\n      recoveryInFlight = null;\n    }\n  })();\n\n  return await recoveryInFlight;\n}\n\n/**\n * Detect if local database is corrupted by sync bug\n */\nasync function detectDatabaseCorruption(): Promise<boolean> {\n  try {\n    // Check 1: No default groups exist (major red flag)\n    const defaultGroups = await getCustomGroups({ isDefault: true });\n    const hasDefaultGroups = defaultGroups.length > 0;\n\n    // Check 2: Very few total actions (likely only custom ones remain)\n    const allTiles = await getTiles({});\n    const totalTileCount = allTiles.length;\n\n    // Check 3: No enabled default actions (everything was nuked)\n    const enabledDefaults = await getTiles({ isCustom: 0, isEnabled: 1 });\n    const hasEnabledDefaults = enabledDefaults.length > 0;\n\n    // Corruption indicators\n    const corruptionIndicators = {\n      noDefaultGroups: !hasDefaultGroups,\n      fewTotalActions: totalTileCount < MIN_DEFAULT_TILE_COUNT,\n      noEnabledDefaults: !hasEnabledDefaults,\n    };\n\n    const corruptionScore = Object.values(corruptionIndicators).filter(Boolean).length;\n\n    // Analysis for debugging in development\n    if (process.env.NODE_ENV === 'development') {\n      console.debug('[Sync Recovery] Corruption analysis:', {\n        defaultGroups: defaultGroups.length,\n        totalTiles: totalTileCount,\n        enabledDefaults: enabledDefaults.length,\n        indicators: corruptionIndicators,\n        score: corruptionScore,\n      });\n    }\n\n    // If 2 or more indicators, likely corrupted\n    return corruptionScore >= 2;\n  } catch (error) {\n    console.error('[Sync Recovery] Error detecting corruption:', error);\n    return false; // Don't trigger recovery if we can't detect properly\n  }\n}\n\n/**\n * Get recovery status from localStorage\n */\nfunction getRecoveryStatus(): RecoveryStatus | null {\n  return safeLocalStorage.getJSON<RecoveryStatus>(RECOVERY_STATUS_KEY);\n}\n\n/**\n * Mark recovery as completed\n */\nfunction markRecoveryCompleted(detectedCorruption: boolean): void {\n  const status: RecoveryStatus = {\n    version: RECOVERY_VERSION,\n    recoveryPerformed: true,\n    detectedCorruption,\n    recoveryTimestamp: Date.now(),\n  };\n\n  safeLocalStorage.setJSON(RECOVERY_STATUS_KEY, status);\n}\n\n/**\n * Reset recovery status (for testing)\n */\nexport function resetRecoveryStatus(): void {\n  safeLocalStorage.removeItem(RECOVERY_STATUS_KEY);\n  recoveryInFlight = null; // Also reset the in-flight promise\n}\n\n/**\n * Check if user was affected by the sync bug\n */\nexport function wasUserAffectedBySync(): boolean {\n  const status = getRecoveryStatus();\n  return status?.detectedCorruption === true;\n}\n\n/**\n * Force recovery for testing\n */\nexport async function forceRecovery(): Promise<boolean> {\n  resetRecoveryStatus();\n  return await runSyncRecovery();\n}\n"],"names":["RECOVERY_STATUS_KEY","RECOVERY_VERSION","MIGRATION_VERSION","recoveryInFlight","async","runSyncRecovery","recoveryStatus","safeLocalStorage","getJSON","recoveryPerformed","version","hasDefaultGroups","getCustomGroups","isDefault","length","totalTileCount","getTiles","corruptionIndicators","noDefaultGroups","fewTotalActions","noEnabledDefaults","isCustom","isEnabled","Object","values","filter","Boolean","error","detectDatabaseCorruption","forceFreshMigration","markRecoveryCompleted","detectedCorruption","status","recoveryTimestamp","Date","now","setJSON"],"mappings":"+1BAeA,MAAMA,EAAsB,mCACtBC,EAAmBC,EAWzB,IAAIC,EAA4C,KAKhDC,eAAsBC,IAEpB,OAAIF,IAKJA,EAAA,WACE,IAEE,MAAMG,EAiFHC,EAAiBC,QAAwBR,GAhF5C,SAAI,MAAAM,OAAA,EAAAA,EAAgBG,qBAAqB,MAAAH,OAAA,EAAAA,EAAgBI,WAAYT,WAkC3EG,iBACE,IAEE,MACMO,SADsBC,EAAgB,CAAEC,WAAW,KAClBC,OAAS,EAI1CC,SADiBC,EAAS,KACAF,OAO1BG,EAAuB,CAC3BC,iBAAkBP,EAClBQ,gBAAiBJ,EA7EQ,GA8EzBK,2BAP4BJ,EAAS,CAAEK,SAAU,EAAGC,UAAW,KACtBR,OAAS,IAuBpD,OAdwBS,OAAOC,OAAOP,GAAsBQ,OAAOC,SAASZ,QAclD,CAC5B,OAASa,GAEP,OAAO,CACT,CACF,CArEgCC,UAIlBC,IAGNC,GAAsB,IACf,IAGPA,GAAsB,IACf,GAEX,OAASH,GAEP,OAAO,CACT,CAAA,QAEExB,EAAmB,IACrB,CACF,EA9BA,UAJeA,CAqCjB,CAyDA,SAAS2B,EAAsBC,GAC7B,MAAMC,EAAyB,CAC7BtB,QAAST,EACTQ,mBAAmB,EACnBsB,qBACAE,kBAAmBC,KAAKC,OAG1B5B,EAAiB6B,QAAQpC,EAAqBgC,EAChD"}