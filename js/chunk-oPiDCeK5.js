var U=Object.defineProperty;var z=(s,r,e)=>r in s?U(s,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[r]=e;var m=(s,r,e)=>z(s,typeof r!="symbol"?r+"":r,e);import{r as u}from"./chunk-u7ZaklyY.js";import{n as M,a as V}from"./chunk-C1hnJ-He.js";import{z as P,p as j}from"./chunk-CaZ9lMwi.js";(function(){var s=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{};s.SENTRY_RELEASE={id:"b0aec1b7336667c3da787da9b7139ec106644213"}})();try{(function(){var s=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},r=new s.Error().stack;r&&(s._sentryDebugIds=s._sentryDebugIds||{},s._sentryDebugIds[r]="5bd692fa-59ed-4561-b1fa-93ed3a6db0ce",s._sentryDebugIdIdentifier="sentry-dbid-5bd692fa-59ed-4561-b1fa-93ed3a6db0ce")})()}catch{}const f=class f{constructor(){m(this,"currentSession",null)}static getInstance(){return f.instance||(f.instance=new f),f.instance}async createSession(r,e,n){try{this.validateSessionInput(r,e,n);const t=M(),o=Date.now(),c=e.map(y=>({...y,location:y.location??0,isFinished:y.isFinished??!1})),a={id:t,roomId:r,players:c,currentPlayerIndex:0,isActive:!0,createdAt:o,updatedAt:o,settings:{...n}},i={sessionId:a.id,roomId:a.roomId,players:a.players,currentPlayerIndex:a.currentPlayerIndex,isActive:a.isActive,createdAt:a.createdAt,updatedAt:a.updatedAt,settings:a.settings};return await P.localPlayerSessions.add(i),this.currentSession=a,a}catch(t){throw new Error(`Failed to create local player session: ${t instanceof Error?t.message:"Unknown error"}`)}}async getSession(r){try{if(!r)throw new Error("Session ID is required");const e=await P.localPlayerSessions.where("sessionId").equals(r).first();return e?this.convertDbSessionToSession(e):null}catch(e){throw new Error(`Failed to get session: ${e instanceof Error?e.message:"Unknown error"}`)}}async updateSession(r,e){try{if(!r)throw new Error("Session ID is required");const n=await this.getSession(r);if(!n)throw new Error("Session not found");const t={...n,...e,id:r,createdAt:n.createdAt,updatedAt:Date.now()},o={roomId:t.roomId,players:t.players,currentPlayerIndex:t.currentPlayerIndex,isActive:t.isActive,updatedAt:t.updatedAt,settings:t.settings};return await P.localPlayerSessions.where("sessionId").equals(r).modify(o),this.currentSession?.id===r&&(this.currentSession=t),t}catch(n){throw new Error(`Failed to update session: ${n instanceof Error?n.message:"Unknown error"}`)}}async advanceLocalTurn(r){try{if(!r)throw new Error("Session ID is required");const e=await this.getSession(r);if(!e)throw new Error("Session not found");if(!e.isActive)throw new Error("Cannot advance turn on inactive session");if(e.players.length===0)throw new Error("No players in session");const n=(e.currentPlayerIndex+1)%e.players.length,t=e.players.map((c,a)=>({...c,isActive:a===n}));return(await this.updateSession(r,{players:t,currentPlayerIndex:n})).players[n]}catch(e){throw new Error(`Failed to advance turn: ${e instanceof Error?e.message:"Unknown error"}`)}}getCurrentSession(){return this.currentSession}async updatePlayerPosition(r,e,n,t=!1){try{if(!r)throw new Error("Session ID is required");if(!e)throw new Error("Player ID is required");if(n<0)throw new Error("Location must be non-negative");const o=await this.getSession(r);if(!o)throw new Error("Session not found");if(!o.isActive)throw new Error("Cannot update player position on inactive session");const c=o.players.findIndex(i=>i.id===e);if(c===-1)throw new Error(`Player with ID ${e} not found in session`);const a=[...o.players];return a[c]={...a[c],location:n,isFinished:t},await this.updateSession(r,{players:a}),a[c]}catch(o){throw new Error(`Failed to update player position: ${o instanceof Error?o.message:"Unknown error"}`)}}clearCurrentSession(){this.currentSession=null}validateSessionInput(r,e,n){if(!r||typeof r!="string")throw new Error("Valid room ID is required");if(!Array.isArray(e)||e.length<2||e.length>4)throw new Error("Session must have between 2 and 4 players");e.forEach((i,y)=>{if(!i.id||typeof i.id!="string")throw new Error(`Player at index ${y} must have a valid ID`);if(!i.name||typeof i.name!="string")throw new Error(`Player at index ${y} must have a valid name`);if(!["sub","dom","vers"].includes(i.role))throw new Error(`Player at index ${y} must have a valid role`);if(typeof i.location<"u"&&(typeof i.location!="number"||i.location<0))throw new Error(`Player at index ${y} must have a valid location (non-negative number)`)});const t=e.map(i=>i.id),o=new Set(t);if(t.length!==o.size)throw new Error("All players must have unique IDs");const c=e.map(i=>i.name.toLowerCase()),a=new Set(c);if(c.length!==a.size)throw new Error("All players must have unique names");if(!n||typeof n!="object")throw new Error("Valid settings object is required")}convertDbSessionToSession(r){return{id:r.sessionId,roomId:r.roomId,players:r.players,currentPlayerIndex:r.currentPlayerIndex,isActive:r.isActive,createdAt:r.createdAt,updatedAt:r.updatedAt,settings:r.settings}}};m(f,"instance");let v=f;const g=v.getInstance(),B=V()(j((s,r)=>({session:null,error:null,isLoading:!1,hasLocalPlayers:()=>{const e=r().session;return e?.isActive===!0&&e.players.length>0},isLocalPlayerRoom:()=>r().session?.isActive===!0,getCurrentPlayer:()=>{const e=r().session;if(!e?.isActive||!e.players||e.players.length===0)return null;const n=e.currentPlayerIndex||0,t=e.players[n];if(!t)return null;const o={...t};return typeof o.location!="number"&&(o.location=0),typeof o.isFinished!="boolean"&&(o.isFinished=!1),o},setSession:e=>{const n=e?r()._migrateSession(e):null;s({session:n,error:null})},_migrateSession:e=>{if(!e||!e.players)return e;const n=e.players.map(t=>({...t,location:typeof t.location=="number"?t.location:0,isFinished:typeof t.isFinished=="boolean"?t.isFinished:!1,sound:t.sound||""}));return{...e,players:n}},clearSession:()=>{g.clearCurrentSession(),s({session:null,error:null})},setError:e=>{s({error:e,isLoading:!1})},setLoading:e=>{s({isLoading:e})},initSession:async(e,n,t)=>{try{s({isLoading:!0,error:null});const o=await g.createSession(e,n,t);s({session:o,isLoading:!1,error:null})}catch(o){const c=o instanceof Error?o.message:"Failed to create session";s({error:c,isLoading:!1,session:null})}},loadSession:async e=>{try{s({isLoading:!0,error:null});const n=await g.getSession(e);s({session:n,isLoading:!1,error:null})}catch(n){const t=n instanceof Error?n.message:"Failed to load session";s({error:t,isLoading:!1,session:null})}},nextLocalPlayer:async()=>{try{s({isLoading:!0,error:null});const e=r().session;if(!e)throw new Error("No active session");await g.advanceLocalTurn(e.id);const n=await g.getSession(e.id);s({session:n,isLoading:!1,error:null})}catch(e){const n=e instanceof Error?e.message:"Failed to advance turn";s({error:n,isLoading:!1})}},updateSessionSettings:async e=>{try{s({isLoading:!0,error:null});const n=r().session;if(!n)throw new Error("No active session");const t=await g.updateSession(n.id,{settings:e});s({session:t,isLoading:!1,error:null})}catch(n){const t=n instanceof Error?n.message:"Failed to update session settings";s({error:t,isLoading:!1})}}}),{name:"local-player-store",partialize:s=>({session:s.session}),onRehydrateStorage:()=>s=>{s&&(s.isLoading=!1,s.error=null)}}));function J(){const{session:s,error:r,isLoading:e,hasLocalPlayers:n,isLocalPlayerRoom:t,getCurrentPlayer:o,setSession:c,clearSession:a,setError:i,setLoading:y,initSession:E,loadSession:b,nextLocalPlayer:I,updateSessionSettings:A}=B(),d=u.useMemo(()=>s?.players||[],[s?.players]),L=o(),w=s?.currentPlayerIndex??-1,x=s?.settings,C=u.useCallback(async(l,p,R)=>{await E(l,p,R)},[E]),D=u.useCallback(async l=>{await b(l)},[b]),k=u.useCallback(async()=>{await I()},[I]),F=u.useCallback(()=>{a()},[a]),q=u.useCallback(async l=>{await A(l)},[A]),h=u.useCallback(l=>l>=0&&l<d.length?d[l]:null,[d]),S=u.useCallback(l=>d.find(p=>p.id===l)||null,[d]),T=u.useCallback(l=>S(l)?.isActive===!0,[S]),$=u.useCallback(()=>{if(d.length===0)return null;const l=(w+1)%d.length;return h(l)},[d,w,h]),N=u.useCallback(()=>{if(d.length===0)return null;const l=w===0?d.length-1:w-1;return h(l)},[d,w,h]);return{session:s,localPlayers:d,currentPlayer:L,currentPlayerIndex:w,sessionSettings:x,error:r,isLoading:e,hasLocalPlayers:n(),isLocalPlayerRoom:t(),playerCount:d.length,isValidSession:s?.isActive===!0&&d.length>=2,createLocalSession:C,loadLocalSession:D,clearLocalSession:F,advanceToNextPlayer:k,updateSettings:q,getPlayerByIndex:h,getPlayerById:S,isPlayerActive:T,getNextPlayer:$,getPreviousPlayer:N,setSession:c,setError:i,setLoading:y}}export{B as a,g as l,J as u};
//# sourceMappingURL=chunk-oPiDCeK5.js.map
