{"version":3,"file":"chunk-CFN5SuUV.js","sources":["../../src/helpers/arrays.ts","../../src/views/GameSettings/submitForm.ts","../../src/services/validationService.ts","../../src/services/gameSettingsMessage.ts","../../src/services/buildGame.ts","../../src/hooks/useGameBoard.ts","../../src/hooks/useRoomNavigate.ts","../../src/hooks/useSubmitGameSettings.ts","../../src/hooks/useUnifiedActionList.ts"],"sourcesContent":["export function shuffleArray<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\nexport function cycleArray<T>(array: T[]): void {\n  if (array.length > 1) array.push(array.shift() as T);\n}\n\nexport function arraysEqual<T>(arr1: T[], arr2: T[]): boolean {\n  if (arr1?.length !== arr2?.length) return false;\n  return arr1.every((element, index) => element === arr2[index]);\n}\n","import { Settings } from '@/types/Settings';\nimport { User } from '@/types';\nimport { getSiteName } from '@/helpers/urls';\nimport i18next from 'i18next';\nimport { sendMessage } from '@/services/firebase';\n\nfunction getRoomSettingsMessage(settings: Partial<Settings>): string {\n  const { t } = i18next;\n  let message = `### ${t('roomSettings')}\\r\\n`;\n\n  Object.entries(settings).forEach(([key, val]) => {\n    if (key === 'room') return; // we handle the room separately.\n    if (key === 'roomBackgroundURL' && val !== '') {\n      message += `* ${t(key)}: [${getSiteName(val)}:link:](${val})\\r\\n`;\n      return;\n    }\n    if (key === 'roomRealtime') {\n      message += `* ${t('playerList')}: ${val ? t('delayed') : t('realtime')}\\r\\n`;\n      return;\n    }\n    if (val !== '') {\n      message += `* ${t(key)}: ${val}\\r\\n`;\n    }\n  });\n  return message;\n}\n\nfunction exportRoomSettings(formData: Settings): Partial<Settings> {\n  const newSettings: Partial<Settings> = {};\n  // Include only message-relevant room fields; omit control flags and deprecated roomBackground\n  Object.entries(formData).forEach(([settingKey, settingValue]) => {\n    if (\n      settingKey.startsWith('room') &&\n      !['roomUpdated', 'roomBackground', 'roomBackgroundURL'].includes(settingKey)\n    ) {\n      newSettings[settingKey] = settingValue;\n    }\n  });\n\n  // Only include background URL if it exists and is valid\n  if (formData.roomBackgroundURL && formData.roomBackgroundURL.trim() !== '') {\n    newSettings.roomBackgroundURL = formData.roomBackgroundURL;\n  }\n\n  return newSettings;\n}\n\nexport async function handleUser(\n  user: User | null,\n  displayName: string | undefined,\n  updateUser: (displayName: string) => Promise<User | null>\n): Promise<User | null> {\n  let updatedUser = user;\n  if (displayName !== undefined && displayName.length > 0) {\n    updatedUser = await updateUser(displayName);\n  }\n  return updatedUser;\n}\n\nexport function sendRoomSettingsMessage(formData: Settings, updatedUser: User): Promise<any> {\n  const roomSettings = exportRoomSettings(formData);\n  return sendMessage({\n    room: formData.room,\n    user: updatedUser,\n    text: getRoomSettingsMessage(roomSettings),\n    type: 'room',\n    settings: JSON.stringify(roomSettings),\n  });\n}\n","import { ValidationResult, CustomGroupBase, CustomGroupIntensity } from '@/types/customGroups';\nimport { CustomTile } from '@/types/customTiles';\nimport { isGroupNameUnique, getCustomGroupByName } from '@/stores/customGroups';\nimport { t } from 'i18next';\nimport { logger } from '@/utils/logger';\n\n/**\n * Validation service for custom groups and tiles\n */\n\n// Constants for validation rules\nconst MAX_GROUP_NAME_LENGTH = 50;\nconst MAX_GROUP_LABEL_LENGTH = 100;\nconst MAX_INTENSITY_LABEL_LENGTH = 50;\nconst MIN_INTENSITY_VALUE = 1;\nconst MAX_INTENSITY_VALUE = 10;\nconst MIN_INTENSITIES_COUNT = 1;\nconst MAX_INTENSITIES_COUNT = 10;\n\n// Reserved group names that cannot be used for custom groups\n// Only includes names that would cause technical issues or UX confusion\nconst RESERVED_GROUP_NAMES = [\n  'none', // Used in UI for \"select none\" operations\n  'all', // Used in UI for \"select all\" operations\n  'default', // Aligns with isDefault system property\n  'undefined', // JavaScript reserved word\n  'null', // JavaScript reserved word\n];\n\n// Valid group types for custom groups\nconst VALID_GROUP_TYPES = ['solo', 'foreplay', 'sex', 'consumption'] as const;\n\n// Export type for group types\nexport type GroupType = (typeof VALID_GROUP_TYPES)[number];\n\n/**\n * Validate a custom group name\n */\nexport const validateGroupName = (\n  name: string,\n  _locale = 'en',\n  _gameMode = 'online',\n  _excludeId?: string\n): ValidationResult => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check if name is provided\n  if (!name || name.trim().length === 0) {\n    errors.push('Group name is required');\n    return { isValid: false, errors, warnings };\n  }\n\n  const trimmedName = name.trim();\n\n  // Check name length\n  if (trimmedName.length > MAX_GROUP_NAME_LENGTH) {\n    errors.push(`Group name must be ${MAX_GROUP_NAME_LENGTH} characters or less`);\n  }\n\n  // Check for reserved names\n  if (RESERVED_GROUP_NAMES.includes(trimmedName.toLowerCase())) {\n    errors.push(`\"${trimmedName}\" is a reserved name and cannot be used`);\n  }\n\n  // Check for valid characters (alphanumeric, hyphens, underscores)\n  const validNamePattern = /^[a-zA-Z0-9_-]+$/;\n  if (!validNamePattern.test(trimmedName)) {\n    errors.push('Group name can only contain letters, numbers, hyphens, and underscores');\n  }\n\n  // Check if name starts with a letter\n  if (!/^[a-zA-Z]/.test(trimmedName)) {\n    errors.push('Group name must start with a letter');\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Validate a custom group label\n */\nexport const validateGroupLabel = (label: string): ValidationResult => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check if label is provided\n  if (!label || label.trim().length === 0) {\n    errors.push(t('groupLabelRequired'));\n    return { isValid: false, errors, warnings };\n  }\n\n  const trimmedLabel = label.trim();\n\n  // Check label length\n  if (trimmedLabel.length > MAX_GROUP_LABEL_LENGTH) {\n    errors.push(`Group label must be ${MAX_GROUP_LABEL_LENGTH} characters or less`);\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Validate custom group intensities\n */\nexport const validateGroupIntensities = (intensities: CustomGroupIntensity[]): ValidationResult => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check if intensities are provided\n  if (!intensities || intensities.length === 0) {\n    errors.push('At least one intensity level is required');\n    return { isValid: false, errors, warnings };\n  }\n\n  // Check intensities count\n  if (intensities.length < MIN_INTENSITIES_COUNT) {\n    errors.push(`At least ${MIN_INTENSITIES_COUNT} intensity level is required`);\n  }\n\n  if (intensities.length > MAX_INTENSITIES_COUNT) {\n    errors.push(`Maximum ${MAX_INTENSITIES_COUNT} intensity levels allowed`);\n  }\n\n  // Track unique values and labels\n  const usedValues = new Set<number>();\n  const usedLabels = new Set<string>();\n\n  for (let i = 0; i < intensities.length; i++) {\n    const intensity = intensities[i];\n\n    // Validate intensity ID\n    if (!intensity.id || intensity.id.trim().length === 0) {\n      errors.push(`Intensity level ${i + 1} is missing an ID`);\n    }\n\n    // Validate intensity label\n    if (!intensity.label || intensity.label.trim().length === 0) {\n      errors.push(`Intensity level ${i + 1} is missing a label`);\n    } else {\n      const trimmedLabel = intensity.label.trim();\n\n      if (trimmedLabel.length > MAX_INTENSITY_LABEL_LENGTH) {\n        errors.push(\n          `Intensity level ${i + 1} label must be ${MAX_INTENSITY_LABEL_LENGTH} characters or less`\n        );\n      }\n\n      // Check for duplicate labels\n      if (usedLabels.has(trimmedLabel.toLowerCase())) {\n        errors.push(`Intensity label \"${trimmedLabel}\" is used multiple times`);\n      } else {\n        usedLabels.add(trimmedLabel.toLowerCase());\n      }\n    }\n\n    // Validate intensity value\n    if (typeof intensity.value !== 'number' || !Number.isInteger(intensity.value)) {\n      errors.push(`Intensity level ${i + 1} must have a valid integer value`);\n    } else {\n      if (intensity.value < MIN_INTENSITY_VALUE || intensity.value > MAX_INTENSITY_VALUE) {\n        errors.push(\n          `Intensity level ${i + 1} value must be between ${MIN_INTENSITY_VALUE} and ${MAX_INTENSITY_VALUE}`\n        );\n      }\n\n      // Check for duplicate values\n      if (usedValues.has(intensity.value)) {\n        errors.push(`Intensity value ${intensity.value} is used multiple times`);\n      } else {\n        usedValues.add(intensity.value);\n      }\n    }\n  }\n\n  // Warn if intensity values are not sequential\n  const sortedValues = Array.from(usedValues).sort((a, b) => a - b);\n  let expectedValue = sortedValues[0];\n  for (const value of sortedValues) {\n    if (value !== expectedValue) {\n      warnings.push(\n        'Intensity values are not sequential. Consider using values like 1, 2, 3, 4 for better user experience'\n      );\n      break;\n    }\n    expectedValue++;\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Validate a complete custom group\n */\nexport const validateCustomGroup = async (\n  group: CustomGroupBase,\n  excludeId?: string\n): Promise<ValidationResult> => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Validate name\n  const nameValidation = validateGroupName(\n    group.name,\n    group.locale || 'en',\n    group.gameMode || 'online',\n    excludeId\n  );\n  errors.push(...nameValidation.errors);\n  warnings.push(...(nameValidation.warnings || []));\n\n  // Validate label\n  const labelValidation = validateGroupLabel(group.label);\n  errors.push(...labelValidation.errors);\n  warnings.push(...(labelValidation.warnings || []));\n\n  // Validate intensities\n  const intensitiesValidation = validateGroupIntensities(group.intensities);\n  errors.push(...intensitiesValidation.errors);\n  warnings.push(...(intensitiesValidation.warnings || []));\n\n  // Check for unique name (async validation)\n  if (nameValidation.isValid && group.name) {\n    try {\n      const isUnique = await isGroupNameUnique(\n        group.name,\n        group.locale || 'en',\n        group.gameMode || 'online',\n        excludeId\n      );\n\n      if (!isUnique) {\n        errors.push(\n          `A group with the name \"${group.name}\" already exists for this locale and game mode`\n        );\n      }\n    } catch (error) {\n      warnings.push('Could not verify group name uniqueness');\n      logger.warn(\n        'Failed to check group name uniqueness:',\n        false,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n    }\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Validate a custom tile against available groups\n */\nexport const validateCustomTileWithGroups = async (\n  tile: CustomTile,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<ValidationResult> => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check if group exists\n  if (!tile.group || tile.group.trim().length === 0) {\n    errors.push('Tile must belong to a group');\n    return { isValid: false, errors, warnings };\n  }\n\n  try {\n    const group = await getCustomGroupByName(tile.group, locale, gameMode);\n\n    if (!group) {\n      errors.push(`Group \"${tile.group}\" does not exist for ${locale}/${gameMode}`);\n      return { isValid: false, errors, warnings };\n    }\n\n    // Check if intensity value is valid for this group\n    const validIntensityValues = group.intensities.map((i) => i.value);\n    if (!validIntensityValues.includes(tile.intensity)) {\n      errors.push(\n        `Intensity ${tile.intensity} is not valid for group \"${tile.group}\". Valid intensities: ${validIntensityValues.join(', ')}`\n      );\n    }\n\n    // Check if action is provided\n    if (!tile.action || tile.action.trim().length === 0) {\n      errors.push('Tile action is required');\n    }\n  } catch (error) {\n    errors.push(`Error validating tile: ${error}`);\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Validate intensity value for a specific group\n */\nexport const validateIntensityForGroup = async (\n  groupName: string,\n  intensity: number,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<ValidationResult> => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  try {\n    const group = await getCustomGroupByName(groupName, locale, gameMode);\n\n    if (!group) {\n      errors.push(`Group \"${groupName}\" does not exist`);\n      return { isValid: false, errors, warnings };\n    }\n\n    const validIntensityValues = group.intensities.map((i) => i.value);\n    if (!validIntensityValues.includes(intensity)) {\n      errors.push(\n        `Intensity ${intensity} is not valid for group \"${groupName}\". Valid intensities: ${validIntensityValues.join(', ')}`\n      );\n    }\n  } catch (error) {\n    errors.push(`Error validating intensity: ${error}`);\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Get validation constants for use in components\n */\nexport const getValidationConstants = () => ({\n  MAX_GROUP_NAME_LENGTH,\n  MAX_GROUP_LABEL_LENGTH,\n  MAX_INTENSITY_LABEL_LENGTH,\n  MIN_INTENSITY_VALUE,\n  MAX_INTENSITY_VALUE,\n  MIN_INTENSITIES_COUNT,\n  MAX_INTENSITIES_COUNT,\n  RESERVED_GROUP_NAMES,\n  VALID_GROUP_TYPES,\n});\n\n/**\n * Helper function to format validation errors for display\n */\nexport const formatValidationErrors = (validation: ValidationResult): string => {\n  if (validation.isValid) return '';\n\n  let message = validation.errors.join('\\n');\n\n  if (validation.warnings && validation.warnings.length > 0) {\n    message += '\\n\\nWarnings:\\n' + validation.warnings.join('\\n');\n  }\n\n  return message;\n};\n","import { DocumentData, DocumentReference } from 'firebase/firestore';\nimport { getOrCreateBoard, sendMessage } from './firebase';\n\nimport { CustomTilePull } from '@/types/customTiles';\nimport { Settings } from '@/types/Settings';\nimport { TileExport } from '@/types/gameBoard';\nimport { User } from '@/types';\nimport { getCustomGroupByName } from '@/stores/customGroups';\nimport i18next from 'i18next';\nimport { isOnlineMode } from '@/helpers/strings';\n\n/**\n * Type guard to check if an object has a valid role property\n * @param obj - The object to check\n * @param role - The role key to look for\n * @returns true if obj is an object and has the role property\n */\nfunction isValidRole(obj: unknown, role: unknown): obj is Record<string, unknown> {\n  return obj !== null && typeof obj === 'object' && typeof role === 'string' && role in obj;\n}\n\ninterface ActionsList {\n  [key: string]: {\n    label: string;\n    actions: Record<string, any>;\n    [key: string]: any;\n  };\n}\n\nfunction getCustomTileCount(\n  settings: Settings,\n  customTiles: CustomTilePull[] | null | undefined,\n  actionsList: ActionsList\n): number {\n  // Use selectedActions structure only\n  const actionEntries = settings.selectedActions || {};\n\n  const settingsDataFolder = Object.entries(actionsList)\n    .filter(([key]) => actionEntries[key])\n    .reduce<Record<string, string[]>>((acc, [key, value]) => {\n      const levels = actionEntries[key].levels || [];\n      const actionKeys = Object.keys(value.actions);\n      acc[key] = levels.map((level) => actionKeys[level]).filter(Boolean);\n      return acc;\n    }, {});\n\n  const usedCustomTiles =\n    customTiles?.filter((entry) => {\n      // Only count tiles that are actually custom (not migrated defaults)\n      if (!entry.isCustom) return false;\n\n      const intensityArray = settingsDataFolder[entry.group];\n      return intensityArray && intensityArray.length >= Number(entry.intensity);\n    }) || [];\n\n  return usedCustomTiles.length;\n}\n\nexport async function getSettingsMessage(\n  settings: Settings,\n  customTiles: CustomTilePull[] | null | undefined,\n  actionsList: ActionsList,\n  reason?: string\n): Promise<string> {\n  const { t } = i18next;\n  let message = `### ${i18next.t('gameSettingsHeading')}\\r\\n`;\n  if (reason) {\n    message += `##### ${reason}\\r\\n`;\n  }\n  message += '--- \\r\\n';\n\n  // output only settings that have a corresponding actionsList entry.\n  // Use selectedActions structure only\n  const actionEntries = settings.selectedActions || {};\n\n  Object.entries(actionsList).forEach(([key, val]) => {\n    if (!actionEntries[key]) return;\n\n    const { role, variation, levels } = actionEntries[key];\n    const actualRole = role || settings.role || 'sub';\n\n    if (levels && levels.length > 0) {\n      // Show group name with bulleted list of intensity level names\n      message += val?.label;\n\n      let modifier = null;\n      if (variation) {\n        modifier = t(variation);\n      } else if (!isOnlineMode(settings.gameMode)) {\n        modifier = isValidRole(val, actualRole)\n          ? (val[actualRole as string] as string)\n          : t(actualRole as string);\n      }\n\n      if (modifier) {\n        message += `: ${modifier}`;\n      }\n\n      message += '\\r\\n';\n\n      // Get intensity names for selected levels\n      const intensityNames = val?.intensities || {};\n      levels.forEach((level: number) => {\n        const levelName = intensityNames[level] || `Level ${level}`;\n        message += `* ${levelName}\\r\\n`;\n      });\n      message += '\\r\\n';\n    }\n  });\n\n  // Add custom groups from settings.customGroups\n  if (settings.customGroups && Array.isArray(settings.customGroups)) {\n    for (const customGroup of settings.customGroups) {\n      if (customGroup.groupName && customGroup.intensity) {\n        try {\n          // Get the actual custom group data to access the label\n          const groupData = await getCustomGroupByName(\n            customGroup.groupName,\n            settings.locale || 'en',\n            settings.gameMode || 'online'\n          );\n\n          const groupLabel = groupData?.label || customGroup.groupName;\n          message += `* ${groupLabel}: Level ${customGroup.intensity} (Custom)\\r\\n`;\n        } catch (error) {\n          console.error(`Error loading custom group ${customGroup.groupName}:`, error);\n          // Fallback to using groupName as label\n          message += `* ${customGroup.groupName}: Level ${customGroup.intensity} (Custom)\\r\\n`;\n        }\n      }\n    }\n  }\n\n  // if our last line was the --- \\r\\n then return nothing because we have no settings.\n  if (message.endsWith('--- \\r\\n')) {\n    return '';\n  }\n\n  const { finishRange } = settings;\n\n  message += '--- \\r\\n';\n\n  if (finishRange) {\n    const noCumPercent = finishRange[0];\n    const ruinedPercent = finishRange[1] - finishRange[0];\n    const normalPercent = 100 - finishRange[1];\n\n    // Count how many non-zero options we have\n    const optionList: Array<{ percent: number; text: string } | null> = [\n      noCumPercent > 0 ? { percent: noCumPercent, text: t('noCum') as string } : null,\n      ruinedPercent > 0 ? { percent: ruinedPercent, text: t('ruined') as string } : null,\n      normalPercent > 0 ? { percent: normalPercent, text: t('cum') as string } : null,\n    ];\n\n    const activeOptions = optionList.filter(\n      (option): option is { percent: number; text: string } => option !== null\n    );\n\n    if (activeOptions.length === 1 && activeOptions[0].percent === 100) {\n      // Single option at 100% - show inline without bullets\n      message += `* ${t('finishSlider')} ${activeOptions[0].text.replace(':', '')} \\r\\n`;\n    } else if (activeOptions.length > 0) {\n      // Multiple options or single option not at 100% - show with bullets\n      message += `* ${t('finishSlider')} \\r\\n\\r\\n`;\n\n      activeOptions.forEach((option) => {\n        const optionText =\n          option.percent === 100\n            ? option.text.replace(':', '')\n            : `${option.text} ${option.percent}%`;\n        message += `  - ${optionText} \\r\\n`;\n      });\n    }\n  }\n\n  const customTileCount = getCustomTileCount(settings, customTiles, actionsList);\n  if (customTileCount) {\n    message += `* ${t('customTilesLabel')}: ${customTileCount} \\r\\n`;\n  }\n\n  return message;\n}\n\nfunction exportSettings(formData: Settings): Record<string, any> {\n  const newSettings: Record<string, any> = {};\n  Object.entries(formData).forEach(([settingKey, settingValue]) => {\n    // list of settings to not export and thus not import.\n    const personalSettings = [\n      'displayName',\n      'background',\n      'boardUpdated',\n      'chatSound',\n      'mySound',\n      'otherSound',\n      'othersDialog',\n      'playerDialog',\n      'readRoll',\n      'hideBoardActions',\n      'advancedSettings',\n    ];\n    // don't export personal settings nor room specific settings.\n    if (!personalSettings.includes(settingKey) && !settingKey.startsWith('room')) {\n      newSettings[settingKey] = settingValue;\n    }\n  });\n  return newSettings;\n}\n\ninterface SendMessageOptions {\n  title: string;\n  formData: Settings;\n  user: User;\n  actionsList: ActionsList;\n  tiles: TileExport[];\n  customTiles?: CustomTilePull[];\n  reason?: string;\n}\n\nexport default async function sendGameSettingsMessage({\n  title,\n  formData,\n  user,\n  actionsList,\n  tiles,\n  customTiles = [],\n  reason = '',\n}: SendMessageOptions): Promise<DocumentReference<DocumentData> | void> {\n  const settings = JSON.stringify(exportSettings(formData));\n\n  const gameBoard = await getOrCreateBoard({\n    title,\n    gameBoard: JSON.stringify(tiles),\n    settings,\n  });\n\n  const text = await getSettingsMessage(formData, customTiles, actionsList, reason);\n\n  if (!gameBoard?.id || text === '') {\n    return;\n  }\n\n  return sendMessage({\n    room: formData?.room || 'PUBLIC',\n    user,\n    text,\n    type: 'settings',\n    gameBoardId: gameBoard.id,\n    boardSize: tiles.length,\n    gameMode: formData.gameMode,\n  });\n}\n","import { CustomGroupPull } from '@/types/customGroups';\nimport { CustomTilePull } from '@/types/customTiles';\nimport { Settings } from '@/types/Settings';\nimport { TileExport } from '@/types/gameBoard';\nimport { getCustomGroups } from '@/stores/customGroups';\nimport { getTiles } from '@/stores/customTiles';\nimport i18next from 'i18next';\nimport { shuffleArray } from '@/helpers/arrays';\n\nconst { t } = i18next;\n\ninterface GameTile {\n  title: string;\n  description: string;\n  standalone?: boolean;\n  role?: string;\n}\n\ninterface BoardBuildResult {\n  board: TileExport[];\n  metadata: {\n    totalTiles: number;\n    tilesWithContent: number;\n    selectedGroups: string[];\n    missingGroups: string[];\n    availableTileCount: number;\n  };\n}\n\n/**\n * Shuffle bag implementation to ensure no duplicate actions until all actions are used.\n * This class groups tiles by group name and intensity, providing a fair distribution\n * of actions by ensuring all tiles in a category are used before any duplicates.\n */\nclass TileShuffleBag {\n  /** Maps group-intensity keys to shuffled tile arrays */\n  private bags: Map<string, CustomTilePull[]> = new Map();\n  /** Stores original tile sets for refilling bags */\n  private originalTiles: Map<string, CustomTilePull[]> = new Map();\n\n  /**\n   * Creates a new shuffle bag from the provided tiles.\n   * @param tiles Array of tiles to organize into shuffle bags\n   */\n  constructor(tiles: CustomTilePull[]) {\n    // Group tiles by group name and intensity for bag management\n    const groupedTiles = new Map<string, CustomTilePull[]>();\n\n    tiles.forEach((tile) => {\n      const key = `${tile.group}-${tile.intensity}`;\n      if (!groupedTiles.has(key)) {\n        groupedTiles.set(key, []);\n      }\n      groupedTiles.get(key)!.push(tile);\n    });\n\n    // Initialize bags with shuffled tiles\n    groupedTiles.forEach((tiles, key) => {\n      const shuffledTiles = [...tiles];\n      shuffleArray(shuffledTiles);\n      this.bags.set(key, shuffledTiles);\n      this.originalTiles.set(key, [...tiles]);\n    });\n  }\n\n  /**\n   * Gets a tile from the specified group and intensity bag.\n   * When a bag is empty, it refills and reshuffles automatically.\n   * @param groupName The name of the group to get a tile from\n   * @param intensity The intensity level to get a tile from\n   * @returns A tile or null if no tiles are available\n   */\n  getTile(groupName: string, intensity: number): CustomTilePull | null {\n    const key = `${groupName}-${intensity}`;\n    let bag = this.bags.get(key);\n\n    if (!bag || bag.length === 0) {\n      // Refill and reshuffle the bag when empty\n      const originalTiles = this.originalTiles.get(key);\n      if (!originalTiles || originalTiles.length === 0) {\n        return null;\n      }\n\n      bag = [...originalTiles];\n      shuffleArray(bag);\n      this.bags.set(key, bag);\n    }\n\n    return bag.pop() || null;\n  }\n}\n\n// Filter tiles based on player role\nfunction filterTilesByRole(\n  tiles: CustomTilePull[],\n  role: string,\n  groups: CustomGroupPull[] = []\n): CustomTilePull[] {\n  return tiles.filter((tile) => {\n    const action = tile.action;\n\n    // Find the group for this tile to check its type\n    const group = groups.find((g) => g.name === tile.group);\n\n    // Consumption tiles should be available to all roles\n    if (group?.type === 'consumption') {\n      return true;\n    }\n\n    // Solo tiles should be available to all roles (self-directed activities)\n    if (group?.type === 'solo') {\n      return true;\n    }\n\n    if (role === 'vers') {\n      return (action.includes('{sub}') && action.includes('{dom}')) || action.includes('{player}');\n    }\n    return !action.match(/{(dom|sub)}/) || action.includes(`{${role}}`);\n  });\n}\n\n/** Cache for intensity calculations to avoid repeated computation */\nconst intensityCache = new Map<string, number>();\n\n/**\n * Calculate intensity level based on board position for progression.\n * Results are cached to improve performance for repeated calculations.\n */\nfunction calculateIntensity(gameSize: number, maxIntensity: number, currentTile: number): number {\n  // Create cache key for memoization\n  const cacheKey = `${gameSize}-${maxIntensity}-${currentTile}`;\n  const cached = intensityCache.get(cacheKey);\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  // Simple linear progression from 1 to maxIntensity across the board\n  const divider = gameSize / maxIntensity;\n  const result = Math.floor(currentTile / divider) + 1; // Add 1 since intensities start at 1\n\n  // Cache the result for future use\n  intensityCache.set(cacheKey, result);\n  return result;\n}\n\n// Build individual tile content\nfunction buildTileContent(\n  availableGroups: CustomGroupPull[],\n  shuffleBag: TileShuffleBag,\n  selectedActions: Record<string, any>,\n  currentTile: number,\n  gameSize: number,\n  settings: Settings\n): GameTile {\n  if (!availableGroups.length) {\n    return { title: '', description: '' };\n  }\n\n  // Use the first (and typically only) group provided\n  const currentGroup = availableGroups[0];\n\n  // Check if this group should append or standalone\n  const groupSelection = selectedActions[currentGroup.name];\n  if (!groupSelection || !groupSelection.levels || groupSelection.levels.length === 0) {\n    return { title: '', description: '' };\n  }\n\n  // Handle frequency/append logic\n  if (groupSelection.variation) {\n    const frequency =\n      groupSelection.variation === 'appendSome'\n        ? 0.4\n        : groupSelection.variation === 'appendMost'\n          ? 0.9\n          : 1.0;\n\n    if (groupSelection.variation !== 'standalone' && Math.random() > frequency) {\n      return { title: '', description: '' };\n    }\n  }\n\n  // Calculate intensity based on position for board progression\n  const maxIntensity = Math.max(...currentGroup.intensities.map((i) => i.value));\n  const calculatedIntensity = calculateIntensity(gameSize, maxIntensity, currentTile);\n\n  // Find the target intensity from user's selected levels\n  const userSelectedLevels = groupSelection.levels;\n  let targetIntensity: number;\n\n  // Check if calculated intensity is in user's selection\n  if (userSelectedLevels.includes(calculatedIntensity)) {\n    targetIntensity = calculatedIntensity;\n  } else {\n    // Find closest available level\n    targetIntensity = userSelectedLevels.reduce((prev: number, curr: number) =>\n      Math.abs(curr - calculatedIntensity) < Math.abs(prev - calculatedIntensity) ? curr : prev\n    );\n  }\n\n  // Try to get a tile from the shuffle bag with fallback logic\n  let selectedTile = shuffleBag.getTile(currentGroup.name, targetIntensity);\n\n  if (!selectedTile) {\n    // Try other selected levels if target intensity doesn't have tiles\n    const otherLevels = userSelectedLevels.filter((level: number) => level !== targetIntensity);\n    for (const intensity of otherLevels) {\n      selectedTile = shuffleBag.getTile(currentGroup.name, intensity);\n      if (selectedTile) {\n        break;\n      }\n    }\n\n    if (!selectedTile) {\n      return { title: '', description: '' };\n    }\n  }\n\n  return {\n    title: currentGroup.label,\n    description: selectedTile.action,\n    standalone: groupSelection.variation === 'standalone',\n    role: settings.role || 'sub',\n  };\n}\n\n// Handle append logic for combining tiles\nfunction processAppendTiles(\n  mainTile: GameTile,\n  appendGroups: CustomGroupPull[],\n  shuffleBag: TileShuffleBag,\n  selectedActions: Record<string, any>,\n  currentTile: number,\n  gameSize: number,\n  settings: Settings\n): string {\n  if (mainTile.standalone || !appendGroups.length || !mainTile.description) {\n    return mainTile.description || '';\n  }\n\n  const appendTile = buildTileContent(\n    appendGroups,\n    shuffleBag,\n    selectedActions,\n    currentTile,\n    gameSize,\n    settings\n  );\n\n  if (appendTile.description) {\n    const ensurePunctuation = appendTile.description.trim().replace(/([^.,!?])$/, '$1.');\n    return `${ensurePunctuation} ${mainTile.description}`;\n  }\n\n  return mainTile.description;\n}\n\n// Build the complete game board\nasync function buildBoard(\n  availableGroups: CustomGroupPull[],\n  allTiles: CustomTilePull[],\n  settings: Settings,\n  size: number\n): Promise<GameTile[]> {\n  const selectedActions = settings.selectedActions || {};\n\n  // Create shuffle bag for tile selection\n  const shuffleBag = new TileShuffleBag(allTiles);\n\n  // Separate groups into main and append categories\n  const mainGroups = availableGroups.filter((group) => {\n    const selection = selectedActions[group.name];\n    return (\n      selection &&\n      selection.levels &&\n      selection.levels.length > 0 &&\n      (!selection.variation || selection.variation === 'standalone')\n    );\n  });\n\n  const appendGroups = availableGroups.filter((group) => {\n    const selection = selectedActions[group.name];\n    return (\n      selection &&\n      selection.levels &&\n      selection.levels.length > 0 &&\n      (selection.variation === 'appendSome' || selection.variation === 'appendMost')\n    );\n  });\n\n  // Shuffle main groups to ensure variety in group selection\n  shuffleArray(mainGroups);\n  let groupIndex = 0;\n\n  const board: GameTile[] = [];\n\n  for (let currentTile = 1; currentTile <= size; currentTile++) {\n    // Rotate through groups to ensure variety\n    const selectedMainGroups =\n      mainGroups.length > 0 ? [mainGroups[groupIndex % mainGroups.length]] : [];\n    groupIndex++;\n\n    const mainTile = buildTileContent(\n      selectedMainGroups,\n      shuffleBag,\n      selectedActions,\n      currentTile,\n      size,\n      settings\n    );\n\n    const finalDescription = processAppendTiles(\n      mainTile,\n      appendGroups,\n      shuffleBag,\n      selectedActions,\n      currentTile,\n      size,\n      settings\n    );\n\n    board.push({\n      title: mainTile.title,\n      description: finalDescription.trim(),\n      role: mainTile.role,\n    });\n  }\n\n  return board;\n}\n\n// Add start and finish tiles\nfunction addStartAndFinishTiles(board: GameTile[], settings: Settings): TileExport[] {\n  const startTile: TileExport = {\n    title: t('start'),\n    description: t('start'),\n  };\n\n  const { finishRange = [33, 66] } = settings;\n  const finishDescription =\n    `${t('noCum')} ${finishRange[0]}%` +\n    `\\r\\n${t('ruined')} ${finishRange[1] - finishRange[0]}%` +\n    `\\r\\n${t('cum')} ${100 - finishRange[1]}%`;\n\n  const finishTile: TileExport = {\n    title: t('finish'),\n    description: finishDescription,\n  };\n\n  return [\n    startTile,\n    ...board.map((tile) => ({ title: tile.title, description: tile.description })),\n    finishTile,\n  ];\n}\n\n/**\n * Build a game board directly from Dexie data\n * @param settings Game settings including selectedActions\n * @param locale Current locale for internationalization\n * @param gameMode Current game mode (online, local, solo)\n * @param tileCount Total number of tiles to generate (excluding start/finish)\n * @returns Promise containing the built board and metadata\n */\nexport default async function buildGameBoard(\n  settings: Settings,\n  locale: string,\n  gameMode: string,\n  tileCount = 40\n): Promise<BoardBuildResult> {\n  try {\n    // Fetch all required data from Dexie in parallel\n    const [availableGroups, allTiles] = await Promise.all([\n      getCustomGroups({ locale, gameMode }), // Include both default and custom groups\n      getTiles({ locale, gameMode }),\n    ]);\n\n    // Get selected action group names\n    const selectedActions = settings.selectedActions || {};\n    const selectedGroupNames = Object.keys(selectedActions).filter(\n      (groupName) =>\n        selectedActions[groupName]?.levels && selectedActions[groupName].levels.length > 0\n    );\n\n    // Filter groups to only those selected by user\n    const selectedGroups = availableGroups.filter((group) =>\n      selectedGroupNames.includes(group.name)\n    );\n\n    // Find missing groups (selected but not available)\n    const availableGroupNames = availableGroups.map((g) => g.name);\n    const missingGroups = selectedGroupNames.filter((name) => !availableGroupNames.includes(name));\n\n    // Filter tiles by role if specified\n    const role = settings.role || 'sub';\n    const filteredTiles = filterTilesByRole(allTiles, role, availableGroups);\n\n    // Only get tiles for selected groups\n    const relevantTiles = filteredTiles.filter((tile) => selectedGroupNames.includes(tile.group));\n\n    // If no selected groups or tiles available, return empty board\n    if (!selectedGroups.length || !relevantTiles.length) {\n      return {\n        board: addStartAndFinishTiles([], settings),\n        metadata: {\n          totalTiles: tileCount + 2,\n          tilesWithContent: 2, // Start and finish tiles\n          selectedGroups: selectedGroupNames,\n          missingGroups,\n          availableTileCount: relevantTiles.length,\n        },\n      };\n    }\n\n    // Build the board\n    const gameBoard = await buildBoard(selectedGroups, relevantTiles, settings, tileCount);\n\n    // Calculate metadata\n    const tilesWithContent = gameBoard.filter((tile) => tile.description.trim().length > 0).length;\n\n    const finalBoard = addStartAndFinishTiles(gameBoard, settings);\n\n    return {\n      board: finalBoard,\n      metadata: {\n        totalTiles: finalBoard.length,\n        tilesWithContent: tilesWithContent + 2, // +2 for start/finish\n        selectedGroups: selectedGroupNames,\n        missingGroups,\n        availableTileCount: relevantTiles.length,\n      },\n    };\n  } catch (error) {\n    console.error('Error building game board:', error);\n\n    // Return empty board on error\n    return {\n      board: addStartAndFinishTiles([], settings),\n      metadata: {\n        totalTiles: 2,\n        tilesWithContent: 2, // Start and finish tiles\n        selectedGroups: [],\n        missingGroups: [],\n        availableTileCount: 0,\n      },\n    };\n  }\n}\n","import { useLiveQuery } from 'dexie-react-hooks';\nimport { isPublicRoom } from '@/helpers/strings';\nimport { useSettings } from '@/stores/settingsStore';\nimport { useTranslation } from 'react-i18next';\nimport buildGameBoard from '@/services/buildGame';\nimport { getActiveBoard, upsertBoard } from '@/stores/gameBoard';\nimport { isOnlineMode } from '@/helpers/strings';\nimport { useCallback } from 'react';\nimport { Settings } from '@/types/Settings';\nimport { DBGameBoard, GameBoardResult } from '@/types/gameBoard';\n\n/**\n * Builds a game board based on the settings provided.\n * @returns A function that takes in a form data object and returns an object.\n */\nexport default function useGameBoard(): (data: Settings) => Promise<GameBoardResult> {\n  const gameBoard = useLiveQuery<DBGameBoard | undefined>(getActiveBoard);\n  const [settings, updateSettings] = useSettings();\n  const { i18n } = useTranslation();\n\n  const updateGameBoard = useCallback(\n    async (data: Settings): Promise<GameBoardResult> => {\n      // Ensure selectedActions is properly handled in formData\n      const formData =\n        data?.roomUpdate || data?.boardUpdated\n          ? data\n          : {\n              ...settings,\n              ...data,\n              selectedActions: {\n                ...settings.selectedActions,\n                ...data.selectedActions,\n              },\n            };\n      let { gameMode, boardUpdated: settingsBoardUpdated } = formData;\n      const { roomTileCount = 40, finishRange, room } = formData;\n      const isPublic = isPublicRoom(room || '');\n\n      if (!data || !finishRange) {\n        // still loading data.\n        return { gameMode };\n      }\n\n      // If we are in a public room,\n      // then gameMode should update to online, and we need to re-import actions.\n      if (isPublic && !isOnlineMode(gameMode || '')) {\n        gameMode = 'online';\n        // this is async, so we need the boardUpdated & updatedDataFolder as separate entities.\n        settingsBoardUpdated = true;\n      }\n\n      const finalGameMode = gameMode || 'online';\n      const locale = i18n.resolvedLanguage || 'en';\n      const tileCount = isPublic ? 40 : roomTileCount || 40;\n\n      // Use the new streamlined buildGameBoard function\n      const boardResult = await buildGameBoard(formData, locale, finalGameMode, tileCount);\n\n      // Log useful debug information\n      if (boardResult.metadata.missingGroups.length > 0) {\n        console.warn('Missing groups for board building:', boardResult.metadata.missingGroups);\n      }\n\n      if (boardResult.metadata.tilesWithContent < tileCount / 2) {\n        console.warn('Low tile content ratio:', {\n          tilesWithContent: boardResult.metadata.tilesWithContent,\n          totalTiles: boardResult.metadata.totalTiles,\n          availableTileCount: boardResult.metadata.availableTileCount,\n        });\n      }\n\n      // if our board updated, then push those changes out.\n      if (\n        data?.boardUpdated ||\n        settingsBoardUpdated ||\n        (gameBoard?.tiles?.length ?? 0) !== boardResult.board.length\n      ) {\n        await updateSettings(formData);\n        await upsertBoard({ title: gameBoard?.title || '', tiles: boardResult.board });\n      }\n\n      return {\n        settingsBoardUpdated,\n        gameMode,\n        newBoard: boardResult.board,\n        metadata: boardResult.metadata,\n      };\n    },\n    [gameBoard, i18n.resolvedLanguage, settings, updateSettings]\n  );\n\n  return useCallback((data: Settings) => updateGameBoard(data), [updateGameBoard]);\n}\n","import { Params, useNavigate, useParams } from 'react-router-dom';\n\nexport default function useRoomNavigate(): (formRoom?: string) => void {\n  const { id: room } = useParams<Params>();\n  const navigate = useNavigate();\n\n  return (formRoom?: string): void => {\n    const shouldNavigate = room !== undefined && room?.toUpperCase() !== formRoom?.toUpperCase();\n    const noLeadingSlash = formRoom?.replace(/^\\/+/, '') || 'PUBLIC';\n\n    if (shouldNavigate) {\n      navigate(`/${noLeadingSlash}`);\n    }\n  };\n}\n","import type { LocalPlayer, LocalSessionSettings } from '@/types';\nimport { Params, useParams } from 'react-router-dom';\nimport { getActiveBoard, upsertBoard } from '@/stores/gameBoard';\nimport { handleUser, sendRoomSettingsMessage } from '@/views/GameSettings/submitForm';\n\nimport { GameBoardResult } from '@/types/gameBoard';\nimport { Message } from '@/types/Message';\nimport { Settings } from '@/types/Settings';\nimport { getActiveTiles } from '@/stores/customTiles';\nimport { getValidationConstants } from '@/services/validationService';\nimport { isPublicRoom } from '@/helpers/strings';\nimport { isValidURL } from '@/helpers/urls';\nimport sendGameSettingsMessage from '@/services/gameSettingsMessage';\nimport useAuth from '@/context/hooks/useAuth';\nimport { useCallback } from 'react';\nimport useGameBoard from './useGameBoard';\nimport { useLiveQuery } from 'dexie-react-hooks';\nimport { useLocalPlayers } from './useLocalPlayers';\nimport useMessages from '@/context/hooks/useMessages';\nimport useRoomNavigate from './useRoomNavigate';\nimport { useSettings } from '@/stores/settingsStore';\nimport { useTranslation } from 'react-i18next';\n\ninterface RoomChangeResult {\n  roomChanged: boolean;\n  isPrivateRoom: boolean;\n  privateBoardSizeChanged: boolean;\n}\nfunction updateRoomBackground(formData: Settings): void {\n  const url = formData.roomBackgroundURL?.trim();\n  if (url !== formData.roomBackgroundURL) {\n    formData.roomBackgroundURL = url || '';\n  }\n  if (formData.roomBackgroundURL && !isValidURL(formData.roomBackgroundURL)) {\n    formData.roomBackgroundURL = ''; // Clear invalid URL\n  }\n}\n\n/**\n * Clean form data by removing any action/consumption entries that have been deselected\n * This ensures that the Zustand store doesn't retain stale action selections\n */\nfunction cleanFormData(formData: Settings): Settings {\n  const cleanedData = { ...formData };\n  const cleanedSelectedActions: Record<string, any> = {};\n\n  // Clean the selectedActions object\n  if (formData.selectedActions) {\n    Object.entries(formData.selectedActions).forEach(([key, entry]) => {\n      if (entry && entry.levels && entry.levels.length > 0) {\n        cleanedSelectedActions[key] = entry;\n      }\n    });\n  }\n\n  // Remove any old root-level action keys (for migration cleanup)\n  const validationConstants = getValidationConstants();\n  Object.keys(cleanedData).forEach((key) => {\n    const entry = cleanedData[key] as any;\n    if (\n      entry &&\n      typeof entry === 'object' &&\n      entry.type &&\n      validationConstants.VALID_GROUP_TYPES.includes(entry.type)\n    ) {\n      delete cleanedData[key];\n    }\n  });\n\n  cleanedData.selectedActions = cleanedSelectedActions;\n\n  return cleanedData;\n}\n\nexport default function useSubmitGameSettings(): (\n  formData: Settings,\n  actionsList: any\n) => Promise<void> {\n  const { user, updateUser } = useAuth();\n  const { id: room } = useParams<Params>();\n  const { t } = useTranslation();\n  const updateGameBoardTiles = useGameBoard();\n  const [settings, updateSettings] = useSettings();\n  const customTiles = useLiveQuery(() => getActiveTiles(settings?.gameMode));\n  const gameBoard = useLiveQuery(getActiveBoard);\n  const navigate = useRoomNavigate();\n  const { messages } = useMessages();\n  const { createLocalSession } = useLocalPlayers();\n\n  const handleRoomChange = useCallback(\n    (formData: Settings): RoomChangeResult => {\n      // Handle the case where room might be undefined (original logic with safety check)\n      const currentRoomUpper = (room || '')?.toUpperCase();\n      const formDataRoomUpper = (formData.room || '').toUpperCase();\n      const roomChanged = currentRoomUpper !== formDataRoomUpper;\n      const isPrivateRoom = Boolean(formData.room && !isPublicRoom(formData.room));\n      const privateBoardSizeChanged =\n        isPrivateRoom && formData.roomTileCount !== settings?.roomTileCount;\n\n      return { roomChanged, isPrivateRoom, privateBoardSizeChanged };\n    },\n    [room, settings?.roomTileCount]\n  );\n\n  const submitSettings = useCallback(\n    async (formData: Settings, actionsList: any): Promise<void> => {\n      const { displayName } = formData;\n      const updatedUser = await handleUser(user, displayName, updateUser);\n\n      updateRoomBackground(formData);\n\n      const {\n        settingsBoardUpdated,\n        gameMode,\n        newBoard = [],\n      } = (await updateGameBoardTiles(formData)) as GameBoardResult;\n      const { roomChanged, isPrivateRoom, privateBoardSizeChanged } = handleRoomChange(formData);\n\n      if (!updatedUser) return;\n\n      if (\n        isPrivateRoom &&\n        (formData.roomUpdated || !messages.find((m: Message) => m.type === 'room'))\n      ) {\n        await sendRoomSettingsMessage(formData, updatedUser);\n      }\n\n      if (gameBoard?.tiles !== newBoard) {\n        await upsertBoard({\n          title: t('settingsGenerated'),\n          tiles: newBoard,\n          isActive: 1,\n          gameMode,\n        });\n      }\n\n      const shouldSendGameSettings =\n        (settingsBoardUpdated || roomChanged || privateBoardSizeChanged) &&\n        !messages.some(\n          (m: Message) =>\n            m.type === 'settings' &&\n            m.uid === updatedUser.uid &&\n            Date.now() - (m.timestamp?.toMillis() || 0) < 5000\n        );\n\n      if (shouldSendGameSettings) {\n        await sendGameSettingsMessage({\n          formData,\n          user: updatedUser,\n          customTiles,\n          actionsList,\n          title: 'Settings Generated Board',\n          tiles: newBoard,\n        });\n      }\n\n      // Handle local player session initialization if data exists\n      const typedFormData = formData as any; // Use any type to access wizard-specific properties\n      if (\n        typedFormData.hasLocalPlayers &&\n        typedFormData.localPlayersData &&\n        typedFormData.localPlayerSessionSettings\n      ) {\n        try {\n          await createLocalSession(\n            formData.room,\n            typedFormData.localPlayersData as LocalPlayer[],\n            typedFormData.localPlayerSessionSettings as LocalSessionSettings\n          );\n        } catch (error) {\n          console.error('Error creating local session:', error);\n          // Don't throw here to prevent blocking the settings save\n        }\n      }\n\n      // Clean the formData to remove any deselected actions/consumptions before storing\n      const cleanedFormData = cleanFormData(formData);\n\n      updateSettings({\n        ...cleanedFormData,\n        boardUpdated: false,\n        roomUpdated: false,\n        gameMode,\n      });\n\n      navigate(formData.room);\n    },\n    [\n      user,\n      updateUser,\n      updateGameBoardTiles,\n      handleRoomChange,\n      messages,\n      gameBoard,\n      t,\n      customTiles,\n      updateSettings,\n      navigate,\n      createLocalSession,\n    ]\n  );\n\n  return useCallback(\n    (formData: Settings, actionsList: any) => submitSettings(formData, actionsList),\n    [submitSettings]\n  );\n}\n","import { useEffect, useState, useCallback, useMemo } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { getAllAvailableGroups } from '@/stores/customGroups';\nimport { GroupedActions } from '@/types/customTiles';\nimport { UNIFIED_ACTION_CACHE_TTL } from '@/constants/actionConstants';\nimport { useMigration } from '@/context/migration';\n\ninterface UnifiedActionListResult {\n  actionsList: GroupedActions;\n  isLoading: boolean;\n}\n\n// Simple cache to prevent duplicate API calls\nconst actionsCache = new Map<string, { data: GroupedActions; timestamp: number }>();\nconst CACHE_TTL = UNIFIED_ACTION_CACHE_TTL;\n\n// Debug function to inspect cache\n(window as any).debugActionsCache = () => {};\n\n// Debug function to clear cache\n(window as any).clearActionsCache = () => {\n  actionsCache.clear();\n};\n\n/**\n * Hook that combines default actions from locale files with custom groups from Dexie\n * into a unified structure that can be used by the existing IncrementalSelect component\n *\n * @param gameMode - The game mode to filter groups by (e.g., 'online', 'local')\n * @returns Object containing the unified actions list and loading state\n *\n * Features:\n * - Caches results for 30 seconds to improve performance\n * - Automatically handles locale changes\n * - Filters groups by game mode\n * - Converts custom groups to the expected format for UI components\n */\nexport default function useUnifiedActionList(gameMode?: string): UnifiedActionListResult {\n  const { i18n, t } = useTranslation();\n  const { currentLanguageMigrated, isHealthy, forceRecovery } = useMigration();\n  const [actionsList, setActionsList] = useState<GroupedActions>({});\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [recoveryAttempted, setRecoveryAttempted] = useState<boolean>(false);\n\n  // Track language changes and migration status for debugging\n  useEffect(() => {\n    const handleLanguageChange = () => {\n      // Clear cache for all languages since the user changed language\n      if (gameMode) {\n        const oldCacheKeys = Array.from(actionsCache.keys()).filter((key) =>\n          key.endsWith(`-${gameMode}`)\n        );\n        oldCacheKeys.forEach((key) => {\n          actionsCache.delete(key);\n        });\n      }\n    };\n\n    i18n.on('languageChanged', handleLanguageChange);\n\n    return () => {\n      i18n.off('languageChanged', handleLanguageChange);\n    };\n  }, [i18n, gameMode]);\n\n  // Memoize the cache key to prevent unnecessary recalculations\n  const cacheKey = useMemo(() => {\n    if (!gameMode || !i18n.resolvedLanguage) return '';\n    return `${i18n.resolvedLanguage}-${gameMode}`;\n  }, [i18n.resolvedLanguage, gameMode]);\n\n  // Clear cache when migration status changes from false to true\n  useEffect(() => {\n    if (currentLanguageMigrated && cacheKey) {\n      // Migration just completed - clear cache to force fresh load\n      const cached = actionsCache.get(cacheKey);\n      if (cached) {\n        actionsCache.delete(cacheKey);\n      }\n    }\n  }, [currentLanguageMigrated, cacheKey]);\n\n  // Check cache immediately on render to prevent unnecessary loading states\n  // Using useEffect instead of useMemo to avoid side effects in useMemo\n  useEffect(() => {\n    if (cacheKey) {\n      const cached = actionsCache.get(cacheKey);\n      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n        setActionsList(cached.data);\n        setIsLoading(false);\n      }\n    }\n  }, [cacheKey]);\n\n  const loadUnifiedActions = useCallback(async (): Promise<void> => {\n    if (!gameMode || !cacheKey) {\n      console.warn(' useUnifiedActionList: Missing required params', { gameMode, cacheKey });\n      return;\n    }\n\n    // Wait for migration to complete before loading actions\n    if (!currentLanguageMigrated) {\n      return;\n    }\n\n    // If migration is complete but health check failed, attempt recovery once\n    if (currentLanguageMigrated && !isHealthy && !recoveryAttempted) {\n      setRecoveryAttempted(true);\n      try {\n        await forceRecovery();\n        // Recovery will trigger a re-render, so return and let the next call handle loading\n        return;\n      } catch {\n        // Continue with loading attempt even if recovery fails\n      }\n    }\n\n    // Check cache first\n    const cached = actionsCache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n      setActionsList(cached.data);\n      setIsLoading(false);\n      return;\n    }\n\n    setIsLoading(true);\n\n    try {\n      // Load all available groups from Dexie (includes both default and custom groups)\n      const allGroups = await getAllAvailableGroups(i18n.resolvedLanguage, gameMode);\n\n      // Convert all groups to unified actions structure\n      const unifiedActions: GroupedActions = {};\n\n      for (const group of allGroups) {\n        // Convert group to the same structure as expected by components\n        const actions: Record<string, string[]> = {\n          [t('none')]: [], // Always include None option for consistency\n        };\n\n        // Add intensity levels as action keys with empty arrays\n        // The IncrementalSelect component uses these keys as menu items\n        const intensities: Record<number, string> = {};\n        if (group.intensities && Array.isArray(group.intensities)) {\n          group.intensities\n            .sort((a, b) => a.value - b.value)\n            .forEach((intensity) => {\n              actions[intensity.label] = []; // Empty array since custom groups don't have predefined actions\n              intensities[intensity.value] = intensity.label; // Map level to name\n            });\n        }\n\n        const finalType = group.type || 'action';\n\n        unifiedActions[group.name] = {\n          label: group.label || group.name,\n          type: finalType, // Use the preserved type from migration\n          actions,\n          intensities, // Add the intensities mapping\n        };\n      }\n\n      // Cache the result\n      actionsCache.set(cacheKey, {\n        data: unifiedActions,\n        timestamp: Date.now(),\n      });\n\n      setActionsList(unifiedActions);\n    } catch (error) {\n      console.error(' useUnifiedActionList: Error loading unified actions', {\n        error,\n        locale: i18n.resolvedLanguage,\n        gameMode,\n        cacheKey,\n      });\n      setActionsList({});\n    } finally {\n      setIsLoading(false);\n    }\n  }, [\n    gameMode,\n    i18n.resolvedLanguage,\n    cacheKey,\n    t,\n    currentLanguageMigrated,\n    isHealthy,\n    recoveryAttempted,\n    forceRecovery,\n  ]);\n\n  useEffect(() => {\n    if (cacheKey && currentLanguageMigrated) {\n      loadUnifiedActions();\n    }\n  }, [loadUnifiedActions, cacheKey, currentLanguageMigrated, isHealthy]);\n\n  return { actionsList, isLoading };\n}\n"],"names":["shuffleArray","array","i","j","arraysEqual","arr1","arr2","element","index","getRoomSettingsMessage","settings","i18next","message","key","val","getSiteName","exportRoomSettings","formData","newSettings","settingKey","settingValue","handleUser","user","displayName","updateUser","updatedUser","sendRoomSettingsMessage","roomSettings","sendMessage","MAX_GROUP_NAME_LENGTH","MAX_GROUP_LABEL_LENGTH","MAX_INTENSITY_LABEL_LENGTH","MIN_INTENSITY_VALUE","MAX_INTENSITY_VALUE","MIN_INTENSITIES_COUNT","MAX_INTENSITIES_COUNT","RESERVED_GROUP_NAMES","VALID_GROUP_TYPES","validateGroupName","name","_locale","_gameMode","_excludeId","errors","warnings","trimmedName","validateGroupLabel","label","t","validateGroupIntensities","intensities","usedValues","usedLabels","intensity","trimmedLabel","sortedValues","a","b","expectedValue","value","validateCustomGroup","group","excludeId","nameValidation","labelValidation","intensitiesValidation","isGroupNameUnique","error","logger","validateCustomTileWithGroups","tile","locale","gameMode","getCustomGroupByName","validIntensityValues","getValidationConstants","isValidRole","obj","role","getCustomTileCount","customTiles","actionsList","actionEntries","settingsDataFolder","acc","levels","actionKeys","level","entry","intensityArray","getSettingsMessage","reason","variation","actualRole","modifier","isOnlineMode","intensityNames","levelName","customGroup","groupData","groupLabel","finishRange","noCumPercent","ruinedPercent","normalPercent","activeOptions","option","optionText","customTileCount","exportSettings","sendGameSettingsMessage","title","tiles","gameBoard","getOrCreateBoard","text","TileShuffleBag","__publicField","groupedTiles","shuffledTiles","groupName","bag","originalTiles","filterTilesByRole","groups","action","g","intensityCache","calculateIntensity","gameSize","maxIntensity","currentTile","cacheKey","cached","divider","result","buildTileContent","availableGroups","shuffleBag","selectedActions","currentGroup","groupSelection","frequency","calculatedIntensity","userSelectedLevels","targetIntensity","prev","curr","selectedTile","otherLevels","processAppendTiles","mainTile","appendGroups","appendTile","buildBoard","allTiles","size","mainGroups","selection","groupIndex","board","selectedMainGroups","finalDescription","addStartAndFinishTiles","startTile","finishDescription","finishTile","buildGameBoard","tileCount","getCustomGroups","getTiles","selectedGroupNames","_a","selectedGroups","availableGroupNames","missingGroups","relevantTiles","tilesWithContent","finalBoard","useGameBoard","useLiveQuery","getActiveBoard","updateSettings","useSettings","i18n","useTranslation","updateGameBoard","useCallback","data","_b","settingsBoardUpdated","roomTileCount","room","isPublic","isPublicRoom","finalGameMode","boardResult","upsertBoard","useRoomNavigate","useParams","navigate","useNavigate","formRoom","shouldNavigate","noLeadingSlash","updateRoomBackground","url","isValidURL","cleanFormData","cleanedData","cleanedSelectedActions","validationConstants","useSubmitGameSettings","useAuth","updateGameBoardTiles","getActiveTiles","messages","useMessages","createLocalSession","useLocalPlayers","handleRoomChange","currentRoomUpper","formDataRoomUpper","roomChanged","isPrivateRoom","privateBoardSizeChanged","submitSettings","newBoard","m","typedFormData","cleanedFormData","actionsCache","CACHE_TTL","UNIFIED_ACTION_CACHE_TTL","useUnifiedActionList","currentLanguageMigrated","isHealthy","forceRecovery","useMigration","setActionsList","useState","isLoading","setIsLoading","recoveryAttempted","setRecoveryAttempted","useEffect","handleLanguageChange","useMemo","loadUnifiedActions","e","allGroups","getAllAvailableGroups","unifiedActions","actions","finalType"],"mappings":"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"}