{"version":3,"file":"chunk-U-BuBlCh.js","sources":["../../src/helpers/arrays.ts","../../src/views/GameSettings/submitForm.ts","../../src/services/validationService.ts","../../src/services/gameSettingsMessage.ts","../../src/services/buildGame.ts","../../src/hooks/useGameBoard.ts","../../src/hooks/useRoomNavigate.ts","../../src/hooks/useSubmitGameSettings.ts","../../src/hooks/useUnifiedActionList.ts"],"sourcesContent":["export function shuffleArray<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\nexport function cycleArray<T>(array: T[]): void {\n  if (array.length > 1) array.push(array.shift() as T);\n}\n\nexport function arraysEqual<T>(arr1: T[], arr2: T[]): boolean {\n  if (arr1?.length !== arr2?.length) return false;\n  return arr1.every((element, index) => element === arr2[index]);\n}\n","import { Settings } from '@/types/Settings';\nimport { User } from '@/types';\nimport { getSiteName } from '@/helpers/urls';\nimport i18next from 'i18next';\nimport { sendMessage } from '@/services/firebase';\n\nfunction getRoomSettingsMessage(settings: Partial<Settings>): string {\n  const { t } = i18next;\n  let message = `### ${t('roomSettings')}\\r\\n`;\n\n  Object.entries(settings).forEach(([key, val]) => {\n    if (key === 'room') return; // we handle the room separately.\n    if (key === 'roomBackgroundURL' && val !== '') {\n      message += `* ${t(key)}: [${getSiteName(val)}:link:](${val})\\r\\n`;\n      return;\n    }\n    if (key === 'roomRealtime') {\n      message += `* ${t('playerList')}: ${val ? t('delayed') : t('realtime')}\\r\\n`;\n      return;\n    }\n    if (val !== '') {\n      message += `* ${t(key)}: ${val}\\r\\n`;\n    }\n  });\n  return message;\n}\n\nfunction exportRoomSettings(formData: Settings): Partial<Settings> {\n  const newSettings: Partial<Settings> = {};\n  // Include only message-relevant room fields; omit control flags and deprecated roomBackground\n  Object.entries(formData).forEach(([settingKey, settingValue]) => {\n    if (\n      settingKey.startsWith('room') &&\n      !['roomUpdated', 'roomBackground', 'roomBackgroundURL'].includes(settingKey)\n    ) {\n      newSettings[settingKey] = settingValue;\n    }\n  });\n\n  // Only include background URL if it exists and is valid\n  if (formData.roomBackgroundURL && formData.roomBackgroundURL.trim() !== '') {\n    newSettings.roomBackgroundURL = formData.roomBackgroundURL;\n  }\n\n  return newSettings;\n}\n\nexport async function handleUser(\n  user: User | null,\n  displayName: string | undefined,\n  updateUser: (displayName: string) => Promise<User | null>\n): Promise<User | null> {\n  let updatedUser = user;\n  if (displayName !== undefined && displayName.length > 0) {\n    updatedUser = await updateUser(displayName);\n  }\n  return updatedUser;\n}\n\nexport function sendRoomSettingsMessage(formData: Settings, updatedUser: User): Promise<any> {\n  const roomSettings = exportRoomSettings(formData);\n  return sendMessage({\n    room: formData.room,\n    user: updatedUser,\n    text: getRoomSettingsMessage(roomSettings),\n    type: 'room',\n    settings: JSON.stringify(roomSettings),\n  });\n}\n","import { ValidationResult, CustomGroupBase, CustomGroupIntensity } from '@/types/customGroups';\nimport { CustomTile } from '@/types/customTiles';\nimport { isGroupNameUnique, getCustomGroupByName } from '@/stores/customGroups';\nimport { t } from 'i18next';\nimport { logger } from '@/utils/logger';\n\n/**\n * Validation service for custom groups and tiles\n */\n\n// Constants for validation rules\nconst MAX_GROUP_NAME_LENGTH = 50;\nconst MAX_GROUP_LABEL_LENGTH = 100;\nconst MAX_INTENSITY_LABEL_LENGTH = 50;\nconst MIN_INTENSITY_VALUE = 1;\nconst MAX_INTENSITY_VALUE = 10;\nconst MIN_INTENSITIES_COUNT = 1;\nconst MAX_INTENSITIES_COUNT = 10;\n\n// Reserved group names that cannot be used for custom groups\n// Only includes names that would cause technical issues or UX confusion\nconst RESERVED_GROUP_NAMES = [\n  'none', // Used in UI for \"select none\" operations\n  'all', // Used in UI for \"select all\" operations\n  'default', // Aligns with isDefault system property\n  'undefined', // JavaScript reserved word\n  'null', // JavaScript reserved word\n];\n\n// Valid group types for custom groups\nconst VALID_GROUP_TYPES = ['solo', 'foreplay', 'sex', 'consumption'] as const;\n\n// Export type for group types\nexport type GroupType = (typeof VALID_GROUP_TYPES)[number];\n\n/**\n * Validate a custom group name\n */\nexport const validateGroupName = (\n  name: string,\n  _locale = 'en',\n  _gameMode = 'online',\n  _excludeId?: string\n): ValidationResult => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check if name is provided\n  if (!name || name.trim().length === 0) {\n    errors.push('Group name is required');\n    return { isValid: false, errors, warnings };\n  }\n\n  const trimmedName = name.trim();\n\n  // Check name length\n  if (trimmedName.length > MAX_GROUP_NAME_LENGTH) {\n    errors.push(`Group name must be ${MAX_GROUP_NAME_LENGTH} characters or less`);\n  }\n\n  // Check for reserved names\n  if (RESERVED_GROUP_NAMES.includes(trimmedName.toLowerCase())) {\n    errors.push(`\"${trimmedName}\" is a reserved name and cannot be used`);\n  }\n\n  // Check for valid characters (alphanumeric, hyphens, underscores)\n  const validNamePattern = /^[a-zA-Z0-9_-]+$/;\n  if (!validNamePattern.test(trimmedName)) {\n    errors.push('Group name can only contain letters, numbers, hyphens, and underscores');\n  }\n\n  // Check if name starts with a letter\n  if (!/^[a-zA-Z]/.test(trimmedName)) {\n    errors.push('Group name must start with a letter');\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Validate a custom group label\n */\nexport const validateGroupLabel = (label: string): ValidationResult => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check if label is provided\n  if (!label || label.trim().length === 0) {\n    errors.push(t('groupLabelRequired'));\n    return { isValid: false, errors, warnings };\n  }\n\n  const trimmedLabel = label.trim();\n\n  // Check label length\n  if (trimmedLabel.length > MAX_GROUP_LABEL_LENGTH) {\n    errors.push(`Group label must be ${MAX_GROUP_LABEL_LENGTH} characters or less`);\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Validate custom group intensities\n */\nexport const validateGroupIntensities = (intensities: CustomGroupIntensity[]): ValidationResult => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check if intensities are provided\n  if (!intensities || intensities.length === 0) {\n    errors.push('At least one intensity level is required');\n    return { isValid: false, errors, warnings };\n  }\n\n  // Check intensities count\n  if (intensities.length < MIN_INTENSITIES_COUNT) {\n    errors.push(`At least ${MIN_INTENSITIES_COUNT} intensity level is required`);\n  }\n\n  if (intensities.length > MAX_INTENSITIES_COUNT) {\n    errors.push(`Maximum ${MAX_INTENSITIES_COUNT} intensity levels allowed`);\n  }\n\n  // Track unique values and labels\n  const usedValues = new Set<number>();\n  const usedLabels = new Set<string>();\n\n  for (let i = 0; i < intensities.length; i++) {\n    const intensity = intensities[i];\n\n    // Validate intensity ID\n    if (!intensity.id || intensity.id.trim().length === 0) {\n      errors.push(`Intensity level ${i + 1} is missing an ID`);\n    }\n\n    // Validate intensity label\n    if (!intensity.label || intensity.label.trim().length === 0) {\n      errors.push(`Intensity level ${i + 1} is missing a label`);\n    } else {\n      const trimmedLabel = intensity.label.trim();\n\n      if (trimmedLabel.length > MAX_INTENSITY_LABEL_LENGTH) {\n        errors.push(\n          `Intensity level ${i + 1} label must be ${MAX_INTENSITY_LABEL_LENGTH} characters or less`\n        );\n      }\n\n      // Check for duplicate labels\n      if (usedLabels.has(trimmedLabel.toLowerCase())) {\n        errors.push(`Intensity label \"${trimmedLabel}\" is used multiple times`);\n      } else {\n        usedLabels.add(trimmedLabel.toLowerCase());\n      }\n    }\n\n    // Validate intensity value\n    if (typeof intensity.value !== 'number' || !Number.isInteger(intensity.value)) {\n      errors.push(`Intensity level ${i + 1} must have a valid integer value`);\n    } else {\n      if (intensity.value < MIN_INTENSITY_VALUE || intensity.value > MAX_INTENSITY_VALUE) {\n        errors.push(\n          `Intensity level ${i + 1} value must be between ${MIN_INTENSITY_VALUE} and ${MAX_INTENSITY_VALUE}`\n        );\n      }\n\n      // Check for duplicate values\n      if (usedValues.has(intensity.value)) {\n        errors.push(`Intensity value ${intensity.value} is used multiple times`);\n      } else {\n        usedValues.add(intensity.value);\n      }\n    }\n  }\n\n  // Warn if intensity values are not sequential\n  const sortedValues = Array.from(usedValues).sort((a, b) => a - b);\n  let expectedValue = sortedValues[0];\n  for (const value of sortedValues) {\n    if (value !== expectedValue) {\n      warnings.push(\n        'Intensity values are not sequential. Consider using values like 1, 2, 3, 4 for better user experience'\n      );\n      break;\n    }\n    expectedValue++;\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Validate a complete custom group\n */\nexport const validateCustomGroup = async (\n  group: CustomGroupBase,\n  excludeId?: string\n): Promise<ValidationResult> => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Validate name\n  const nameValidation = validateGroupName(\n    group.name,\n    group.locale || 'en',\n    group.gameMode || 'online',\n    excludeId\n  );\n  errors.push(...nameValidation.errors);\n  warnings.push(...(nameValidation.warnings || []));\n\n  // Validate label\n  const labelValidation = validateGroupLabel(group.label);\n  errors.push(...labelValidation.errors);\n  warnings.push(...(labelValidation.warnings || []));\n\n  // Validate intensities\n  const intensitiesValidation = validateGroupIntensities(group.intensities);\n  errors.push(...intensitiesValidation.errors);\n  warnings.push(...(intensitiesValidation.warnings || []));\n\n  // Check for unique name (async validation)\n  if (nameValidation.isValid && group.name) {\n    try {\n      const isUnique = await isGroupNameUnique(\n        group.name,\n        group.locale || 'en',\n        group.gameMode || 'online',\n        excludeId\n      );\n\n      if (!isUnique) {\n        errors.push(\n          `A group with the name \"${group.name}\" already exists for this locale and game mode`\n        );\n      }\n    } catch (error) {\n      warnings.push('Could not verify group name uniqueness');\n      logger.warn(\n        'Failed to check group name uniqueness:',\n        false,\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n    }\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Validate a custom tile against available groups\n */\nexport const validateCustomTileWithGroups = async (\n  tile: CustomTile,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<ValidationResult> => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check if group exists\n  if (!tile.group || tile.group.trim().length === 0) {\n    errors.push('Tile must belong to a group');\n    return { isValid: false, errors, warnings };\n  }\n\n  try {\n    const group = await getCustomGroupByName(tile.group, locale, gameMode);\n\n    if (!group) {\n      errors.push(`Group \"${tile.group}\" does not exist for ${locale}/${gameMode}`);\n      return { isValid: false, errors, warnings };\n    }\n\n    // Check if intensity value is valid for this group\n    const validIntensityValues = group.intensities.map((i) => i.value);\n    if (!validIntensityValues.includes(tile.intensity)) {\n      errors.push(\n        `Intensity ${tile.intensity} is not valid for group \"${tile.group}\". Valid intensities: ${validIntensityValues.join(', ')}`\n      );\n    }\n\n    // Check if action is provided\n    if (!tile.action || tile.action.trim().length === 0) {\n      errors.push('Tile action is required');\n    }\n  } catch (error) {\n    errors.push(`Error validating tile: ${error}`);\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Validate intensity value for a specific group\n */\nexport const validateIntensityForGroup = async (\n  groupName: string,\n  intensity: number,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<ValidationResult> => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  try {\n    const group = await getCustomGroupByName(groupName, locale, gameMode);\n\n    if (!group) {\n      errors.push(`Group \"${groupName}\" does not exist`);\n      return { isValid: false, errors, warnings };\n    }\n\n    const validIntensityValues = group.intensities.map((i) => i.value);\n    if (!validIntensityValues.includes(intensity)) {\n      errors.push(\n        `Intensity ${intensity} is not valid for group \"${groupName}\". Valid intensities: ${validIntensityValues.join(', ')}`\n      );\n    }\n  } catch (error) {\n    errors.push(`Error validating intensity: ${error}`);\n  }\n\n  return { isValid: errors.length === 0, errors, warnings };\n};\n\n/**\n * Get validation constants for use in components\n */\nexport const getValidationConstants = () => ({\n  MAX_GROUP_NAME_LENGTH,\n  MAX_GROUP_LABEL_LENGTH,\n  MAX_INTENSITY_LABEL_LENGTH,\n  MIN_INTENSITY_VALUE,\n  MAX_INTENSITY_VALUE,\n  MIN_INTENSITIES_COUNT,\n  MAX_INTENSITIES_COUNT,\n  RESERVED_GROUP_NAMES,\n  VALID_GROUP_TYPES,\n});\n\n/**\n * Helper function to format validation errors for display\n */\nexport const formatValidationErrors = (validation: ValidationResult): string => {\n  if (validation.isValid) return '';\n\n  let message = validation.errors.join('\\n');\n\n  if (validation.warnings && validation.warnings.length > 0) {\n    message += '\\n\\nWarnings:\\n' + validation.warnings.join('\\n');\n  }\n\n  return message;\n};\n","import { DocumentData, DocumentReference } from 'firebase/firestore';\nimport { getOrCreateBoard, sendMessage } from './firebase';\n\nimport { CustomTilePull } from '@/types/customTiles';\nimport { Settings } from '@/types/Settings';\nimport { TileExport } from '@/types/gameBoard';\nimport { User } from '@/types';\nimport { getCustomGroupByName } from '@/stores/customGroups';\nimport i18next from 'i18next';\nimport { isOnlineMode } from '@/helpers/strings';\n\n/**\n * Type guard to check if an object has a valid role property\n * @param obj - The object to check\n * @param role - The role key to look for\n * @returns true if obj is an object and has the role property\n */\nfunction isValidRole(obj: unknown, role: unknown): obj is Record<string, unknown> {\n  return obj !== null && typeof obj === 'object' && typeof role === 'string' && role in obj;\n}\n\ninterface ActionsList {\n  [key: string]: {\n    label: string;\n    actions: Record<string, any>;\n    [key: string]: any;\n  };\n}\n\nfunction getCustomTileCount(\n  settings: Settings,\n  customTiles: CustomTilePull[] | null | undefined,\n  actionsList: ActionsList\n): number {\n  // Use selectedActions structure only\n  const actionEntries = settings.selectedActions || {};\n\n  const settingsDataFolder = Object.entries(actionsList)\n    .filter(([key]) => actionEntries[key])\n    .reduce<Record<string, string[]>>((acc, [key, value]) => {\n      const levels = actionEntries[key].levels || [];\n      const actionKeys = Object.keys(value.actions);\n      acc[key] = levels.map((level) => actionKeys[level]).filter(Boolean);\n      return acc;\n    }, {});\n\n  const usedCustomTiles =\n    customTiles?.filter((entry) => {\n      // Only count tiles that are actually custom (not migrated defaults)\n      if (!entry.isCustom) return false;\n\n      const intensityArray = settingsDataFolder[entry.group];\n      return intensityArray && intensityArray.length >= Number(entry.intensity);\n    }) || [];\n\n  return usedCustomTiles.length;\n}\n\nexport async function getSettingsMessage(\n  settings: Settings,\n  customTiles: CustomTilePull[] | null | undefined,\n  actionsList: ActionsList,\n  reason?: string\n): Promise<string> {\n  const { t } = i18next;\n  let message = `### ${i18next.t('gameSettingsHeading')}\\r\\n`;\n  if (reason) {\n    message += `##### ${reason}\\r\\n`;\n  }\n  message += '--- \\r\\n';\n\n  // output only settings that have a corresponding actionsList entry.\n  // Use selectedActions structure only\n  const actionEntries = settings.selectedActions || {};\n\n  Object.entries(actionsList).forEach(([key, val]) => {\n    if (!actionEntries[key]) return;\n\n    const { role, variation, levels } = actionEntries[key];\n    const actualRole = role || settings.role || 'sub';\n\n    if (levels && levels.length > 0) {\n      // Show group name with bulleted list of intensity level names\n      message += val?.label;\n\n      let modifier = null;\n      if (variation) {\n        modifier = t(variation);\n      } else if (!isOnlineMode(settings.gameMode)) {\n        modifier = isValidRole(val, actualRole)\n          ? (val[actualRole as string] as string)\n          : t(actualRole as string);\n      }\n\n      if (modifier) {\n        message += `: ${modifier}`;\n      }\n\n      message += '\\r\\n';\n\n      // Get intensity names for selected levels\n      const intensityNames = val?.intensities || {};\n      levels.forEach((level: number) => {\n        const levelName = intensityNames[level] || `Level ${level}`;\n        message += `* ${levelName}\\r\\n`;\n      });\n      message += '\\r\\n';\n    }\n  });\n\n  // Add custom groups from settings.customGroups\n  if (settings.customGroups && Array.isArray(settings.customGroups)) {\n    for (const customGroup of settings.customGroups) {\n      if (customGroup.groupName && customGroup.intensity) {\n        try {\n          // Get the actual custom group data to access the label\n          const groupData = await getCustomGroupByName(\n            customGroup.groupName,\n            settings.locale || 'en',\n            settings.gameMode || 'online'\n          );\n\n          const groupLabel = groupData?.label || customGroup.groupName;\n          message += `* ${groupLabel}: Level ${customGroup.intensity} (Custom)\\r\\n`;\n        } catch (error) {\n          console.error(`Error loading custom group ${customGroup.groupName}:`, error);\n          // Fallback to using groupName as label\n          message += `* ${customGroup.groupName}: Level ${customGroup.intensity} (Custom)\\r\\n`;\n        }\n      }\n    }\n  }\n\n  // if our last line was the --- \\r\\n then return nothing because we have no settings.\n  if (message.endsWith('--- \\r\\n')) {\n    return '';\n  }\n\n  const { finishRange } = settings;\n\n  message += '--- \\r\\n';\n\n  if (finishRange) {\n    const noCumPercent = finishRange[0];\n    const ruinedPercent = finishRange[1] - finishRange[0];\n    const normalPercent = 100 - finishRange[1];\n\n    // Count how many non-zero options we have\n    const optionList: Array<{ percent: number; text: string } | null> = [\n      noCumPercent > 0 ? { percent: noCumPercent, text: t('noCum') as string } : null,\n      ruinedPercent > 0 ? { percent: ruinedPercent, text: t('ruined') as string } : null,\n      normalPercent > 0 ? { percent: normalPercent, text: t('cum') as string } : null,\n    ];\n\n    const activeOptions = optionList.filter(\n      (option): option is { percent: number; text: string } => option !== null\n    );\n\n    if (activeOptions.length === 1 && activeOptions[0].percent === 100) {\n      // Single option at 100% - show inline without bullets\n      message += `* ${t('finishSlider')} ${activeOptions[0].text.replace(':', '')} \\r\\n`;\n    } else if (activeOptions.length > 0) {\n      // Multiple options or single option not at 100% - show with bullets\n      message += `* ${t('finishSlider')} \\r\\n\\r\\n`;\n\n      activeOptions.forEach((option) => {\n        const optionText =\n          option.percent === 100\n            ? option.text.replace(':', '')\n            : `${option.text} ${option.percent}%`;\n        message += `  - ${optionText} \\r\\n`;\n      });\n    }\n  }\n\n  const customTileCount = getCustomTileCount(settings, customTiles, actionsList);\n  if (customTileCount) {\n    message += `* ${t('customTilesLabel')}: ${customTileCount} \\r\\n`;\n  }\n\n  return message;\n}\n\nfunction exportSettings(formData: Settings): Record<string, any> {\n  const newSettings: Record<string, any> = {};\n  Object.entries(formData).forEach(([settingKey, settingValue]) => {\n    // list of settings to not export and thus not import.\n    const personalSettings = [\n      'displayName',\n      'background',\n      'boardUpdated',\n      'chatSound',\n      'mySound',\n      'otherSound',\n      'othersDialog',\n      'playerDialog',\n      'readRoll',\n      'hideBoardActions',\n      'advancedSettings',\n    ];\n    // don't export personal settings nor room specific settings.\n    if (!personalSettings.includes(settingKey) && !settingKey.startsWith('room')) {\n      newSettings[settingKey] = settingValue;\n    }\n  });\n  return newSettings;\n}\n\ninterface SendMessageOptions {\n  title: string;\n  formData: Settings;\n  user: User;\n  actionsList: ActionsList;\n  tiles: TileExport[];\n  customTiles?: CustomTilePull[];\n  reason?: string;\n}\n\nexport default async function sendGameSettingsMessage({\n  title,\n  formData,\n  user,\n  actionsList,\n  tiles,\n  customTiles = [],\n  reason = '',\n}: SendMessageOptions): Promise<DocumentReference<DocumentData> | void> {\n  const settings = JSON.stringify(exportSettings(formData));\n\n  const gameBoard = await getOrCreateBoard({\n    title,\n    gameBoard: JSON.stringify(tiles),\n    settings,\n  });\n\n  const text = await getSettingsMessage(formData, customTiles, actionsList, reason);\n\n  if (!gameBoard?.id || text === '') {\n    return;\n  }\n\n  return sendMessage({\n    room: formData?.room || 'PUBLIC',\n    user,\n    text,\n    type: 'settings',\n    gameBoardId: gameBoard.id,\n    boardSize: tiles.length,\n    gameMode: formData.gameMode,\n  });\n}\n","import { CustomGroupPull } from '@/types/customGroups';\nimport { CustomTilePull } from '@/types/customTiles';\nimport { Settings } from '@/types/Settings';\nimport { TileExport } from '@/types/gameBoard';\nimport { getCustomGroups } from '@/stores/customGroups';\nimport { getTiles } from '@/stores/customTiles';\nimport i18next from 'i18next';\nimport { shuffleArray } from '@/helpers/arrays';\n\nconst { t } = i18next;\n\ninterface GameTile {\n  title: string;\n  description: string;\n  standalone?: boolean;\n  role?: string;\n}\n\ninterface BoardBuildResult {\n  board: TileExport[];\n  metadata: {\n    totalTiles: number;\n    tilesWithContent: number;\n    selectedGroups: string[];\n    missingGroups: string[];\n    availableTileCount: number;\n  };\n}\n\n/**\n * Shuffle bag implementation to ensure no duplicate actions until all actions are used.\n * This class groups tiles by group name and intensity, providing a fair distribution\n * of actions by ensuring all tiles in a category are used before any duplicates.\n */\nclass TileShuffleBag {\n  /** Maps group-intensity keys to shuffled tile arrays */\n  private bags: Map<string, CustomTilePull[]> = new Map();\n  /** Stores original tile sets for refilling bags */\n  private originalTiles: Map<string, CustomTilePull[]> = new Map();\n\n  /**\n   * Creates a new shuffle bag from the provided tiles.\n   * @param tiles Array of tiles to organize into shuffle bags\n   */\n  constructor(tiles: CustomTilePull[]) {\n    // Group tiles by group name and intensity for bag management\n    const groupedTiles = new Map<string, CustomTilePull[]>();\n\n    tiles.forEach((tile) => {\n      const key = `${tile.group}-${tile.intensity}`;\n      if (!groupedTiles.has(key)) {\n        groupedTiles.set(key, []);\n      }\n      groupedTiles.get(key)!.push(tile);\n    });\n\n    // Initialize bags with shuffled tiles\n    groupedTiles.forEach((tiles, key) => {\n      const shuffledTiles = [...tiles];\n      shuffleArray(shuffledTiles);\n      this.bags.set(key, shuffledTiles);\n      this.originalTiles.set(key, [...tiles]);\n    });\n  }\n\n  /**\n   * Gets a tile from the specified group and intensity bag.\n   * When a bag is empty, it refills and reshuffles automatically.\n   * @param groupName The name of the group to get a tile from\n   * @param intensity The intensity level to get a tile from\n   * @returns A tile or null if no tiles are available\n   */\n  getTile(groupName: string, intensity: number): CustomTilePull | null {\n    const key = `${groupName}-${intensity}`;\n    let bag = this.bags.get(key);\n\n    if (!bag || bag.length === 0) {\n      // Refill and reshuffle the bag when empty\n      const originalTiles = this.originalTiles.get(key);\n      if (!originalTiles || originalTiles.length === 0) {\n        return null;\n      }\n\n      bag = [...originalTiles];\n      shuffleArray(bag);\n      this.bags.set(key, bag);\n    }\n\n    return bag.pop() || null;\n  }\n}\n\n// Filter tiles based on player role\nfunction filterTilesByRole(\n  tiles: CustomTilePull[],\n  role: string,\n  groups: CustomGroupPull[] = []\n): CustomTilePull[] {\n  return tiles.filter((tile) => {\n    const action = tile.action;\n\n    // Find the group for this tile to check its type\n    const group = groups.find((g) => g.name === tile.group);\n\n    // Consumption tiles should be available to all roles\n    if (group?.type === 'consumption') {\n      return true;\n    }\n\n    // Solo tiles should be available to all roles (self-directed activities)\n    if (group?.type === 'solo') {\n      return true;\n    }\n\n    if (role === 'vers') {\n      return (action.includes('{sub}') && action.includes('{dom}')) || action.includes('{player}');\n    }\n    return !action.match(/{(dom|sub)}/) || action.includes(`{${role}}`);\n  });\n}\n\n/** Cache for intensity calculations to avoid repeated computation */\nconst intensityCache = new Map<string, number>();\n\n/**\n * Calculate intensity level based on board position for progression.\n * Results are cached to improve performance for repeated calculations.\n */\nfunction calculateIntensity(gameSize: number, maxIntensity: number, currentTile: number): number {\n  // Create cache key for memoization\n  const cacheKey = `${gameSize}-${maxIntensity}-${currentTile}`;\n  const cached = intensityCache.get(cacheKey);\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  // Simple linear progression from 1 to maxIntensity across the board\n  const divider = gameSize / maxIntensity;\n  const result = Math.floor(currentTile / divider) + 1; // Add 1 since intensities start at 1\n\n  // Cache the result for future use\n  intensityCache.set(cacheKey, result);\n  return result;\n}\n\n// Build individual tile content\nfunction buildTileContent(\n  availableGroups: CustomGroupPull[],\n  shuffleBag: TileShuffleBag,\n  selectedActions: Record<string, any>,\n  currentTile: number,\n  gameSize: number,\n  settings: Settings\n): GameTile {\n  if (!availableGroups.length) {\n    return { title: '', description: '' };\n  }\n\n  // Use the first (and typically only) group provided\n  const currentGroup = availableGroups[0];\n\n  // Check if this group should append or standalone\n  const groupSelection = selectedActions[currentGroup.name];\n  if (!groupSelection || !groupSelection.levels || groupSelection.levels.length === 0) {\n    return { title: '', description: '' };\n  }\n\n  // Handle frequency/append logic\n  if (groupSelection.variation) {\n    const frequency =\n      groupSelection.variation === 'appendSome'\n        ? 0.4\n        : groupSelection.variation === 'appendMost'\n          ? 0.9\n          : 1.0;\n\n    if (groupSelection.variation !== 'standalone' && Math.random() > frequency) {\n      return { title: '', description: '' };\n    }\n  }\n\n  // Calculate intensity based on position for board progression\n  const maxIntensity = Math.max(...currentGroup.intensities.map((i) => i.value));\n  const calculatedIntensity = calculateIntensity(gameSize, maxIntensity, currentTile);\n\n  // Find the target intensity from user's selected levels\n  const userSelectedLevels = groupSelection.levels;\n  let targetIntensity: number;\n\n  // Check if calculated intensity is in user's selection\n  if (userSelectedLevels.includes(calculatedIntensity)) {\n    targetIntensity = calculatedIntensity;\n  } else {\n    // Find closest available level\n    targetIntensity = userSelectedLevels.reduce((prev: number, curr: number) =>\n      Math.abs(curr - calculatedIntensity) < Math.abs(prev - calculatedIntensity) ? curr : prev\n    );\n  }\n\n  // Try to get a tile from the shuffle bag with fallback logic\n  let selectedTile = shuffleBag.getTile(currentGroup.name, targetIntensity);\n\n  if (!selectedTile) {\n    // Try other selected levels if target intensity doesn't have tiles\n    const otherLevels = userSelectedLevels.filter((level: number) => level !== targetIntensity);\n    for (const intensity of otherLevels) {\n      selectedTile = shuffleBag.getTile(currentGroup.name, intensity);\n      if (selectedTile) {\n        break;\n      }\n    }\n\n    if (!selectedTile) {\n      return { title: '', description: '' };\n    }\n  }\n\n  return {\n    title: currentGroup.label,\n    description: selectedTile.action,\n    standalone: groupSelection.variation === 'standalone',\n    role: settings.role || 'sub',\n  };\n}\n\n// Handle append logic for combining tiles\nfunction processAppendTiles(\n  mainTile: GameTile,\n  appendGroups: CustomGroupPull[],\n  shuffleBag: TileShuffleBag,\n  selectedActions: Record<string, any>,\n  currentTile: number,\n  gameSize: number,\n  settings: Settings\n): string {\n  if (mainTile.standalone || !appendGroups.length || !mainTile.description) {\n    return mainTile.description || '';\n  }\n\n  const appendTile = buildTileContent(\n    appendGroups,\n    shuffleBag,\n    selectedActions,\n    currentTile,\n    gameSize,\n    settings\n  );\n\n  if (appendTile.description) {\n    const ensurePunctuation = appendTile.description.trim().replace(/([^.,!?])$/, '$1.');\n    return `${ensurePunctuation} ${mainTile.description}`;\n  }\n\n  return mainTile.description;\n}\n\n// Build the complete game board\nasync function buildBoard(\n  availableGroups: CustomGroupPull[],\n  allTiles: CustomTilePull[],\n  settings: Settings,\n  size: number\n): Promise<GameTile[]> {\n  const selectedActions = settings.selectedActions || {};\n\n  // Create shuffle bag for tile selection\n  const shuffleBag = new TileShuffleBag(allTiles);\n\n  // Separate groups into main and append categories\n  const mainGroups = availableGroups.filter((group) => {\n    const selection = selectedActions[group.name];\n    return (\n      selection &&\n      selection.levels &&\n      selection.levels.length > 0 &&\n      (!selection.variation || selection.variation === 'standalone')\n    );\n  });\n\n  const appendGroups = availableGroups.filter((group) => {\n    const selection = selectedActions[group.name];\n    return (\n      selection &&\n      selection.levels &&\n      selection.levels.length > 0 &&\n      (selection.variation === 'appendSome' || selection.variation === 'appendMost')\n    );\n  });\n\n  // Shuffle main groups to ensure variety in group selection\n  shuffleArray(mainGroups);\n  let groupIndex = 0;\n\n  const board: GameTile[] = [];\n\n  for (let currentTile = 1; currentTile <= size; currentTile++) {\n    // Rotate through groups to ensure variety\n    const selectedMainGroups =\n      mainGroups.length > 0 ? [mainGroups[groupIndex % mainGroups.length]] : [];\n    groupIndex++;\n\n    const mainTile = buildTileContent(\n      selectedMainGroups,\n      shuffleBag,\n      selectedActions,\n      currentTile,\n      size,\n      settings\n    );\n\n    const finalDescription = processAppendTiles(\n      mainTile,\n      appendGroups,\n      shuffleBag,\n      selectedActions,\n      currentTile,\n      size,\n      settings\n    );\n\n    board.push({\n      title: mainTile.title,\n      description: finalDescription.trim(),\n      role: mainTile.role,\n    });\n  }\n\n  return board;\n}\n\n// Add start and finish tiles\nfunction addStartAndFinishTiles(board: GameTile[], settings: Settings): TileExport[] {\n  const startTile: TileExport = {\n    title: t('start'),\n    description: t('start'),\n  };\n\n  const { finishRange = [33, 66] } = settings;\n  const finishDescription =\n    `${t('noCum')} ${finishRange[0]}%` +\n    `\\r\\n${t('ruined')} ${finishRange[1] - finishRange[0]}%` +\n    `\\r\\n${t('cum')} ${100 - finishRange[1]}%`;\n\n  const finishTile: TileExport = {\n    title: t('finish'),\n    description: finishDescription,\n  };\n\n  return [\n    startTile,\n    ...board.map((tile) => ({ title: tile.title, description: tile.description })),\n    finishTile,\n  ];\n}\n\n/**\n * Build a game board directly from Dexie data\n * @param settings Game settings including selectedActions\n * @param locale Current locale for internationalization\n * @param gameMode Current game mode (online, local, solo)\n * @param tileCount Total number of tiles to generate (excluding start/finish)\n * @returns Promise containing the built board and metadata\n */\nexport default async function buildGameBoard(\n  settings: Settings,\n  locale: string,\n  gameMode: string,\n  tileCount = 40\n): Promise<BoardBuildResult> {\n  try {\n    // Fetch all required data from Dexie in parallel\n    const [availableGroups, allTiles] = await Promise.all([\n      getCustomGroups({ locale, gameMode }), // Include both default and custom groups\n      getTiles({ locale, gameMode }),\n    ]);\n\n    // Get selected action group names\n    const selectedActions = settings.selectedActions || {};\n    const selectedGroupNames = Object.keys(selectedActions).filter(\n      (groupName) =>\n        selectedActions[groupName]?.levels && selectedActions[groupName].levels.length > 0\n    );\n\n    // Filter groups to only those selected by user\n    const selectedGroups = availableGroups.filter((group) =>\n      selectedGroupNames.includes(group.name)\n    );\n\n    // Find missing groups (selected but not available)\n    const availableGroupNames = availableGroups.map((g) => g.name);\n    const missingGroups = selectedGroupNames.filter((name) => !availableGroupNames.includes(name));\n\n    // Filter tiles by role if specified\n    const role = settings.role || 'sub';\n    const filteredTiles = filterTilesByRole(allTiles, role, availableGroups);\n\n    // Only get tiles for selected groups\n    const relevantTiles = filteredTiles.filter((tile) => selectedGroupNames.includes(tile.group));\n\n    // If no selected groups or tiles available, return empty board\n    if (!selectedGroups.length || !relevantTiles.length) {\n      return {\n        board: addStartAndFinishTiles([], settings),\n        metadata: {\n          totalTiles: tileCount + 2,\n          tilesWithContent: 2, // Start and finish tiles\n          selectedGroups: selectedGroupNames,\n          missingGroups,\n          availableTileCount: relevantTiles.length,\n        },\n      };\n    }\n\n    // Build the board\n    const gameBoard = await buildBoard(selectedGroups, relevantTiles, settings, tileCount);\n\n    // Calculate metadata\n    const tilesWithContent = gameBoard.filter((tile) => tile.description.trim().length > 0).length;\n\n    const finalBoard = addStartAndFinishTiles(gameBoard, settings);\n\n    return {\n      board: finalBoard,\n      metadata: {\n        totalTiles: finalBoard.length,\n        tilesWithContent: tilesWithContent + 2, // +2 for start/finish\n        selectedGroups: selectedGroupNames,\n        missingGroups,\n        availableTileCount: relevantTiles.length,\n      },\n    };\n  } catch (error) {\n    console.error('Error building game board:', error);\n\n    // Return empty board on error\n    return {\n      board: addStartAndFinishTiles([], settings),\n      metadata: {\n        totalTiles: 2,\n        tilesWithContent: 2, // Start and finish tiles\n        selectedGroups: [],\n        missingGroups: [],\n        availableTileCount: 0,\n      },\n    };\n  }\n}\n","import { useLiveQuery } from 'dexie-react-hooks';\nimport { isPublicRoom } from '@/helpers/strings';\nimport { useSettings } from '@/stores/settingsStore';\nimport { useTranslation } from 'react-i18next';\nimport buildGameBoard from '@/services/buildGame';\nimport { getActiveBoard, upsertBoard } from '@/stores/gameBoard';\nimport { isOnlineMode } from '@/helpers/strings';\nimport { useCallback } from 'react';\nimport { Settings } from '@/types/Settings';\nimport { DBGameBoard, GameBoardResult } from '@/types/gameBoard';\n\n/**\n * Builds a game board based on the settings provided.\n * @returns A function that takes in a form data object and returns an object.\n */\nexport default function useGameBoard(): (data: Settings) => Promise<GameBoardResult> {\n  const gameBoard = useLiveQuery<DBGameBoard | undefined>(getActiveBoard);\n  const [settings, updateSettings] = useSettings();\n  const { i18n } = useTranslation();\n\n  const updateGameBoard = useCallback(\n    async (data: Settings): Promise<GameBoardResult> => {\n      // Ensure selectedActions is properly handled in formData\n      const formData =\n        data?.roomUpdate || data?.boardUpdated\n          ? data\n          : {\n              ...settings,\n              ...data,\n              selectedActions: {\n                ...settings.selectedActions,\n                ...data.selectedActions,\n              },\n            };\n      let { gameMode, boardUpdated: settingsBoardUpdated } = formData;\n      const { roomTileCount = 40, finishRange, room } = formData;\n      const isPublic = isPublicRoom(room || '');\n\n      if (!data || !finishRange) {\n        // still loading data.\n        return { gameMode };\n      }\n\n      // If we are in a public room,\n      // then gameMode should update to online, and we need to re-import actions.\n      if (isPublic && !isOnlineMode(gameMode || '')) {\n        gameMode = 'online';\n        // this is async, so we need the boardUpdated & updatedDataFolder as separate entities.\n        settingsBoardUpdated = true;\n      }\n\n      const finalGameMode = gameMode || 'online';\n      const locale = i18n.resolvedLanguage || 'en';\n      const tileCount = isPublic ? 40 : roomTileCount || 40;\n\n      // Use the new streamlined buildGameBoard function\n      const boardResult = await buildGameBoard(formData, locale, finalGameMode, tileCount);\n\n      // Log useful debug information\n      if (boardResult.metadata.missingGroups.length > 0) {\n        console.warn('Missing groups for board building:', boardResult.metadata.missingGroups);\n      }\n\n      if (boardResult.metadata.tilesWithContent < tileCount / 2) {\n        console.warn('Low tile content ratio:', {\n          tilesWithContent: boardResult.metadata.tilesWithContent,\n          totalTiles: boardResult.metadata.totalTiles,\n          availableTileCount: boardResult.metadata.availableTileCount,\n        });\n      }\n\n      // if our board updated, then push those changes out.\n      if (\n        data?.boardUpdated ||\n        settingsBoardUpdated ||\n        (gameBoard?.tiles?.length ?? 0) !== boardResult.board.length\n      ) {\n        await updateSettings(formData);\n        await upsertBoard({ title: gameBoard?.title || '', tiles: boardResult.board });\n      }\n\n      return {\n        settingsBoardUpdated,\n        gameMode,\n        newBoard: boardResult.board,\n        metadata: boardResult.metadata,\n      };\n    },\n    [gameBoard, i18n.resolvedLanguage, settings, updateSettings]\n  );\n\n  return useCallback((data: Settings) => updateGameBoard(data), [updateGameBoard]);\n}\n","import { Params, useNavigate, useParams } from 'react-router-dom';\n\nexport default function useRoomNavigate(): (formRoom?: string) => void {\n  const { id: room } = useParams<Params>();\n  const navigate = useNavigate();\n\n  return (formRoom?: string): void => {\n    const shouldNavigate = room !== undefined && room?.toUpperCase() !== formRoom?.toUpperCase();\n    const noLeadingSlash = formRoom?.replace(/^\\/+/, '') || 'PUBLIC';\n\n    if (shouldNavigate) {\n      navigate(`/${noLeadingSlash}`);\n    }\n  };\n}\n","import type { LocalPlayer, LocalSessionSettings } from '@/types';\nimport { Params, useParams } from 'react-router-dom';\nimport { getActiveBoard, upsertBoard } from '@/stores/gameBoard';\nimport { handleUser, sendRoomSettingsMessage } from '@/views/GameSettings/submitForm';\n\nimport { GameBoardResult } from '@/types/gameBoard';\nimport { Message } from '@/types/Message';\nimport { Settings } from '@/types/Settings';\nimport { getActiveTiles } from '@/stores/customTiles';\nimport { getValidationConstants } from '@/services/validationService';\nimport { isPublicRoom } from '@/helpers/strings';\nimport { isValidURL } from '@/helpers/urls';\nimport sendGameSettingsMessage from '@/services/gameSettingsMessage';\nimport useAuth from '@/context/hooks/useAuth';\nimport { useCallback } from 'react';\nimport useGameBoard from './useGameBoard';\nimport { useLiveQuery } from 'dexie-react-hooks';\nimport { useLocalPlayers } from './useLocalPlayers';\nimport useMessages from '@/context/hooks/useMessages';\nimport useRoomNavigate from './useRoomNavigate';\nimport { useSettings } from '@/stores/settingsStore';\nimport { useTranslation } from 'react-i18next';\n\ninterface RoomChangeResult {\n  roomChanged: boolean;\n  isPrivateRoom: boolean;\n  privateBoardSizeChanged: boolean;\n}\nfunction updateRoomBackground(formData: Settings): void {\n  const url = formData.roomBackgroundURL?.trim();\n  if (url !== formData.roomBackgroundURL) {\n    formData.roomBackgroundURL = url || '';\n  }\n  if (formData.roomBackgroundURL && !isValidURL(formData.roomBackgroundURL)) {\n    formData.roomBackgroundURL = ''; // Clear invalid URL\n  }\n}\n\n/**\n * Clean form data by removing any action/consumption entries that have been deselected\n * This ensures that the Zustand store doesn't retain stale action selections\n */\nfunction cleanFormData(formData: Settings): Settings {\n  const cleanedData = { ...formData };\n  const cleanedSelectedActions: Record<string, any> = {};\n\n  // Clean the selectedActions object\n  if (formData.selectedActions) {\n    Object.entries(formData.selectedActions).forEach(([key, entry]) => {\n      if (entry && entry.levels && entry.levels.length > 0) {\n        cleanedSelectedActions[key] = entry;\n      }\n    });\n  }\n\n  // Remove any old root-level action keys (for migration cleanup)\n  const validationConstants = getValidationConstants();\n  Object.keys(cleanedData).forEach((key) => {\n    const entry = cleanedData[key] as any;\n    if (\n      entry &&\n      typeof entry === 'object' &&\n      entry.type &&\n      validationConstants.VALID_GROUP_TYPES.includes(entry.type)\n    ) {\n      delete cleanedData[key];\n    }\n  });\n\n  cleanedData.selectedActions = cleanedSelectedActions;\n\n  return cleanedData;\n}\n\nexport default function useSubmitGameSettings(): (\n  formData: Settings,\n  actionsList: any\n) => Promise<void> {\n  const { user, updateUser } = useAuth();\n  const { id: room } = useParams<Params>();\n  const { t } = useTranslation();\n  const updateGameBoardTiles = useGameBoard();\n  const [settings, updateSettings] = useSettings();\n  const customTiles = useLiveQuery(() => getActiveTiles(settings?.gameMode));\n  const gameBoard = useLiveQuery(getActiveBoard);\n  const navigate = useRoomNavigate();\n  const { messages } = useMessages();\n  const { createLocalSession } = useLocalPlayers();\n\n  const handleRoomChange = useCallback(\n    (formData: Settings): RoomChangeResult => {\n      // Handle the case where room might be undefined (original logic with safety check)\n      const currentRoomUpper = (room || '')?.toUpperCase();\n      const formDataRoomUpper = (formData.room || '').toUpperCase();\n      const roomChanged = currentRoomUpper !== formDataRoomUpper;\n      const isPrivateRoom = Boolean(formData.room && !isPublicRoom(formData.room));\n      const privateBoardSizeChanged =\n        isPrivateRoom && formData.roomTileCount !== settings?.roomTileCount;\n\n      return { roomChanged, isPrivateRoom, privateBoardSizeChanged };\n    },\n    [room, settings?.roomTileCount]\n  );\n\n  const submitSettings = useCallback(\n    async (formData: Settings, actionsList: any): Promise<void> => {\n      const { displayName } = formData;\n      const updatedUser = await handleUser(user, displayName, updateUser);\n\n      updateRoomBackground(formData);\n\n      const {\n        settingsBoardUpdated,\n        gameMode,\n        newBoard = [],\n      } = (await updateGameBoardTiles(formData)) as GameBoardResult;\n      const { roomChanged, isPrivateRoom, privateBoardSizeChanged } = handleRoomChange(formData);\n\n      if (!updatedUser) return;\n\n      if (\n        isPrivateRoom &&\n        (formData.roomUpdated || !messages.find((m: Message) => m.type === 'room'))\n      ) {\n        await sendRoomSettingsMessage(formData, updatedUser);\n      }\n\n      if (gameBoard?.tiles !== newBoard) {\n        await upsertBoard({\n          title: t('settingsGenerated'),\n          tiles: newBoard,\n          isActive: 1,\n          gameMode,\n        });\n      }\n\n      const shouldSendGameSettings =\n        (settingsBoardUpdated || roomChanged || privateBoardSizeChanged) &&\n        !messages.some(\n          (m: Message) =>\n            m.type === 'settings' &&\n            m.uid === updatedUser.uid &&\n            Date.now() - (m.timestamp?.toMillis() || 0) < 5000\n        );\n\n      if (shouldSendGameSettings) {\n        await sendGameSettingsMessage({\n          formData,\n          user: updatedUser,\n          customTiles,\n          actionsList,\n          title: 'Settings Generated Board',\n          tiles: newBoard,\n        });\n      }\n\n      // Handle local player session initialization if data exists\n      const typedFormData = formData as any; // Use any type to access wizard-specific properties\n      if (\n        typedFormData.hasLocalPlayers &&\n        typedFormData.localPlayersData &&\n        typedFormData.localPlayerSessionSettings\n      ) {\n        try {\n          await createLocalSession(\n            formData.room,\n            typedFormData.localPlayersData as LocalPlayer[],\n            typedFormData.localPlayerSessionSettings as LocalSessionSettings\n          );\n        } catch (error) {\n          console.error('Error creating local session:', error);\n          // Don't throw here to prevent blocking the settings save\n        }\n      }\n\n      // Clean the formData to remove any deselected actions/consumptions before storing\n      const cleanedFormData = cleanFormData(formData);\n\n      updateSettings({\n        ...cleanedFormData,\n        boardUpdated: false,\n        roomUpdated: false,\n        gameMode,\n      });\n\n      navigate(formData.room);\n    },\n    [\n      user,\n      updateUser,\n      updateGameBoardTiles,\n      handleRoomChange,\n      messages,\n      gameBoard,\n      t,\n      customTiles,\n      updateSettings,\n      navigate,\n      createLocalSession,\n    ]\n  );\n\n  return useCallback(\n    (formData: Settings, actionsList: any) => submitSettings(formData, actionsList),\n    [submitSettings]\n  );\n}\n","import { useEffect, useState, useCallback, useMemo } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { getAllAvailableGroups } from '@/stores/customGroups';\nimport { GroupedActions } from '@/types/customTiles';\nimport { UNIFIED_ACTION_CACHE_TTL } from '@/constants/actionConstants';\nimport { useMigration } from '@/context/migration';\n\ninterface UnifiedActionListResult {\n  actionsList: GroupedActions;\n  isLoading: boolean;\n}\n\n// Simple cache to prevent duplicate API calls\nconst actionsCache = new Map<string, { data: GroupedActions; timestamp: number }>();\nconst CACHE_TTL = UNIFIED_ACTION_CACHE_TTL;\n\n// Debug function to inspect cache\n(window as any).debugActionsCache = () => {};\n\n// Debug function to clear cache\n(window as any).clearActionsCache = () => {\n  actionsCache.clear();\n};\n\n/**\n * Hook that combines default actions from locale files with custom groups from Dexie\n * into a unified structure that can be used by the existing IncrementalSelect component\n *\n * @param gameMode - The game mode to filter groups by (e.g., 'online', 'local')\n * @returns Object containing the unified actions list and loading state\n *\n * Features:\n * - Caches results for 30 seconds to improve performance\n * - Automatically handles locale changes\n * - Filters groups by game mode\n * - Converts custom groups to the expected format for UI components\n */\nexport default function useUnifiedActionList(gameMode?: string): UnifiedActionListResult {\n  const { i18n, t } = useTranslation();\n  const { currentLanguageMigrated, isHealthy, forceRecovery } = useMigration();\n  const [actionsList, setActionsList] = useState<GroupedActions>({});\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [recoveryAttempted, setRecoveryAttempted] = useState<boolean>(false);\n\n  // Track language changes and migration status for debugging\n  useEffect(() => {\n    const handleLanguageChange = () => {\n      // Clear cache for all languages since the user changed language\n      if (gameMode) {\n        const oldCacheKeys = Array.from(actionsCache.keys()).filter((key) =>\n          key.endsWith(`-${gameMode}`)\n        );\n        oldCacheKeys.forEach((key) => {\n          actionsCache.delete(key);\n        });\n      }\n    };\n\n    i18n.on('languageChanged', handleLanguageChange);\n\n    return () => {\n      i18n.off('languageChanged', handleLanguageChange);\n    };\n  }, [i18n, gameMode]);\n\n  // Memoize the cache key to prevent unnecessary recalculations\n  const cacheKey = useMemo(() => {\n    if (!gameMode || !i18n.resolvedLanguage) return '';\n    return `${i18n.resolvedLanguage}-${gameMode}`;\n  }, [i18n.resolvedLanguage, gameMode]);\n\n  // Clear cache when migration status changes from false to true\n  useEffect(() => {\n    if (currentLanguageMigrated && cacheKey) {\n      // Migration just completed - clear cache to force fresh load\n      const cached = actionsCache.get(cacheKey);\n      if (cached) {\n        actionsCache.delete(cacheKey);\n      }\n    }\n  }, [currentLanguageMigrated, cacheKey]);\n\n  // Check cache immediately on render to prevent unnecessary loading states\n  // Using useEffect instead of useMemo to avoid side effects in useMemo\n  useEffect(() => {\n    if (cacheKey) {\n      const cached = actionsCache.get(cacheKey);\n      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n        setActionsList(cached.data);\n        setIsLoading(false);\n      }\n    }\n  }, [cacheKey]);\n\n  const loadUnifiedActions = useCallback(async (): Promise<void> => {\n    if (!gameMode || !cacheKey) {\n      console.warn('⚠️ useUnifiedActionList: Missing required params', { gameMode, cacheKey });\n      return;\n    }\n\n    // Wait for migration to complete before loading actions\n    if (!currentLanguageMigrated) {\n      return;\n    }\n\n    // If migration is complete but health check failed, attempt recovery once\n    if (currentLanguageMigrated && !isHealthy && !recoveryAttempted) {\n      setRecoveryAttempted(true);\n      try {\n        await forceRecovery();\n        // Recovery will trigger a re-render, so return and let the next call handle loading\n        return;\n      } catch {\n        // Continue with loading attempt even if recovery fails\n      }\n    }\n\n    // Check cache first\n    const cached = actionsCache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n      setActionsList(cached.data);\n      setIsLoading(false);\n      return;\n    }\n\n    setIsLoading(true);\n\n    try {\n      // Load all available groups from Dexie (includes both default and custom groups)\n      const allGroups = await getAllAvailableGroups(i18n.resolvedLanguage, gameMode);\n\n      // Convert all groups to unified actions structure\n      const unifiedActions: GroupedActions = {};\n\n      for (const group of allGroups) {\n        // Convert group to the same structure as expected by components\n        const actions: Record<string, string[]> = {\n          [t('none')]: [], // Always include None option for consistency\n        };\n\n        // Add intensity levels as action keys with empty arrays\n        // The IncrementalSelect component uses these keys as menu items\n        const intensities: Record<number, string> = {};\n        if (group.intensities && Array.isArray(group.intensities)) {\n          group.intensities\n            .sort((a, b) => a.value - b.value)\n            .forEach((intensity) => {\n              actions[intensity.label] = []; // Empty array since custom groups don't have predefined actions\n              intensities[intensity.value] = intensity.label; // Map level to name\n            });\n        }\n\n        const finalType = group.type || 'action';\n\n        unifiedActions[group.name] = {\n          label: group.label || group.name,\n          type: finalType, // Use the preserved type from migration\n          actions,\n          intensities, // Add the intensities mapping\n        };\n      }\n\n      // Cache the result\n      actionsCache.set(cacheKey, {\n        data: unifiedActions,\n        timestamp: Date.now(),\n      });\n\n      setActionsList(unifiedActions);\n    } catch (error) {\n      console.error('❌ useUnifiedActionList: Error loading unified actions', {\n        error,\n        locale: i18n.resolvedLanguage,\n        gameMode,\n        cacheKey,\n      });\n      setActionsList({});\n    } finally {\n      setIsLoading(false);\n    }\n  }, [\n    gameMode,\n    i18n.resolvedLanguage,\n    cacheKey,\n    t,\n    currentLanguageMigrated,\n    isHealthy,\n    recoveryAttempted,\n    forceRecovery,\n  ]);\n\n  useEffect(() => {\n    if (cacheKey && currentLanguageMigrated) {\n      loadUnifiedActions();\n    }\n  }, [loadUnifiedActions, cacheKey, currentLanguageMigrated, isHealthy]);\n\n  return { actionsList, isLoading };\n}\n"],"names":["shuffleArray","array","i","j","arraysEqual","arr1","arr2","element","index","getRoomSettingsMessage","settings","i18next","message","key","val","getSiteName","exportRoomSettings","formData","newSettings","settingKey","settingValue","handleUser","user","displayName","updateUser","__async","updatedUser","sendRoomSettingsMessage","roomSettings","sendMessage","MAX_GROUP_NAME_LENGTH","MAX_GROUP_LABEL_LENGTH","MAX_INTENSITY_LABEL_LENGTH","MIN_INTENSITY_VALUE","MAX_INTENSITY_VALUE","MIN_INTENSITIES_COUNT","MAX_INTENSITIES_COUNT","RESERVED_GROUP_NAMES","VALID_GROUP_TYPES","validateGroupName","name","_locale","_gameMode","_excludeId","errors","warnings","trimmedName","validateGroupLabel","label","t","validateGroupIntensities","intensities","usedValues","usedLabels","intensity","trimmedLabel","sortedValues","a","b","expectedValue","value","validateCustomGroup","group","excludeId","nameValidation","labelValidation","intensitiesValidation","isGroupNameUnique","error","logger","validateCustomTileWithGroups","tile","locale","gameMode","getCustomGroupByName","validIntensityValues","getValidationConstants","isValidRole","obj","role","getCustomTileCount","customTiles","actionsList","actionEntries","settingsDataFolder","acc","levels","actionKeys","level","entry","intensityArray","getSettingsMessage","reason","variation","actualRole","modifier","isOnlineMode","intensityNames","levelName","customGroup","groupData","groupLabel","finishRange","noCumPercent","ruinedPercent","normalPercent","activeOptions","option","optionText","customTileCount","exportSettings","sendGameSettingsMessage","_0","title","tiles","gameBoard","getOrCreateBoard","text","TileShuffleBag","__publicField","groupedTiles","shuffledTiles","groupName","bag","originalTiles","filterTilesByRole","groups","action","g","intensityCache","calculateIntensity","gameSize","maxIntensity","currentTile","cacheKey","cached","divider","result","buildTileContent","availableGroups","shuffleBag","selectedActions","currentGroup","groupSelection","frequency","calculatedIntensity","userSelectedLevels","targetIntensity","prev","curr","selectedTile","otherLevels","processAppendTiles","mainTile","appendGroups","appendTile","buildBoard","allTiles","size","mainGroups","selection","groupIndex","board","selectedMainGroups","finalDescription","addStartAndFinishTiles","startTile","finishDescription","finishTile","buildGameBoard","tileCount","getCustomGroups","getTiles","selectedGroupNames","_a","selectedGroups","availableGroupNames","missingGroups","relevantTiles","tilesWithContent","finalBoard","useGameBoard","useLiveQuery","getActiveBoard","updateSettings","useSettings","i18n","useTranslation","updateGameBoard","useCallback","data","_b","__spreadProps","__spreadValues","settingsBoardUpdated","roomTileCount","room","isPublic","isPublicRoom","finalGameMode","boardResult","upsertBoard","useRoomNavigate","useParams","navigate","useNavigate","formRoom","shouldNavigate","noLeadingSlash","updateRoomBackground","url","isValidURL","cleanFormData","cleanedData","cleanedSelectedActions","validationConstants","useSubmitGameSettings","useAuth","updateGameBoardTiles","getActiveTiles","messages","useMessages","createLocalSession","useLocalPlayers","handleRoomChange","currentRoomUpper","formDataRoomUpper","roomChanged","isPrivateRoom","privateBoardSizeChanged","submitSettings","newBoard","m","typedFormData","cleanedFormData","actionsCache","CACHE_TTL","UNIFIED_ACTION_CACHE_TTL","useUnifiedActionList","currentLanguageMigrated","isHealthy","forceRecovery","useMigration","setActionsList","useState","isLoading","setIsLoading","recoveryAttempted","setRecoveryAttempted","useEffect","handleLanguageChange","useMemo","loadUnifiedActions","e","allGroups","getAllAvailableGroups","unifiedActions","actions","finalType"],"mappings":"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"}