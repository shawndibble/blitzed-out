{"version":3,"mappings":"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","names":["logError","level","context","error","details","Error","message","String","safeLocalStorage","getItem","key","localStorage","setItem","value","removeItem","getJSON","item","JSON","parse","setJSON","stringify","withErrorHandling","async","operation","fallback","isMigrationInProgress","status","MIGRATION_IN_PROGRESS_KEY","Date","now","startedAt","getTime","STALE_LOCK_TIMEOUT","inProgress","setMigrationInProgress","toISOString","isLanguageMigrationInProgress","locale","CURRENT_LANGUAGE_MIGRATION_KEY","locales","includes","setLanguageMigrationInProgress","push","filter","l","length","setBackgroundMigrationInProgress","BACKGROUND_MIGRATION_IN_PROGRESS_KEY","markMigrationComplete","MIGRATION_KEY","version","MIGRATION_VERSION","completed","completedAt","markLanguageMigrated","bgStatus","BACKGROUND_MIGRATION_KEY","completedLanguages","completedSet","Set","add","Array","from","markBackgroundMigrationInProgress","isMigrationCompleted","isCurrentLanguageMigrationCompleted","SUPPORTED_LANGUAGES","every","lang","getMigrationStatus","main","background","resetMigrationStatus","checkAndHandleVersionChange","versionChanged","oldVersion","clearAllMigrationData","getCurrentLanguage","resolved","i18n","resolvedLanguage","currentLang","language","storedLanguage","navigator","browserLang","split","importActionFile","groupName","gameMode","actionFile","__variableDynamicImportRuntimeHelper","Object","assign","__vitePreload","import","__VITE_PRELOAD__","default","label","type","actions","intensities","keys","map","intensityName","index","id","isDefault","deterministicId","createDeterministicGroupId","customGroup","name","customTiles","actionList","entries","isArray","intensity","find","i","action","trim","group_id","tags","isEnabled","isCustom","addCustomGroupSafely","addCustomGroup","isDuplicateError","getNewTiles","tiles","tile","validateTilesHaveGroupId","existingTiles","getTiles","group","some","existing","importCustomTilesSafely","importCustomTiles","importGroupsForLocaleAndGameMode","groupNames","bundleFile","sort","getActionGroupNames","groupsImported","tilesImported","db","then","n","W","module","getCustomGroupByName","result","transaction","customGroups","newTiles","tilesAdded","cleanupDuplicateGroups","totalDuplicatesRemoved","gameModes","GAME_MODES","removeDuplicateGroups","migrateActionGroups","cleanupDuplicatesIfNeeded","_a","_b","_c","migrateCurrentLanguage","currentLocale","waitForMigrationCompletion","X","migrateRemainingLanguages","excludeLocale","isBackgroundMigrationInProgress","remainingLocales","Promise","resolve","setTimeout","BACKGROUND_MIGRATION_DELAY","t","has","queueBackgroundMigration","window","requestIdleCallback","timeout","IDLE_CALLBACK_TIMEOUT","QUEUE_BACKGROUND_MIGRATION_DELAY","ensureLanguageMigrated","runMigrationIfNeeded","success","forceFreshMigration","clear","checkInProgress","operationName","startTime","MIGRATION_TIMEOUT"],"ignoreList":[],"sources":["../../src/services/migration/errorHandling.ts","../../src/services/migration/statusManager.ts","../../src/services/migration/versionManager.ts","../../src/services/migration/fileDiscovery.ts","../../src/services/migration/importOperations.ts","../../src/services/migration/index.ts"],"sourcesContent":["/**\n * Centralized error handling utilities for the migration service\n */\n\nexport type ErrorLevel = 'debug' | 'warn' | 'error';\n\n/**\n * Standardized error logging with consistent format\n */\nexport const logError = (\n  level: ErrorLevel,\n  context: string,\n  error: unknown,\n  details?: any\n): void => {\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  const logMessage = `[Migration ${context}] ${errorMessage}`;\n\n  if (details) {\n    console[level](logMessage, details);\n  } else {\n    console[level](logMessage);\n  }\n};\n\n/**\n * Safe localStorage operation wrapper\n */\nexport const safeLocalStorage = {\n  getItem: (key: string): string | null => {\n    try {\n      return localStorage.getItem(key);\n    } catch (error) {\n      logError('warn', 'localStorage.getItem', error, { key });\n      return null;\n    }\n  },\n\n  setItem: (key: string, value: string): boolean => {\n    try {\n      localStorage.setItem(key, value);\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.setItem', error, { key });\n      return false;\n    }\n  },\n\n  removeItem: (key: string): boolean => {\n    try {\n      localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.removeItem', error, { key });\n      return false;\n    }\n  },\n\n  getJSON: <T>(key: string): T | null => {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      logError('warn', 'localStorage.getJSON', error, { key });\n      return null;\n    }\n  },\n\n  setJSON: (key: string, value: any): boolean => {\n    try {\n      localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.setJSON', error, { key });\n      return false;\n    }\n  },\n};\n\n/**\n * Async operation wrapper with consistent error handling\n */\nexport const withErrorHandling = async <T>(\n  operation: () => Promise<T>,\n  context: string,\n  fallback?: T\n): Promise<T | null> => {\n  try {\n    return await operation();\n  } catch (error) {\n    logError('error', context, error);\n    return fallback ?? null;\n  }\n};\n\n/**\n * Check if an error indicates a duplicate/conflict that can be safely ignored\n */\nexport const isDuplicateError = (error: unknown): boolean => {\n  if (error instanceof Error) {\n    return (\n      error.message.includes('already exists') ||\n      error.message.includes('duplicate') ||\n      error.message.includes('unique constraint')\n    );\n  }\n  return false;\n};\n","/**\n * Status management module for localStorage-based migration tracking\n */\n\nimport {\n  MIGRATION_KEY,\n  BACKGROUND_MIGRATION_KEY,\n  MIGRATION_IN_PROGRESS_KEY,\n  CURRENT_LANGUAGE_MIGRATION_KEY,\n  BACKGROUND_MIGRATION_IN_PROGRESS_KEY,\n  MIGRATION_VERSION,\n  STALE_LOCK_TIMEOUT,\n  SUPPORTED_LANGUAGES,\n} from './constants';\nimport {\n  MigrationStatus,\n  BackgroundMigrationStatus,\n  MigrationLockStatus,\n  LanguageMigrationStatus,\n  MigrationStatusSnapshot,\n} from './types';\nimport { safeLocalStorage, logError } from './errorHandling';\n\n/**\n * Check if main migration is in progress\n */\nexport const isMigrationInProgress = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationLockStatus>(MIGRATION_IN_PROGRESS_KEY);\n  if (!status) return false;\n\n  // Auto-cleanup stale locks\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT) {\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n    return false;\n  }\n\n  return status.inProgress;\n};\n\n/**\n * Set main migration progress status\n */\nexport const setMigrationInProgress = (inProgress: boolean): void => {\n  if (inProgress) {\n    const status: MigrationLockStatus = {\n      inProgress: true,\n      startedAt: new Date().toISOString(),\n    };\n    safeLocalStorage.setJSON(MIGRATION_IN_PROGRESS_KEY, status);\n  } else {\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n  }\n};\n\n/**\n * Check if language migration is in progress\n */\nexport const isLanguageMigrationInProgress = (locale: string): boolean => {\n  const status = safeLocalStorage.getJSON<LanguageMigrationStatus>(CURRENT_LANGUAGE_MIGRATION_KEY);\n  if (!status) return false;\n\n  // Auto-cleanup stale locks\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT) {\n    safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    return false;\n  }\n\n  return status.locales && status.locales.includes(locale);\n};\n\n/**\n * Set language migration progress status\n */\nexport const setLanguageMigrationInProgress = (locale: string, inProgress: boolean): void => {\n  const status = safeLocalStorage.getJSON<LanguageMigrationStatus>(\n    CURRENT_LANGUAGE_MIGRATION_KEY\n  ) || {\n    locales: [],\n    startedAt: new Date().toISOString(),\n  };\n\n  if (inProgress) {\n    if (!status.locales.includes(locale)) {\n      status.locales.push(locale);\n      status.startedAt = new Date().toISOString();\n    }\n  } else {\n    status.locales = status.locales.filter((l) => l !== locale);\n    if (status.locales.length === 0) {\n      safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n      return;\n    }\n  }\n\n  safeLocalStorage.setJSON(CURRENT_LANGUAGE_MIGRATION_KEY, status);\n};\n\n/**\n * Check if background migration is in progress\n */\nexport const isBackgroundMigrationInProgress = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationLockStatus>(\n    BACKGROUND_MIGRATION_IN_PROGRESS_KEY\n  );\n  if (!status) return false;\n\n  // Auto-cleanup stale locks (longer timeout for background operations)\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT * 2) {\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n    return false;\n  }\n\n  return status.inProgress;\n};\n\n/**\n * Set background migration progress status\n */\nexport const setBackgroundMigrationInProgress = (inProgress: boolean): void => {\n  if (inProgress) {\n    const status: MigrationLockStatus = {\n      inProgress: true,\n      startedAt: new Date().toISOString(),\n    };\n    safeLocalStorage.setJSON(BACKGROUND_MIGRATION_IN_PROGRESS_KEY, status);\n  } else {\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n  }\n};\n\n/**\n * Mark migration as completed\n */\nexport const markMigrationComplete = (): void => {\n  const status: MigrationStatus = {\n    version: MIGRATION_VERSION,\n    completed: true,\n    completedAt: new Date(),\n  };\n  safeLocalStorage.setJSON(MIGRATION_KEY, status);\n};\n\n/**\n * Mark a specific language as migrated in background status\n */\nexport const markLanguageMigrated = (locale: string): void => {\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(\n    BACKGROUND_MIGRATION_KEY\n  ) || {\n    version: MIGRATION_VERSION,\n    completedLanguages: [],\n    inProgress: false,\n  };\n\n  // Use Set to ensure uniqueness and atomic update\n  const completedSet = new Set(bgStatus.completedLanguages);\n  completedSet.add(locale);\n  bgStatus.completedLanguages = Array.from(completedSet);\n\n  safeLocalStorage.setJSON(BACKGROUND_MIGRATION_KEY, bgStatus);\n};\n\n/**\n * Mark background migration as in progress\n */\nexport const markBackgroundMigrationInProgress = (inProgress: boolean): void => {\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(\n    BACKGROUND_MIGRATION_KEY\n  ) || {\n    version: MIGRATION_VERSION,\n    completedLanguages: [],\n    inProgress: false,\n  };\n\n  bgStatus.inProgress = inProgress;\n  if (inProgress) {\n    bgStatus.startedAt = new Date();\n  } else {\n    bgStatus.completedAt = new Date();\n  }\n\n  safeLocalStorage.setJSON(BACKGROUND_MIGRATION_KEY, bgStatus);\n};\n\n/**\n * Check if migration has been completed\n */\nexport const isMigrationCompleted = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n  if (!status) return false;\n\n  return status.completed && status.version === MIGRATION_VERSION;\n};\n\n/**\n * Check if current language migration has been completed\n */\nexport const isCurrentLanguageMigrationCompleted = (locale: string): boolean => {\n  // Check background migration status for specific language\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(BACKGROUND_MIGRATION_KEY);\n\n  if (bgStatus && bgStatus.completedLanguages.includes(locale)) {\n    return true;\n  }\n\n  // Fallback: check if full migration is complete AND all languages are done\n  const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n  if (status && status.completed && status.version === MIGRATION_VERSION) {\n    // Only return true if this is a full migration (not just current language)\n    if (bgStatus) {\n      return SUPPORTED_LANGUAGES.every((lang) => bgStatus.completedLanguages.includes(lang));\n    }\n    // If no background status, assume full migration means all languages are done\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Get migration status for debugging\n */\nexport const getMigrationStatus = (): MigrationStatusSnapshot => {\n  return {\n    main: safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY),\n    background: safeLocalStorage.getJSON<BackgroundMigrationStatus>(BACKGROUND_MIGRATION_KEY),\n  };\n};\n\n/**\n * Reset migration status (for debugging/development)\n */\nexport const resetMigrationStatus = (): void => {\n  try {\n    safeLocalStorage.removeItem(MIGRATION_KEY);\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n    safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n  } catch (error) {\n    logError('error', 'resetMigrationStatus', error);\n  }\n};\n","/**\n * Version management module for handling version checks and updates\n */\n\nimport {\n  MIGRATION_KEY,\n  BACKGROUND_MIGRATION_KEY,\n  MIGRATION_IN_PROGRESS_KEY,\n  CURRENT_LANGUAGE_MIGRATION_KEY,\n  BACKGROUND_MIGRATION_IN_PROGRESS_KEY,\n  MIGRATION_VERSION,\n} from './constants';\nimport { MigrationStatus, VersionCheckResult } from './types';\nimport { safeLocalStorage, logError } from './errorHandling';\n\n/**\n * Check if migration version has changed and clear outdated data\n */\nexport const checkAndHandleVersionChange = (): VersionCheckResult => {\n  try {\n    const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n    if (!status) {\n      return { versionChanged: false };\n    }\n\n    const oldVersion = status.version;\n    const versionChanged = oldVersion !== MIGRATION_VERSION;\n\n    if (versionChanged) {\n      // Clear all migration-related localStorage\n      clearAllMigrationData();\n      return { versionChanged: true, oldVersion };\n    }\n\n    return { versionChanged: false, oldVersion };\n  } catch (error) {\n    logError('error', 'checkAndHandleVersionChange', error);\n    return { versionChanged: false };\n  }\n};\n\n/**\n * Clear all migration-related data from localStorage\n */\nexport const clearAllMigrationData = (): void => {\n  safeLocalStorage.removeItem(MIGRATION_KEY);\n  safeLocalStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n  safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n  safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n  safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n};\n\n/**\n * Get current migration version\n */\nexport const getCurrentMigrationVersion = (): string => {\n  return MIGRATION_VERSION;\n};\n\n/**\n * Check if a version change requires data migration\n */\nexport const requiresDataMigration = (oldVersion?: string): boolean => {\n  if (!oldVersion) return true;\n\n  // Add logic here for version-specific migration requirements\n  // For now, any version change requires migration\n  return oldVersion !== MIGRATION_VERSION;\n};\n","/**\n * File discovery utilities for dynamic locale and game mode detection\n */\n\nimport { SUPPORTED_LANGUAGES } from './constants';\nimport { logError } from './errorHandling';\nimport i18n from '@/i18n';\n\n/**\n * Get current user language from i18next with fallbacks\n */\nexport const getCurrentLanguage = async (): Promise<string> => {\n  try {\n    // First try: get current language from i18next using proper API\n    const resolved = i18n.resolvedLanguage;\n    if (resolved !== undefined) {\n      return resolved;\n    }\n\n    // Second try: get language from i18next instance\n    const currentLang = i18n.language;\n    if (currentLang !== undefined) {\n      return currentLang;\n    }\n\n    // Third try: localStorage fallback\n    const storedLanguage = localStorage.getItem('i18nextLng');\n    if (storedLanguage && storedLanguage !== 'undefined') {\n      return storedLanguage;\n    }\n\n    // Fourth try: browser language with proper validation\n    if (typeof navigator !== 'undefined' && navigator.language) {\n      const browserLang = navigator.language.split('-')[0];\n      if (SUPPORTED_LANGUAGES.includes(browserLang as (typeof SUPPORTED_LANGUAGES)[number])) {\n        return browserLang;\n      }\n    }\n\n    // Final fallback: English\n    return 'en';\n  } catch (error) {\n    logError('error', 'getCurrentLanguage', error);\n    return 'en'; // Safe fallback\n  }\n};\n\n/**\n * Dynamically discover action group names for a specific locale and game mode\n * Uses bundled translation files for better performance\n */\nexport const getActionGroupNames = async (locale: string, gameMode: string): Promise<string[]> => {\n  try {\n    // Import the bundle for the specified locale and game mode\n    const bundleFile = await import(`@/locales/${locale}/${gameMode}-bundle.json`);\n\n    // Return all keys (group names) from the bundle\n    return Object.keys(bundleFile).sort(); // Sort for consistent ordering\n  } catch (error) {\n    // Bundle doesn't exist or can't be imported\n    logError('warn', `getActionGroupNames: Bundle not found for ${locale}/${gameMode}`, error);\n    return [];\n  }\n};\n","/**\n * Import operations module for handling action file imports and data conversion\n */\n\nimport { addCustomGroup, getCustomGroupByName, removeDuplicateGroups } from '@/stores/customGroups';\nimport { importCustomTiles, getTiles } from '@/stores/customTiles';\nimport { CustomGroupBase } from '@/types/customGroups';\nimport { CustomTileBase } from '@/types/customTiles';\nimport { ImportResult } from './types';\nimport { logError, withErrorHandling, isDuplicateError } from './errorHandling';\nimport { getActionGroupNames } from './fileDiscovery';\nimport { createDeterministicGroupId } from './groupIdMigration';\nimport { GAME_MODES, SUPPORTED_LANGUAGES } from './constants';\n\n/**\n * Import a single action file and convert it to a custom group with custom tiles\n */\nexport const importActionFile = async (\n  groupName: string,\n  locale: string,\n  gameMode: string\n): Promise<{ customGroup: CustomGroupBase; customTiles: CustomTileBase[] } | null> => {\n  return withErrorHandling(async () => {\n    // Import from bundled translation files for better performance\n    const bundleFile = await import(`@/locales/${locale}/${gameMode}-bundle.json`);\n    const bundle = bundleFile.default;\n    const actionFile = bundle[groupName];\n\n    if (!actionFile) {\n      throw new Error(`Group \"${groupName}\" not found in ${locale}/${gameMode} bundle`);\n    }\n\n    // Extract data from the JSON file\n    const label = actionFile.label || groupName;\n    const type = actionFile.type || 'action';\n    const actions = actionFile.actions || {};\n\n    // Convert actions object to intensities array\n    const intensities = Object.keys(actions).map((intensityName, index) => ({\n      id: `${groupName}-${index + 1}`,\n      label: intensityName,\n      value: index + 1,\n      isDefault: true,\n    }));\n\n    // Create deterministic ID for default groups to ensure consistency across devices\n    const deterministicId = createDeterministicGroupId(groupName, locale, gameMode);\n\n    // Create the custom group with deterministic ID\n    const customGroup: CustomGroupBase & { id?: string } = {\n      id: deterministicId, // Set deterministic ID for sync consistency\n      name: groupName,\n      label,\n      intensities,\n      type,\n      isDefault: true,\n      locale,\n      gameMode,\n    };\n\n    // Create custom tiles from the actions\n    const customTiles: CustomTileBase[] = [];\n\n    for (const [intensityName, actionList] of Object.entries(actions)) {\n      if (!Array.isArray(actionList)) continue;\n\n      // Find the intensity value for this intensity name\n      const intensity = intensities.find((i) => i.label === intensityName);\n      if (!intensity) continue;\n\n      // Create a tile for each action in this intensity\n      for (const action of actionList) {\n        if (typeof action === 'string' && action.trim()) {\n          customTiles.push({\n            group_id: deterministicId, // Assign the deterministic group ID\n            intensity: intensity.value,\n            action: action.trim(),\n            tags: ['default'], // Mark as default tiles from JSON files\n            isEnabled: 1,\n            isCustom: 0, // These are default tiles, not custom\n          });\n        }\n      }\n    }\n\n    return { customGroup, customTiles };\n  }, `importActionFile:${groupName}:${locale}/${gameMode}`);\n};\n\n/**\n * Add a custom group with error handling for duplicates\n */\nconst addCustomGroupSafely = async (customGroup: CustomGroupBase): Promise<boolean> => {\n  try {\n    await addCustomGroup(customGroup);\n    return true;\n  } catch (error) {\n    if (isDuplicateError(error)) {\n      // Group was already added by concurrent process, this is ok\n      return false;\n    }\n    throw error; // Re-throw other errors\n  }\n};\n\n/**\n * Validates that all tiles have proper group_id assignment\n */\nconst validateTilesHaveGroupId = (tiles: CustomTileBase[]): void => {\n  for (const tile of tiles) {\n    if (!tile.group_id || !tile.group_id.trim()) {\n      throw new Error(`Tile missing group_id during import: ${tile.action}`);\n    }\n  }\n};\n\n/**\n * Filter out existing tiles to prevent duplicates using group_id-based matching\n */\nconst getNewTiles = async (\n  customTiles: CustomTileBase[],\n  locale: string,\n  gameMode: string,\n  groupName: string\n): Promise<CustomTileBase[]> => {\n  try {\n    // Validate all tiles have proper group_id\n    validateTilesHaveGroupId(customTiles);\n\n    const existingTiles = await getTiles({ locale, gameMode, group: groupName });\n\n    if (!existingTiles || !Array.isArray(existingTiles)) {\n      return customTiles; // If no existing tiles, all tiles are new\n    }\n\n    return customTiles.filter((tile) => {\n      return !existingTiles.some(\n        (existing) =>\n          existing.group_id === tile.group_id &&\n          existing.intensity === tile.intensity &&\n          existing.action === tile.action\n      );\n    });\n  } catch (error) {\n    logError('warn', `getNewTiles:${groupName}:${locale}/${gameMode}`, error);\n    return customTiles; // On error, import all tiles\n  }\n};\n\n/**\n * Import custom tiles with duplicate handling\n */\nconst importCustomTilesSafely = async (tiles: CustomTileBase[]): Promise<number> => {\n  if (tiles.length === 0) return 0;\n\n  try {\n    await importCustomTiles(tiles);\n    return tiles.length;\n  } catch (error) {\n    logError('warn', 'importCustomTilesSafely', error);\n    // Continue processing, don't fail the entire migration\n    return 0;\n  }\n};\n\n/**\n * Import all action groups for a specific locale and game mode\n * Uses Dexie transactions to prevent cursor invalidation during concurrent operations\n */\nexport const importGroupsForLocaleAndGameMode = async (\n  locale: string,\n  gameMode: string\n): Promise<ImportResult> => {\n  const groupNames = await getActionGroupNames(locale, gameMode);\n  let groupsImported = 0;\n  let tilesImported = 0;\n\n  // Import Dexie database for transaction usage\n  const db = await import('@/stores/store').then((module) => module.default);\n\n  // Process each group individually to avoid transaction timeouts\n  for (const groupName of groupNames) {\n    try {\n      // Check if group already exists to prevent duplicates\n      const existingGroup = await getCustomGroupByName(groupName, locale, gameMode);\n      if (existingGroup) {\n        continue; // Group already exists, skip\n      }\n\n      const result = await importActionFile(groupName, locale, gameMode);\n      if (!result) continue;\n\n      const { customGroup, customTiles } = result;\n\n      // Process each group in its own transaction to prevent timeouts\n      await db.transaction('rw', [db.customGroups, db.customTiles], async () => {\n        // Add the custom group with error handling for duplicates\n        const groupAdded = await addCustomGroupSafely(customGroup);\n        if (groupAdded) {\n          groupsImported++;\n        }\n\n        // Add the custom tiles if there are any\n        if (customTiles.length > 0) {\n          const newTiles = await getNewTiles(customTiles, locale, gameMode, groupName);\n          const tilesAdded = await importCustomTilesSafely(newTiles);\n          tilesImported += tilesAdded;\n        }\n      });\n    } catch (error) {\n      logError(\n        'error',\n        `importGroupsForLocaleAndGameMode:${groupName}:${locale}/${gameMode}`,\n        error\n      );\n    }\n  }\n\n  return { groupsImported, tilesImported };\n};\n\n/**\n * Clean up duplicate groups across all locales and game modes\n */\nexport const cleanupDuplicateGroups = async (): Promise<number> => {\n  const result = await withErrorHandling(\n    async () => {\n      const locales = SUPPORTED_LANGUAGES;\n      let totalDuplicatesRemoved = 0;\n\n      for (const locale of locales) {\n        const gameModes = GAME_MODES;\n        for (const gameMode of gameModes) {\n          const duplicatesRemoved = await removeDuplicateGroups(locale, gameMode);\n          totalDuplicatesRemoved += duplicatesRemoved;\n        }\n      }\n\n      return totalDuplicatesRemoved;\n    },\n    'cleanupDuplicateGroups',\n    0\n  );\n\n  return result !== null ? result : 0;\n};\n","/**\n * Main migration service that orchestrates all migration modules\n *\n * This is the refactored migration service broken down into focused modules:\n * - types: Type definitions and interfaces\n * - constants: Configuration and constant values\n * - errorHandling: Centralized error handling patterns\n * - statusManager: localStorage-based migration tracking\n * - versionManager: Version checking and updates\n * - fileDiscovery: Dynamic file and locale discovery\n * - importOperations: File importing and data conversion\n * - validationUtils: Integrity checks and validation\n */\n\nimport {\n  MIGRATION_TIMEOUT,\n  BACKGROUND_MIGRATION_DELAY,\n  QUEUE_BACKGROUND_MIGRATION_DELAY,\n  IDLE_CALLBACK_TIMEOUT,\n  SUPPORTED_LANGUAGES,\n  GAME_MODES,\n} from './constants';\nimport {\n  isMigrationInProgress,\n  setMigrationInProgress,\n  isLanguageMigrationInProgress,\n  setLanguageMigrationInProgress,\n  isBackgroundMigrationInProgress,\n  setBackgroundMigrationInProgress,\n  markMigrationComplete,\n  markLanguageMigrated,\n  markBackgroundMigrationInProgress,\n  isMigrationCompleted,\n  isCurrentLanguageMigrationCompleted,\n  getMigrationStatus,\n  resetMigrationStatus,\n} from './statusManager';\nimport { checkAndHandleVersionChange } from './versionManager';\nimport { getCurrentLanguage } from './fileDiscovery';\nimport { importGroupsForLocaleAndGameMode, cleanupDuplicateGroups } from './importOperations';\nimport { withErrorHandling, logError, safeLocalStorage } from './errorHandling';\n\n// Re-export types for external consumption\nexport type {\n  MigrationStatus,\n  BackgroundMigrationStatus,\n  ImportResult,\n  VersionCheckResult,\n  MigrationStatusSnapshot,\n} from './types';\n\n// Re-export key functions that are used by external components\nexport {\n  isMigrationCompleted,\n  isCurrentLanguageMigrationCompleted,\n  getMigrationStatus,\n  resetMigrationStatus,\n} from './statusManager';\n\nexport { checkAndHandleVersionChange } from './versionManager';\nexport { verifyMigrationIntegrity, fixMigrationStatusCorruption } from './validationUtils';\n\n/**\n * Main migration function with dynamic discovery\n */\nexport const migrateActionGroups = async (): Promise<boolean> => {\n  const result = await withErrorHandling(\n    async () => {\n      // Get available locales\n      const locales = SUPPORTED_LANGUAGES;\n\n      for (const locale of locales) {\n        // Use known game modes\n        const gameModes = GAME_MODES;\n\n        for (const gameMode of gameModes) {\n          try {\n            await importGroupsForLocaleAndGameMode(locale, gameMode);\n          } catch (error) {\n            logError('error', `migrateActionGroups:${locale}/${gameMode}`, error);\n          }\n        }\n      }\n\n      // Clean up any duplicates that might exist from previous migrations\n      await cleanupDuplicateGroups();\n\n      markMigrationComplete();\n      return true;\n    },\n    'migrateActionGroups',\n    false\n  );\n\n  return result !== null ? result : false;\n};\n\n/**\n * Clean up duplicate groups across all locales and game modes\n * Can be called independently of migration\n */\nexport const cleanupDuplicatesIfNeeded = async (): Promise<number> => {\n  const result = await withErrorHandling(\n    async () => {\n      const status = getMigrationStatus();\n      if (status.main?.completed || status.background?.completedLanguages?.length) {\n        return await cleanupDuplicateGroups();\n      }\n      return 0;\n    },\n    'cleanupDuplicatesIfNeeded',\n    0\n  );\n\n  return result !== null ? result : 0;\n};\n\n/**\n * Migration function for current language only (fast path)\n */\nexport const migrateCurrentLanguage = async (locale?: string): Promise<boolean> => {\n  const currentLocale = locale || (await getCurrentLanguage());\n\n  try {\n    // Check if this language is already migrated\n    if (isCurrentLanguageMigrationCompleted(currentLocale)) {\n      return true;\n    }\n\n    // Prevent concurrent migrations for the same language\n    if (isLanguageMigrationInProgress(currentLocale)) {\n      // Wait for the current migration to complete with timeout\n      await waitForMigrationCompletion(\n        () => isLanguageMigrationInProgress(currentLocale),\n        `${currentLocale} migration`\n      );\n      // Re-check if migration is now completed\n      return isCurrentLanguageMigrationCompleted(currentLocale);\n    }\n\n    setLanguageMigrationInProgress(currentLocale, true);\n\n    try {\n      const gameModes = GAME_MODES;\n\n      for (const gameMode of gameModes) {\n        try {\n          await importGroupsForLocaleAndGameMode(currentLocale, gameMode);\n        } catch (error) {\n          logError('error', `migrateCurrentLanguage:${currentLocale}/${gameMode}`, error);\n        }\n      }\n\n      // Clean up duplicates for current language\n      for (const gameMode of gameModes) {\n        try {\n          const { removeDuplicateGroups } = await import('@/stores/customGroups');\n          await removeDuplicateGroups(currentLocale, gameMode);\n        } catch (error) {\n          logError('warn', `cleanup:${currentLocale}/${gameMode}`, error);\n        }\n      }\n\n      // Mark this language as migrated\n      markLanguageMigrated(currentLocale);\n      return true;\n    } finally {\n      setLanguageMigrationInProgress(currentLocale, false);\n    }\n  } catch (error) {\n    logError('error', 'migrateCurrentLanguage', error);\n    setLanguageMigrationInProgress(currentLocale, false);\n    return false;\n  }\n};\n\n/**\n * Background migration for remaining languages\n */\nexport const migrateRemainingLanguages = async (excludeLocale?: string): Promise<void> => {\n  try {\n    // Prevent concurrent background migrations\n    if (isBackgroundMigrationInProgress()) {\n      return;\n    }\n\n    setBackgroundMigrationInProgress(true);\n    const currentLocale = excludeLocale || (await getCurrentLanguage());\n    markBackgroundMigrationInProgress(true);\n\n    const allLocales = SUPPORTED_LANGUAGES;\n    const remainingLocales = allLocales.filter((locale) => locale !== currentLocale);\n\n    for (const locale of remainingLocales) {\n      // Check if already migrated\n      if (isCurrentLanguageMigrationCompleted(locale)) {\n        continue;\n      }\n\n      try {\n        const gameModes = GAME_MODES;\n\n        for (const gameMode of gameModes) {\n          await importGroupsForLocaleAndGameMode(locale, gameMode);\n          // Add small delay to prevent blocking the main thread\n          await new Promise((resolve) => setTimeout(resolve, BACKGROUND_MIGRATION_DELAY));\n        }\n\n        // Clean up duplicates\n        for (const gameMode of gameModes) {\n          const { removeDuplicateGroups } = await import('@/stores/customGroups');\n          await removeDuplicateGroups(locale, gameMode);\n        }\n\n        markLanguageMigrated(locale);\n      } catch (error) {\n        logError('warn', `migrateRemainingLanguages:${locale}`, error);\n        // Continue with other languages even if one fails\n      }\n    }\n\n    markBackgroundMigrationInProgress(false);\n\n    // Check if all languages are now migrated\n    const { BACKGROUND_MIGRATION_KEY } = await import('./constants');\n    const bgStatus = safeLocalStorage.getJSON(BACKGROUND_MIGRATION_KEY);\n    const completedLanguages = new Set((bgStatus as any)?.completedLanguages || []);\n    const allLanguagesCompleted = SUPPORTED_LANGUAGES.every((lang) => completedLanguages.has(lang));\n\n    if (allLanguagesCompleted) {\n      markMigrationComplete(); // Mark full migration as complete\n    }\n  } catch (error) {\n    logError('error', 'migrateRemainingLanguages', error);\n    markBackgroundMigrationInProgress(false);\n    setBackgroundMigrationInProgress(false);\n  } finally {\n    setBackgroundMigrationInProgress(false);\n  }\n};\n\n/**\n * Queue background migration for remaining languages\n */\nexport const queueBackgroundMigration = (excludeLocale?: string): void => {\n  try {\n    if (typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function') {\n      window.requestIdleCallback(() => migrateRemainingLanguages(excludeLocale), {\n        timeout: IDLE_CALLBACK_TIMEOUT,\n      });\n    } else {\n      // Fallback for browsers without requestIdleCallback\n      setTimeout(() => migrateRemainingLanguages(excludeLocale), QUEUE_BACKGROUND_MIGRATION_DELAY);\n    }\n  } catch (error) {\n    logError('error', 'queueBackgroundMigration', error);\n  }\n};\n\n/**\n * Force migration for a specific language (useful when switching languages)\n */\nexport const ensureLanguageMigrated = async (locale: string): Promise<boolean> => {\n  try {\n    // Quick check first\n    const isCompleted = isCurrentLanguageMigrationCompleted(locale);\n    if (isCompleted) {\n      return true;\n    }\n\n    // If migration is in progress for this language, wait for it\n    if (isLanguageMigrationInProgress(locale)) {\n      await waitForMigrationCompletion(\n        () => isLanguageMigrationInProgress(locale),\n        `${locale} migration`\n      );\n      return isCurrentLanguageMigrationCompleted(locale);\n    }\n\n    return await migrateCurrentLanguage(locale);\n  } catch (error) {\n    logError('error', `ensureLanguageMigrated:${locale}`, error);\n    // Graceful fallback: allow the app to continue even if migration fails\n    logError('warn', 'Migration failed but app will continue', null, { locale });\n    return false;\n  }\n};\n\n/**\n * Run migration if needed (optimized for current language first)\n */\nexport const runMigrationIfNeeded = async (): Promise<boolean> => {\n  try {\n    // Check for version changes first\n    const { versionChanged } = checkAndHandleVersionChange();\n    if (versionChanged) {\n      // Version changed, force fresh migration\n    }\n\n    const currentLocale = await getCurrentLanguage();\n\n    // Check if the current language is already migrated\n    if (isCurrentLanguageMigrationCompleted(currentLocale)) {\n      return true;\n    }\n\n    // Prevent concurrent migrations\n    if (isMigrationInProgress()) {\n      await waitForMigrationCompletion(() => isMigrationInProgress(), 'main migration');\n      // Re-check if migration is now completed\n      return (\n        isMigrationCompleted() || isCurrentLanguageMigrationCompleted(await getCurrentLanguage())\n      );\n    }\n\n    setMigrationInProgress(true);\n\n    try {\n      // Fast path: migrate current language only\n      const success = await migrateCurrentLanguage(currentLocale);\n\n      if (success) {\n        // Queue background migration for other languages\n        queueBackgroundMigration(currentLocale);\n      }\n\n      return success;\n    } finally {\n      setMigrationInProgress(false);\n    }\n  } catch (error) {\n    logError('error', 'runMigrationIfNeeded', error);\n    setMigrationInProgress(false);\n    // Graceful fallback: allow app to continue even if migration fails\n    logError('warn', 'Migration failed but app will continue with existing data', null);\n    return false;\n  }\n};\n\n/**\n * Developer utility: Force a fresh migration by clearing all data\n */\nexport const forceFreshMigration = async (): Promise<void> => {\n  try {\n    // Clear all localStorage\n    resetMigrationStatus();\n\n    // Optionally clear Dexie database too for a completely fresh start\n    const db = await import('@/stores/store');\n    await db.default.customGroups.clear();\n    await db.default.customTiles.clear();\n  } catch (error) {\n    logError('error', 'forceFreshMigration', error);\n  }\n};\n\n/**\n * Wait for a migration to complete with timeout\n */\nconst waitForMigrationCompletion = async (\n  checkInProgress: () => boolean,\n  operationName: string\n): Promise<void> => {\n  const startTime = Date.now();\n\n  while (checkInProgress()) {\n    if (Date.now() - startTime > MIGRATION_TIMEOUT) {\n      logError(\n        'warn',\n        `Migration timeout: ${operationName} took longer than ${MIGRATION_TIMEOUT}ms`,\n        null\n      );\n      break;\n    }\n    await new Promise((resolve) => setTimeout(resolve, 50));\n  }\n};\n"],"file":"js/chunk-FtLujAFk.js"}