import{r as u}from"./chunk-gLqOAnAo.js";import{n as U,a as M}from"./chunk-D9KXFDlS.js";import{d as P,q as z}from"./chunk-Ce3NdNab.js";(function(){var n=typeof window!="undefined"?window:typeof global!="undefined"?global:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:{};n.SENTRY_RELEASE={id:"ba7d3cfce23f41097f343c1a83f9f2db3c72f794"}})();try{(function(){var n=typeof window!="undefined"?window:typeof global!="undefined"?global:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:{},r=new n.Error().stack;r&&(n._sentryDebugIds=n._sentryDebugIds||{},n._sentryDebugIds[r]="9f121c41-90b5-4d04-b216-8485b85c62d4",n._sentryDebugIdIdentifier="sentry-dbid-9f121c41-90b5-4d04-b216-8485b85c62d4")})()}catch(n){}var V=Object.defineProperty,B=(n,r,e)=>r in n?V(n,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[r]=e,L=(n,r,e)=>B(n,typeof r!="symbol"?r+"":r,e);const A=class S{constructor(){L(this,"currentSession",null)}static getInstance(){return S.instance||(S.instance=new S),S.instance}async createSession(r,e,s){try{this.validateSessionInput(r,e,s);const o=U(),t=Date.now(),l=e.map(f=>{var v,h;return{...f,location:(v=f.location)!=null?v:0,isFinished:(h=f.isFinished)!=null?h:!1}}),i={id:o,roomId:r,players:l,currentPlayerIndex:0,isActive:!0,createdAt:t,updatedAt:t,settings:{...s}},a={sessionId:i.id,roomId:i.roomId,players:i.players,currentPlayerIndex:i.currentPlayerIndex,isActive:i.isActive,createdAt:i.createdAt,updatedAt:i.updatedAt,settings:i.settings};return await P.localPlayerSessions.add(a),this.currentSession=i,i}catch(o){throw new Error(`Failed to create local player session: ${o instanceof Error?o.message:"Unknown error"}`)}}async getSession(r){try{if(!r)throw new Error("Session ID is required");const e=await P.localPlayerSessions.where("sessionId").equals(r).first();return e?this.convertDbSessionToSession(e):null}catch(e){throw new Error(`Failed to get session: ${e instanceof Error?e.message:"Unknown error"}`)}}async updateSession(r,e){var s;try{if(!r)throw new Error("Session ID is required");const o=await this.getSession(r);if(!o)throw new Error("Session not found");const t={...o,...e,id:r,createdAt:o.createdAt,updatedAt:Date.now()},l={roomId:t.roomId,players:t.players,currentPlayerIndex:t.currentPlayerIndex,isActive:t.isActive,updatedAt:t.updatedAt,settings:t.settings};return await P.localPlayerSessions.where("sessionId").equals(r).modify(l),((s=this.currentSession)==null?void 0:s.id)===r&&(this.currentSession=t),t}catch(o){throw new Error(`Failed to update session: ${o instanceof Error?o.message:"Unknown error"}`)}}async advanceLocalTurn(r){try{if(!r)throw new Error("Session ID is required");const e=await this.getSession(r);if(!e)throw new Error("Session not found");if(!e.isActive)throw new Error("Cannot advance turn on inactive session");if(e.players.length===0)throw new Error("No players in session");const s=(e.currentPlayerIndex+1)%e.players.length,o=e.players.map((l,i)=>({...l,isActive:i===s}));return(await this.updateSession(r,{players:o,currentPlayerIndex:s})).players[s]}catch(e){throw new Error(`Failed to advance turn: ${e instanceof Error?e.message:"Unknown error"}`)}}getCurrentSession(){return this.currentSession}async updatePlayerPosition(r,e,s,o=!1){try{if(!r)throw new Error("Session ID is required");if(!e)throw new Error("Player ID is required");if(s<0)throw new Error("Location must be non-negative");const t=await this.getSession(r);if(!t)throw new Error("Session not found");if(!t.isActive)throw new Error("Cannot update player position on inactive session");const l=t.players.findIndex(a=>a.id===e);if(l===-1)throw new Error(`Player with ID ${e} not found in session`);const i=[...t.players];return i[l]={...i[l],location:s,isFinished:o},await this.updateSession(r,{players:i}),i[l]}catch(t){throw new Error(`Failed to update player position: ${t instanceof Error?t.message:"Unknown error"}`)}}clearCurrentSession(){this.currentSession=null}validateSessionInput(r,e,s){if(!r||typeof r!="string")throw new Error("Valid room ID is required");if(!Array.isArray(e)||e.length<2||e.length>4)throw new Error("Session must have between 2 and 4 players");e.forEach((a,f)=>{if(!a.id||typeof a.id!="string")throw new Error(`Player at index ${f} must have a valid ID`);if(!a.name||typeof a.name!="string")throw new Error(`Player at index ${f} must have a valid name`);if(!["sub","dom","vers"].includes(a.role))throw new Error(`Player at index ${f} must have a valid role`);if(typeof a.location!="undefined"&&(typeof a.location!="number"||a.location<0))throw new Error(`Player at index ${f} must have a valid location (non-negative number)`)});const o=e.map(a=>a.id),t=new Set(o);if(o.length!==t.size)throw new Error("All players must have unique IDs");const l=e.map(a=>a.name.toLowerCase()),i=new Set(l);if(l.length!==i.size)throw new Error("All players must have unique names");if(!s||typeof s!="object")throw new Error("Valid settings object is required")}convertDbSessionToSession(r){return{id:r.sessionId,roomId:r.roomId,players:r.players,currentPlayerIndex:r.currentPlayerIndex,isActive:r.isActive,createdAt:r.createdAt,updatedAt:r.updatedAt,settings:r.settings}}};L(A,"instance");let j=A;const g=j.getInstance(),O=M()(z((n,r)=>({session:null,error:null,isLoading:!1,hasLocalPlayers:()=>{const e=r().session;return(e==null?void 0:e.isActive)===!0&&e.players.length>0},isLocalPlayerRoom:()=>{const e=r().session;return(e==null?void 0:e.isActive)===!0},getCurrentPlayer:()=>{const e=r().session;if(!(e!=null&&e.isActive)||!e.players||e.players.length===0)return null;const s=e.currentPlayerIndex||0,o=e.players[s];if(!o)return null;const t={...o};return typeof t.location!="number"&&(t.location=0),typeof t.isFinished!="boolean"&&(t.isFinished=!1),t},setSession:e=>{const s=e?r()._migrateSession(e):null;n({session:s,error:null})},_migrateSession:e=>{if(!e||!e.players)return e;const s=e.players.map(o=>({...o,location:typeof o.location=="number"?o.location:0,isFinished:typeof o.isFinished=="boolean"?o.isFinished:!1,sound:o.sound||""}));return{...e,players:s}},clearSession:()=>{g.clearCurrentSession(),n({session:null,error:null})},setError:e=>{n({error:e,isLoading:!1})},setLoading:e=>{n({isLoading:e})},initSession:async(e,s,o)=>{try{n({isLoading:!0,error:null});const t=await g.createSession(e,s,o);n({session:t,isLoading:!1,error:null})}catch(t){const l=t instanceof Error?t.message:"Failed to create session";n({error:l,isLoading:!1,session:null})}},loadSession:async e=>{try{n({isLoading:!0,error:null});const s=await g.getSession(e);n({session:s,isLoading:!1,error:null})}catch(s){const o=s instanceof Error?s.message:"Failed to load session";n({error:o,isLoading:!1,session:null})}},nextLocalPlayer:async()=>{try{n({isLoading:!0,error:null});const e=r().session;if(!e)throw new Error("No active session");await g.advanceLocalTurn(e.id);const s=await g.getSession(e.id);n({session:s,isLoading:!1,error:null})}catch(e){const s=e instanceof Error?e.message:"Failed to advance turn";n({error:s,isLoading:!1})}},updateSessionSettings:async e=>{try{n({isLoading:!0,error:null});const s=r().session;if(!s)throw new Error("No active session");const o=await g.updateSession(s.id,{settings:e});n({session:o,isLoading:!1,error:null})}catch(s){const o=s instanceof Error?s.message:"Failed to update session settings";n({error:o,isLoading:!1})}}}),{name:"local-player-store",partialize:n=>({session:n.session}),onRehydrateStorage:()=>n=>{n&&(n.isLoading=!1,n.error=null)}}));function J(){var n;const{session:r,error:e,isLoading:s,hasLocalPlayers:o,isLocalPlayerRoom:t,getCurrentPlayer:l,setSession:i,clearSession:a,setError:f,setLoading:v,initSession:h,loadSession:E,nextLocalPlayer:b,updateSessionSettings:I}=O(),d=u.useMemo(()=>(r==null?void 0:r.players)||[],[r==null?void 0:r.players]),x=l(),y=(n=r==null?void 0:r.currentPlayerIndex)!=null?n:-1,C=r==null?void 0:r.settings,D=u.useCallback(async(c,w,R)=>{await h(c,w,R)},[h]),F=u.useCallback(async c=>{await E(c)},[E]),_=u.useCallback(async()=>{await b()},[b]),q=u.useCallback(()=>{a()},[a]),k=u.useCallback(async c=>{await I(c)},[I]),p=u.useCallback(c=>c>=0&&c<d.length?d[c]:null,[d]),m=u.useCallback(c=>d.find(w=>w.id===c)||null,[d]),T=u.useCallback(c=>{const w=m(c);return(w==null?void 0:w.isActive)===!0},[m]),$=u.useCallback(()=>{if(d.length===0)return null;const c=(y+1)%d.length;return p(c)},[d,y,p]),N=u.useCallback(()=>{if(d.length===0)return null;const c=y===0?d.length-1:y-1;return p(c)},[d,y,p]);return{session:r,localPlayers:d,currentPlayer:x,currentPlayerIndex:y,sessionSettings:C,error:e,isLoading:s,hasLocalPlayers:o(),isLocalPlayerRoom:t(),playerCount:d.length,isValidSession:(r==null?void 0:r.isActive)===!0&&d.length>=2,createLocalSession:D,loadLocalSession:F,clearLocalSession:q,advanceToNextPlayer:_,updateSettings:k,getPlayerByIndex:p,getPlayerById:m,isPlayerActive:T,getNextPlayer:$,getPreviousPlayer:N,setSession:i,setError:f,setLoading:v}}export{O as a,g as l,J as u};
//# sourceMappingURL=chunk-BRW-j_h2.js.map
