{"version":3,"mappings":"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","names":["customTiles","db","_primKey","obj","_transaction","importCustomTiles","record","recordData","tile","createFilteredQuery","filters","possibleFilters","query","key","value","getTiles","error","getPaginatedTiles","page","limit","count","offset","createBaseTileQuery","locale","gameMode","getTileCountsByGroup","tags","tag","groups","group","intensity","getActiveTiles","currentLocale","i18next","tiles","addCustomTile","updateCustomTile","id","toggleCustomTile","deleteAllIsCustomTiles","deleteCustomTile","createTilesByGroupQuery","groupName","countTilesByGroup","deleteCustomTilesByGroup","gameBoard","getBoards","getActiveBoard","_a","addBoard","updateBoard","board","upsertBoard","_b","newData","deactivateAllBoards","activateBoard","updatedBoards","deleteBoard","DEFAULT_NONE_OPTION","UNIFIED_ACTION_CACHE_TTL","SYNC_DELAY_MS","getFirestore","syncCustomTilesToFirebase","user","getAuth","setDoc","doc","syncCustomGroupsToFirebase","customGroups","getCustomGroups","syncGameBoardsToFirebase","gameBoards","syncSettingsToFirebase","settings","useSettingsStore","localPlayers","settingsForFirebase","syncAllDataToFirebase","syncDataFromFirebase","userDocRef","userDoc","getDoc","userData","deleteAllCustomTiles","resolve","deleteAllCustomGroups","importCustomGroups","updateSettings","firebaseSettings","syncIntervalId","startPeriodicSync","intervalMinutes","stopPeriodicSync","intervalMs","auth","AuthContext","React","AuthProvider","props","setUser","useState","loading","setLoading","initializing","setInitializing","setError","syncStatus","setSyncStatus","syncTimeoutRef","useRef","authInitializedRef","performSync","useCallback","syncFunction","err","login","displayName","loggedInUser","loginAnonymously","errorMessage","getErrorMessage","loginEmail","email","password","loginWithEmail","loginGoogle","loginWithGoogle","register","registeredUser","registerWithEmail","forgotPassword","resetPassword","convertToRegistered","convertedUser","convertAnonymousAccount","updateUser","updatedUser","updateDisplayName","logoutUser","syncPromise","timeoutPromise","logout","wipeAllAppDataAndReload","wipeAllAppData","syncData","useEffect","unsubscribe","deferSync","globalWindow","useMemo","AllProviders","lazy","__vitePreload","n","RouterSetup","AppContent","useContext","AppSkeleton","jsx","Suspense","FullApp"],"ignoreList":[],"sources":["../../src/stores/customTiles.ts","../../src/stores/gameBoard.ts","../../src/constants/actionConstants.ts","../../src/services/syncService.ts","../../src/context/auth.tsx","../../src/components/FullApp/index.tsx"],"sourcesContent":["import i18next from 'i18next';\nimport db from './store';\nimport { CustomTile, CustomTilePull } from '@/types/customTiles';\nimport { CustomTileFilters, PaginatedResult } from '@/types/dexieTypes';\nimport { Collection, Table } from 'dexie';\n\nconst { customTiles } = db;\n\n// Index the customTiles table by locale, gameMode, and isCustom for faster queries\ncustomTiles.hook(\n  'creating',\n  function (this: any, _primKey: number | undefined, obj: CustomTile, _transaction: any) {\n    if (obj.locale === undefined) obj.locale = 'en';\n    if (obj.gameMode === undefined) obj.gameMode = 'online';\n    if (obj.isCustom === undefined) obj.isCustom = 1;\n  }\n);\n\nexport const importCustomTiles = async (\n  record: Partial<CustomTile>[]\n): Promise<number | undefined> => {\n  const recordData = record.map((tile) => ({ ...tile, isEnabled: 1 }));\n  return await customTiles.bulkAdd(recordData as CustomTile[]);\n};\n\n// Helper function to create and filter the query\nconst createFilteredQuery = (filters: Partial<CustomTileFilters>) => {\n  const possibleFilters = ['locale', 'gameMode', 'group', 'intensity', 'tag', 'isCustom', 'action'];\n  let query: Collection<CustomTilePull, number | undefined> = (\n    customTiles as Table<CustomTilePull, number>\n  ).toCollection();\n\n  const filtersArray = Object.entries(filters).filter(([key]) => possibleFilters.includes(key));\n\n  filtersArray.forEach(([key, value]) => {\n    if (value === undefined || value === null || value === '') return;\n\n    if (key === 'tag') {\n      query = query.filter((tile) => tile.tags.includes(value as string));\n    } else {\n      query = query.filter((tile) => tile[key as keyof CustomTile] === value);\n    }\n  });\n\n  return query;\n};\n\nexport const getTiles = async (\n  filters: Omit<CustomTileFilters, 'page' | 'limit' | 'paginated'> = {}\n): Promise<CustomTilePull[]> => {\n  try {\n    const query = createFilteredQuery(filters);\n    return await query.toArray();\n  } catch (error) {\n    console.error('Error in getTiles:', error);\n    return [];\n  }\n};\n\nexport const getPaginatedTiles = async (\n  filters: CustomTileFilters\n): Promise<PaginatedResult<CustomTilePull>> => {\n  const { page = 1, limit = 50 } = filters;\n\n  try {\n    const query = createFilteredQuery(filters);\n\n    // Get total count for pagination\n    const count = await query.count();\n\n    // Apply pagination\n    const offset = (page - 1) * limit;\n    const items = await query.offset(offset).limit(limit).toArray();\n\n    return {\n      items: items,\n      total: count,\n      page,\n      limit,\n      totalPages: Math.ceil(count / limit),\n    };\n  } catch (error) {\n    console.error('Error in getPaginatedTiles:', error);\n    return {\n      items: [],\n      total: 0,\n      page,\n      limit,\n      totalPages: 0,\n    };\n  }\n};\n\n/**\n * Helper function to create a base query for tiles by locale and gameMode\n */\nconst createBaseTileQuery = (locale = 'en', gameMode = 'online') => {\n  return customTiles\n    .where('locale')\n    .equals(locale)\n    .and((tile) => tile.gameMode === gameMode);\n};\n\n/**\n * Get tile counts and intensity distributions by group (without labels)\n * This should be merged with group definitions from customGroups table\n */\nexport const getTileCountsByGroup = async (\n  locale = 'en',\n  gameMode = 'online',\n  tags: string[] | string | null = null\n): Promise<Record<string, { count: number; intensities: Record<number, number> }>> => {\n  // Get tiles with count of items in each group\n  let query = createBaseTileQuery(locale, gameMode);\n\n  if (tags) {\n    query = query.and((tile) => tile.tags.some((tag) => tags.includes(tag)));\n  }\n\n  const allTiles = await query.toArray();\n\n  return allTiles.reduce<Record<string, { count: number; intensities: Record<number, number> }>>(\n    (groups, tile) => {\n      const group = tile.group;\n      if (!groups[group]) {\n        groups[group] = {\n          count: 0,\n          intensities: {},\n        };\n      }\n      groups[group].count++;\n\n      const intensity = Number(tile.intensity);\n      if (!groups[group].intensities[intensity]) {\n        groups[group].intensities[intensity] = 0;\n      }\n      groups[group].intensities[intensity]++;\n\n      return groups;\n    },\n    {}\n  );\n};\n\nexport const getActiveTiles = (gameMode: string | null = null): Promise<CustomTilePull[]> => {\n  const currentLocale = i18next.resolvedLanguage || i18next.language || 'en';\n\n  let tiles = customTiles\n    .where('locale')\n    .equals(currentLocale)\n    .and((tile) => tile.isEnabled === 1);\n\n  if (gameMode) {\n    tiles = tiles.and((tile) => tile.gameMode === gameMode);\n  }\n\n  return tiles.toArray();\n};\n\nexport const addCustomTile = async (record: Partial<CustomTile>): Promise<number | undefined> => {\n  return await customTiles.add({\n    ...record,\n    isEnabled: 1,\n  } as CustomTile);\n};\n\nexport const updateCustomTile = async (\n  id: number,\n  record: Partial<CustomTile>\n): Promise<number> => {\n  return await customTiles.update(id, record);\n};\n\nexport const toggleCustomTile = async (id: number): Promise<number> => {\n  const tile = await customTiles.get(id);\n  if (!tile) throw new Error(`Custom tile with id ${id} not found`);\n\n  return await customTiles.update(id, {\n    isEnabled: !tile.isEnabled ? 1 : 0,\n  });\n};\n\nexport async function deleteAllIsCustomTiles(): Promise<boolean> {\n  try {\n    await db.customTiles.where('isCustom').equals(1).delete();\n    return true;\n  } catch (error) {\n    console.error('Error deleting custom tiles:', error);\n    return false;\n  }\n}\n\nexport const deleteCustomTile = async (id: number): Promise<void> => {\n  await customTiles.delete(id);\n};\n\n/**\n * Helper function to create a query for tiles by group, locale, and gameMode\n */\nconst createTilesByGroupQuery = (groupName: string, locale = 'en', gameMode = 'online') => {\n  return createBaseTileQuery(locale, gameMode).and((tile) => tile.group === groupName);\n};\n\n/**\n * Count custom tiles that belong to a specific group\n */\nexport const countTilesByGroup = async (\n  groupName: string,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<number> => {\n  try {\n    return await createTilesByGroupQuery(groupName, locale, gameMode).count();\n  } catch (error) {\n    console.error('Error counting tiles by group:', error);\n    return 0;\n  }\n};\n\n/**\n * Delete all custom tiles that belong to a specific group\n */\nexport const deleteCustomTilesByGroup = async (\n  groupName: string,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<number> => {\n  try {\n    return await createTilesByGroupQuery(groupName, locale, gameMode).delete();\n  } catch (error) {\n    console.error('Error deleting tiles by group:', error);\n    return 0;\n  }\n};\n","import db from './store';\nimport { DBGameBoard } from '@/types/gameBoard';\n\nconst { gameBoard } = db;\n\nexport const getBoards = (): Promise<DBGameBoard[]> => {\n  return gameBoard.orderBy('title').toArray();\n};\n\nexport const getActiveBoard = async (): Promise<DBGameBoard | undefined> => {\n  return gameBoard.where('isActive').equals(1)?.first();\n};\n\nexport const getBoard = (id: number): Promise<DBGameBoard | undefined> => {\n  return gameBoard.get(id);\n};\n\nexport const addBoard = async (record: Partial<DBGameBoard>): Promise<number | undefined> => {\n  return gameBoard.add(record as DBGameBoard);\n};\n\nexport const updateBoard = async (\n  board: DBGameBoard,\n  record?: Partial<DBGameBoard>\n): Promise<number> => {\n  return gameBoard.update(board.id as number, { ...board, ...record });\n};\n\nexport const upsertBoard = async (record: Partial<DBGameBoard>): Promise<number | undefined> => {\n  const newData: DBGameBoard = {\n    title: record.title === undefined ? '' : record.title,\n    tiles: record.tiles || [],\n    isActive: record.isActive === undefined ? 1 : record.isActive,\n    tags: record.tags || [],\n    gameMode: record.gameMode || 'online',\n  };\n\n  // if we have tiles, we should have a title to go with it.\n  if (!newData?.title?.length && newData?.tiles?.length) {\n    return undefined;\n  }\n\n  const board = await gameBoard.where('title').equals(newData.title).first();\n\n  return db.transaction('rw', db.gameBoard, async () => {\n    if (newData.isActive) {\n      await deactivateAllBoards();\n    }\n\n    if (board) {\n      await updateBoard(board, record);\n      return board.id;\n    }\n\n    return await addBoard(newData);\n  });\n};\n\nexport const activateBoard = async (id: number): Promise<void> => {\n  const allBoards = await gameBoard.toArray();\n\n  const updatedBoards = allBoards.map((board) => ({\n    ...board,\n    isActive: board.id === id ? 1 : 0,\n  }));\n\n  await gameBoard.bulkPut(updatedBoards);\n};\n\nexport const deleteBoard = async (id: number): Promise<void> => {\n  await gameBoard.delete(id);\n};\n\nconst deactivateAllBoards = async (): Promise<void> => {\n  await gameBoard.where('isActive').equals(1).modify({ isActive: 0 });\n};\n","/**\n * Constants used across action-related components and services\n */\n\n/**\n * Default option that appears in all action groups for consistency\n * This ensures all action groups have a \"None\" option available\n */\nexport const DEFAULT_NONE_OPTION = 'None';\n\n/**\n * Cache time-to-live for unified action list in milliseconds\n * Actions are cached for 30 seconds to improve performance\n */\nexport const UNIFIED_ACTION_CACHE_TTL = 30000;\n\n/**\n * Delay in milliseconds between clearing data and syncing with remote server\n * This prevents race conditions during data sync operations\n */\nexport const SYNC_DELAY_MS = 500;\n\n/**\n * Common intensity labels used across the application\n * These map to translation keys for internationalization\n */\nexport const DEFAULT_INTENSITY_LABELS = {\n  /** Beginner level intensity */\n  BEGINNER: 'intensityLabels.beginner',\n  /** Intermediate level intensity */\n  INTERMEDIATE: 'intensityLabels.intermediate',\n  /** Advanced level intensity */\n  ADVANCED: 'intensityLabels.advanced',\n} as const;\n","import {\n  addCustomTile,\n  deleteAllIsCustomTiles as deleteAllCustomTiles,\n  getTiles,\n} from '@/stores/customTiles';\nimport { deleteAllCustomGroups, getCustomGroups, importCustomGroups } from '@/stores/customGroups';\nimport { doc, getDoc, setDoc } from 'firebase/firestore';\nimport { getBoards, upsertBoard } from '@/stores/gameBoard';\nimport { useSettingsStore } from '@/stores/settingsStore';\n\nimport { CustomGroupPull } from '@/types/customGroups';\nimport { CustomTilePull } from '@/types/customTiles';\nimport { Settings } from '@/types/Settings';\nimport { SYNC_DELAY_MS } from '@/constants/actionConstants';\nimport { getAuth } from 'firebase/auth';\nimport { getFirestore } from 'firebase/firestore';\n\ninterface GameBoard {\n  title: string;\n  tiles: any[];\n  tags?: string[];\n  gameMode?: string;\n  isActive?: number;\n}\n\n// Updated to use inline type instead of separate interface to avoid unused warning\n\nconst db = getFirestore();\n\n// Sync custom tiles to Firebase\nexport async function syncCustomTilesToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get all custom tiles from Dexie\n    const customTiles = await getTiles({ isCustom: 1 });\n\n    // Create a document in Firebase with all custom tiles\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        customTiles,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing custom tiles:', error);\n    return false;\n  }\n}\n\n// Sync custom groups to Firebase\nexport async function syncCustomGroupsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get all custom groups from Dexie\n    const customGroups = await getCustomGroups();\n\n    // Create a document in Firebase with all custom groups\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        customGroups,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing custom groups:', error);\n    return false;\n  }\n}\n\n// Sync game boards to Firebase\nexport async function syncGameBoardsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get all game boards from Dexie\n    const gameBoards = await getBoards();\n\n    if (!gameBoards.length) {\n      return true;\n    }\n\n    // Create a document in Firebase with all game boards\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        gameBoards,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing game boards:', error);\n    return false;\n  }\n}\n\n// Sync user settings (including theme preferences) to Firebase\nexport async function syncSettingsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get current settings from store\n    const { settings } = useSettingsStore.getState();\n\n    // Filter out local player settings - they should stay in React app only\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { localPlayers, ...settingsForFirebase } = settings;\n\n    // Create a document in Firebase with filtered user settings\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        settings: settingsForFirebase,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing settings:', error);\n    return false;\n  }\n}\n\n// Sync all data to Firebase\nexport async function syncAllDataToFirebase(): Promise<boolean> {\n  await syncCustomTilesToFirebase();\n  await syncCustomGroupsToFirebase();\n  await syncGameBoardsToFirebase();\n  await syncSettingsToFirebase();\n  return true;\n}\n\n// Sync data from Firebase to Dexie\nexport async function syncDataFromFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get user data from Firebase\n    const userDocRef = doc(db, 'user-data', user.uid);\n    const userDoc = await getDoc(userDocRef);\n\n    if (!userDoc.exists()) {\n      return false;\n    }\n\n    const userData = userDoc.data();\n\n    // Import custom tiles\n    if (userData.customTiles !== undefined) {\n      // Clear existing custom tiles before importing\n      await deleteAllCustomTiles();\n\n      // Add a delay after clearing custom tiles before syncing with remote server\n      await new Promise((resolve) => setTimeout(resolve, SYNC_DELAY_MS));\n\n      // Only import if there are tiles to import\n      if (userData.customTiles && userData.customTiles.length > 0) {\n        for (const tile of userData.customTiles as CustomTilePull[]) {\n          try {\n            const existingTile = await getTiles({\n              gameMode: tile.gameMode,\n              group: tile.group,\n              intensity: tile.intensity,\n              action: tile.action,\n            });\n\n            if (existingTile.length === 0) {\n              await addCustomTile(tile);\n            }\n          } catch (error) {\n            console.error('Error importing custom tile:', tile, error);\n          }\n        }\n        // Successfully processed and imported custom tiles from Firebase into local Dexie database\n      } else {\n        // Firebase data contains empty custom tiles array - local database cleared but no new tiles to import\n      }\n    }\n\n    // Import custom groups\n    if (userData.customGroups !== undefined) {\n      // Clear existing custom groups before importing\n      await deleteAllCustomGroups();\n\n      // Add a delay after clearing custom groups before syncing with remote server\n      await new Promise((resolve) => setTimeout(resolve, SYNC_DELAY_MS));\n\n      // Only import if there are groups to import\n      if (userData.customGroups && userData.customGroups.length > 0) {\n        try {\n          await importCustomGroups(userData.customGroups as CustomGroupPull[]);\n          // Successfully bulk imported custom groups from Firebase with validation and error handling\n        } catch (error) {\n          console.error('Error importing custom groups:', error);\n        }\n      } else {\n        // Firebase data contains empty custom groups array - local database cleared but no new groups to import\n      }\n    }\n\n    // Import game boards\n    if (userData.gameBoards && userData.gameBoards.length > 0) {\n      for (const board of userData.gameBoards as GameBoard[]) {\n        await upsertBoard({\n          title: board.title,\n          tiles: board.tiles,\n          tags: board.tags || [],\n          gameMode: board.gameMode || 'online',\n          isActive: board.isActive || 0,\n        });\n      }\n      // Successfully imported all game boards from Firebase, upserting each board with proper defaults for missing fields\n    }\n\n    // Import user settings (including theme preferences)\n    if (userData.settings) {\n      try {\n        const { updateSettings } = useSettingsStore.getState();\n\n        // Merge Firebase settings with local settings\n        // Only update if the Firebase data is newer or has different values\n        const firebaseSettings = userData.settings as Partial<Settings>;\n        updateSettings(firebaseSettings);\n\n        // Successfully imported user settings from Firebase including theme preferences\n      } catch (error) {\n        console.error('Error importing settings:', error);\n      }\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing data:', error);\n    return false;\n  }\n}\n\n// Variable to store the interval ID for periodic syncing\nlet syncIntervalId: number | null = null;\n\n// Start periodic syncing from Firebase (every 5 minutes)\nexport function startPeriodicSync(intervalMinutes = 5): boolean {\n  // Clear any existing interval first\n  stopPeriodicSync();\n\n  // Convert minutes to milliseconds\n  const intervalMs = intervalMinutes * 60 * 1000;\n\n  // Set up the interval\n  syncIntervalId = window.setInterval(async () => {\n    const auth = getAuth();\n    if (auth.currentUser && !auth.currentUser.isAnonymous) {\n      await syncDataFromFirebase();\n    }\n  }, intervalMs);\n\n  return true;\n}\n\n// Stop periodic syncing\nexport function stopPeriodicSync(): boolean {\n  if (syncIntervalId) {\n    window.clearInterval(syncIntervalId);\n    syncIntervalId = null;\n    return true;\n  }\n  return false;\n}\n\n// Check if periodic sync is active\nexport function isPeriodicSyncActive(): boolean {\n  return syncIntervalId !== null;\n}\n","import React, { useEffect, useMemo, useState, useRef, ReactNode, useCallback } from 'react';\nimport { getAuth } from 'firebase/auth';\nimport {\n  loginAnonymously,\n  updateDisplayName,\n  loginWithEmail,\n  loginWithGoogle,\n  registerWithEmail,\n  resetPassword,\n  convertAnonymousAccount,\n  logout,\n  wipeAllAppData,\n} from '@/services/firebase';\nimport {\n  syncDataFromFirebase,\n  syncAllDataToFirebase,\n  startPeriodicSync,\n  stopPeriodicSync,\n} from '@/services/syncService';\nimport { User } from '@/types';\nimport { getErrorMessage } from '@/types/errors';\n\nexport interface SyncStatus {\n  syncing: boolean;\n  lastSync: Date | null;\n}\n\nexport interface AuthContextType {\n  user: User | null;\n  loading: boolean;\n  initializing: boolean;\n  error: string | null;\n  syncStatus: SyncStatus;\n  login: (displayName?: string) => Promise<User | null>;\n  loginEmail: (email: string, password: string) => Promise<User>;\n  loginGoogle: () => Promise<User>;\n  register: (email: string, password: string, displayName: string) => Promise<User>;\n  updateUser: (displayName?: string) => Promise<User | null>;\n  forgotPassword: (email: string) => Promise<boolean>;\n  convertToRegistered: (email: string, password: string) => Promise<User>;\n  logout: () => Promise<void>;\n  wipeAllData: () => Promise<void>;\n  syncData: () => Promise<boolean>;\n  isAnonymous: boolean;\n}\n\n// eslint-disable-next-line react-refresh/only-export-components\nexport const AuthContext = React.createContext<AuthContextType | undefined>(undefined);\n\ninterface AuthProviderProps {\n  children: ReactNode;\n  [key: string]: unknown;\n}\n\nfunction AuthProvider(props: AuthProviderProps): JSX.Element {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState<boolean>(false); // Changed: false by default for immediate UI\n  const [initializing, setInitializing] = useState<boolean>(true); // New: tracks initial auth check\n  const [error, setError] = useState<string | null>(null);\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({ syncing: false, lastSync: null });\n\n  // Debounce mechanism for sync operations\n  const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Track if initial auth check is complete\n  const authInitializedRef = useRef<boolean>(false);\n\n  // Function to safely perform sync operations with debouncing\n  const performSync = useCallback(\n    async (syncFunction: () => Promise<boolean>): Promise<boolean> => {\n      // Clear any pending sync timeout\n      if (syncTimeoutRef.current) {\n        clearTimeout(syncTimeoutRef.current);\n        syncTimeoutRef.current = null;\n      }\n\n      // Return early if user is not logged in or is anonymous\n      if (!user || user.isAnonymous) return false;\n\n      try {\n        setSyncStatus({ syncing: true, lastSync: syncStatus.lastSync });\n        await syncFunction();\n        setSyncStatus({ syncing: false, lastSync: new Date() });\n        return true;\n      } catch (err: unknown) {\n        console.error('Sync error:', err);\n        if (err instanceof Error) {\n          setError(err.message);\n        } else {\n          setError('An unknown error occurred');\n        }\n        setSyncStatus({ syncing: false, lastSync: syncStatus.lastSync });\n        return false;\n      }\n    },\n    [user, syncTimeoutRef, setSyncStatus, syncStatus.lastSync, setError]\n  );\n  async function login(displayName = ''): Promise<User | null> {\n    try {\n      const loggedInUser = await loginAnonymously(displayName);\n      setUser(loggedInUser);\n      return loggedInUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }\n\n  async function loginEmail(email: string, password: string): Promise<User> {\n    try {\n      setLoading(true);\n      const loggedInUser = await loginWithEmail(email, password);\n      setUser(loggedInUser);\n\n      // Sync will happen via onAuthStateChanged\n      return loggedInUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function loginGoogle(): Promise<User> {\n    try {\n      setLoading(true);\n      const loggedInUser = await loginWithGoogle();\n      setUser(loggedInUser);\n\n      // Sync will happen via onAuthStateChanged\n      return loggedInUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function register(email: string, password: string, displayName: string): Promise<User> {\n    try {\n      setLoading(true);\n      const registeredUser = await registerWithEmail(email, password, displayName);\n      setUser(registeredUser);\n      return registeredUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function forgotPassword(email: string): Promise<boolean> {\n    try {\n      await resetPassword(email);\n      return true;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }\n\n  const convertToRegistered = useCallback(\n    async (email: string, password: string): Promise<User> => {\n      try {\n        setLoading(true);\n        const convertedUser = await convertAnonymousAccount(email, password);\n        setUser(convertedUser);\n\n        // Sync local data to Firebase after conversion\n        await performSync(syncAllDataToFirebase);\n\n        return convertedUser;\n      } catch (err) {\n        if (err instanceof Error) {\n          setError(err.message);\n        }\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [setLoading, setUser, performSync, setError]\n  );\n\n  async function updateUser(displayName = ''): Promise<User | null> {\n    try {\n      const updatedUser = await updateDisplayName(displayName);\n      setUser(updatedUser);\n      return updatedUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }\n\n  const logoutUser = useCallback(async (): Promise<void> => {\n    try {\n      // Sync data to Firebase before logout if user is not anonymous\n      if (user && !user.isAnonymous) {\n        // Add timeout to make sure logout doesn't hang\n        const syncPromise = performSync(syncAllDataToFirebase);\n        const timeoutPromise = new Promise((resolve) => setTimeout(resolve, 5000, false));\n        await Promise.race([syncPromise, timeoutPromise]);\n      }\n\n      await logout();\n      setUser(null);\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [user, performSync, setUser, setError]);\n\n  const wipeAllAppDataAndReload = useCallback(async (): Promise<void> => {\n    try {\n      // Use the comprehensive wipe function from firebase service\n      await wipeAllAppData();\n\n      // Clear user state\n      setUser(null);\n\n      // Reload the page to ensure all React state is reset\n      window.location.reload();\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [setUser, setError]);\n\n  const syncData = useCallback(async (): Promise<boolean> => {\n    return performSync(syncAllDataToFirebase);\n  }, [performSync]);\n\n  useEffect(() => {\n    const auth = getAuth();\n    const unsubscribe = auth.onAuthStateChanged((userData: User | null) => {\n      setUser(userData || null);\n\n      // Mark initial auth check as complete\n      if (!authInitializedRef.current) {\n        authInitializedRef.current = true;\n        setInitializing(false);\n      }\n\n      // If user is logged in and not anonymous, defer sync operations\n      if (userData && !userData.isAnonymous) {\n        // Defer sync to not block UI rendering - use requestIdleCallback or fallback\n        const deferSync = () => {\n          // Use debounced sync to prevent multiple rapid syncs\n          if (syncTimeoutRef.current) {\n            clearTimeout(syncTimeoutRef.current);\n          }\n\n          syncTimeoutRef.current = setTimeout(() => {\n            setSyncStatus({ syncing: true, lastSync: null });\n\n            // Handle case where syncDataFromFirebase might not be defined (e.g., in tests)\n            let syncPromise;\n            try {\n              syncPromise = syncDataFromFirebase ? syncDataFromFirebase() : Promise.resolve(false);\n            } catch (error) {\n              console.warn('syncDataFromFirebase is not available:', error);\n              syncPromise = Promise.resolve(false);\n            }\n\n            // Ensure syncPromise is always a Promise\n            if (!syncPromise || typeof syncPromise.then !== 'function') {\n              syncPromise = Promise.resolve(false);\n            }\n\n            syncPromise\n              .then(() => {\n                setSyncStatus({ syncing: false, lastSync: new Date() });\n                // Start periodic sync after initial sync completes\n                if (startPeriodicSync) {\n                  startPeriodicSync();\n                }\n              })\n              .catch((err) => {\n                console.error('Error syncing from Firebase:', err);\n                setSyncStatus({ syncing: false, lastSync: null });\n              })\n              .finally(() => {\n                syncTimeoutRef.current = null;\n              });\n          }, 1000); // Increased debounce to allow UI to render first\n        };\n\n        if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {\n          (\n            window as Window & {\n              requestIdleCallback: (callback: () => void, options?: { timeout: number }) => void;\n            }\n          ).requestIdleCallback(deferSync, { timeout: 5000 });\n        } else {\n          // Fallback for browsers without requestIdleCallback\n          setTimeout(deferSync, 100);\n        }\n      } else {\n        // User is logged out or anonymous, stop periodic sync\n        if (stopPeriodicSync) {\n          stopPeriodicSync();\n        }\n      }\n    });\n\n    // Make auth context available globally for middleware\n    (window as Window & { authContext?: { user: User | null } }).authContext = { user: null };\n\n    // Clean up function\n    return () => {\n      if (typeof unsubscribe === 'function') {\n        unsubscribe();\n      }\n      if (syncTimeoutRef.current) {\n        clearTimeout(syncTimeoutRef.current);\n      }\n      // Make sure to stop periodic sync when component unmounts\n      if (stopPeriodicSync) {\n        stopPeriodicSync();\n      }\n      (window as Window & { authContext?: { user: User | null } }).authContext = undefined;\n    };\n  }, []);\n\n  // Update global auth context when user changes\n  useEffect(() => {\n    const globalWindow = window as Window & { authContext?: { user: User | null } };\n    if (globalWindow.authContext) {\n      globalWindow.authContext.user = user;\n    }\n  }, [user]);\n  const value = useMemo(\n    () => ({\n      user,\n      loading,\n      initializing,\n      error,\n      syncStatus,\n      login,\n      loginEmail,\n      loginGoogle,\n      register,\n      updateUser,\n      forgotPassword,\n      convertToRegistered,\n      logout: logoutUser,\n      wipeAllData: wipeAllAppDataAndReload,\n      syncData,\n      isAnonymous: user?.isAnonymous || false,\n    }),\n    [\n      user,\n      loading,\n      initializing,\n      error,\n      syncStatus,\n      convertToRegistered,\n      logoutUser,\n      wipeAllAppDataAndReload,\n      syncData,\n    ]\n  );\n\n  return <AuthContext.Provider value={value} {...props} />;\n}\n\nexport { AuthProvider };\n","import { Suspense, lazy, useContext } from 'react';\nimport AppSkeleton from '../AppSkeleton';\nimport { AuthContext, AuthProvider } from '../../context/auth';\n\n// Reduce nesting by consolidating providers and lazy loading only the router\nconst AllProviders = lazy(() => import('../AllProviders'));\nconst RouterSetup = lazy(() => import('../RouterSetup'));\n\nfunction AppContent() {\n  const auth = useContext(AuthContext);\n\n  // Show skeleton during auth loading\n  if (!auth || auth.initializing) {\n    return <AppSkeleton />;\n  }\n\n  return (\n    <Suspense fallback={<AppSkeleton />}>\n      <AllProviders>\n        <RouterSetup />\n      </AllProviders>\n    </Suspense>\n  );\n}\n\nexport default function FullApp() {\n  return (\n    <AuthProvider>\n      <AppContent />\n    </AuthProvider>\n  );\n}\n"],"file":"js/chunk-CZcF1WFm.js"}