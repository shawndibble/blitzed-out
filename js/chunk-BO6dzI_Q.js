import{b as f}from"./chunk-CVSdvP5Z.js";import{n as K,a as Q}from"./chunk-CNqt7FHs.js";import{d as L,p as W}from"./chunk-B-cyqPC2.js";(function(){var n=typeof window!="undefined"?window:typeof global!="undefined"?global:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:{};n.SENTRY_RELEASE={id:"874067a760cfa9079dd7f585e4ceff298b0e879f"}})();try{(function(){var n=typeof window!="undefined"?window:typeof global!="undefined"?global:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:{},r=new n.Error().stack;r&&(n._sentryDebugIds=n._sentryDebugIds||{},n._sentryDebugIds[r]="70d6adcb-a73a-4ba1-a5cc-e3519387e5a6",n._sentryDebugIdIdentifier="sentry-dbid-70d6adcb-a73a-4ba1-a5cc-e3519387e5a6")})()}catch(n){}var X=Object.defineProperty,Z=Object.defineProperties,ee=Object.getOwnPropertyDescriptors,C=Object.getOwnPropertySymbols,re=Object.prototype.hasOwnProperty,ne=Object.prototype.propertyIsEnumerable,x=(n,r,e)=>r in n?X(n,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[r]=e,h=(n,r)=>{for(var e in r||(r={}))re.call(r,e)&&x(n,e,r[e]);if(C)for(var e of C(r))ne.call(r,e)&&x(n,e,r[e]);return n},_=(n,r)=>Z(n,ee(r)),k=(n,r,e)=>x(n,typeof r!="symbol"?r+"":r,e),P=(n,r,e)=>new Promise((t,s)=>{var i=o=>{try{a(e.next(o))}catch(c){s(c)}},l=o=>{try{a(e.throw(o))}catch(c){s(c)}},a=o=>o.done?t(o.value):Promise.resolve(o.value).then(i,l);a((e=e.apply(n,r)).next())});const N=class m{constructor(){k(this,"currentSession",null)}static getInstance(){return m.instance||(m.instance=new m),m.instance}createSession(r,e,t){return P(this,null,function*(){try{this.validateSessionInput(r,e,t);const s=K(),i=Date.now(),l=e.map(c=>{var S,w;return _(h({},c),{location:(S=c.location)!=null?S:0,isFinished:(w=c.isFinished)!=null?w:!1})}),a={id:s,roomId:r,players:l,currentPlayerIndex:0,isActive:!0,createdAt:i,updatedAt:i,settings:h({},t)},o={sessionId:a.id,roomId:a.roomId,players:a.players,currentPlayerIndex:a.currentPlayerIndex,isActive:a.isActive,createdAt:a.createdAt,updatedAt:a.updatedAt,settings:a.settings};return yield L.localPlayerSessions.add(o),this.currentSession=a,a}catch(s){throw new Error(`Failed to create local player session: ${s instanceof Error?s.message:"Unknown error"}`)}})}getSession(r){return P(this,null,function*(){try{if(!r)throw new Error("Session ID is required");const e=yield L.localPlayerSessions.where("sessionId").equals(r).first();return e?this.convertDbSessionToSession(e):null}catch(e){throw new Error(`Failed to get session: ${e instanceof Error?e.message:"Unknown error"}`)}})}updateSession(r,e){return P(this,null,function*(){var t;try{if(!r)throw new Error("Session ID is required");const s=yield this.getSession(r);if(!s)throw new Error("Session not found");const i=_(h(h({},s),e),{id:r,createdAt:s.createdAt,updatedAt:Date.now()}),l={roomId:i.roomId,players:i.players,currentPlayerIndex:i.currentPlayerIndex,isActive:i.isActive,updatedAt:i.updatedAt,settings:i.settings};return yield L.localPlayerSessions.where("sessionId").equals(r).modify(l),((t=this.currentSession)==null?void 0:t.id)===r&&(this.currentSession=i),i}catch(s){throw new Error(`Failed to update session: ${s instanceof Error?s.message:"Unknown error"}`)}})}advanceLocalTurn(r){return P(this,null,function*(){try{if(!r)throw new Error("Session ID is required");const e=yield this.getSession(r);if(!e)throw new Error("Session not found");if(!e.isActive)throw new Error("Cannot advance turn on inactive session");if(e.players.length===0)throw new Error("No players in session");const t=(e.currentPlayerIndex+1)%e.players.length,s=e.players.map((l,a)=>_(h({},l),{isActive:a===t}));return(yield this.updateSession(r,{players:s,currentPlayerIndex:t})).players[t]}catch(e){throw new Error(`Failed to advance turn: ${e instanceof Error?e.message:"Unknown error"}`)}})}getCurrentSession(){return this.currentSession}updatePlayerPosition(r,e,t,s=!1){return P(this,null,function*(){try{if(!r)throw new Error("Session ID is required");if(!e)throw new Error("Player ID is required");if(t<0)throw new Error("Location must be non-negative");const i=yield this.getSession(r);if(!i)throw new Error("Session not found");if(!i.isActive)throw new Error("Cannot update player position on inactive session");const l=i.players.findIndex(o=>o.id===e);if(l===-1)throw new Error(`Player with ID ${e} not found in session`);const a=[...i.players];return a[l]=_(h({},a[l]),{location:t,isFinished:s}),yield this.updateSession(r,{players:a}),a[l]}catch(i){throw new Error(`Failed to update player position: ${i instanceof Error?i.message:"Unknown error"}`)}})}clearCurrentSession(){this.currentSession=null}validateSessionInput(r,e,t){if(!r||typeof r!="string")throw new Error("Valid room ID is required");if(!Array.isArray(e)||e.length<2||e.length>4)throw new Error("Session must have between 2 and 4 players");e.forEach((o,c)=>{if(!o.id||typeof o.id!="string")throw new Error(`Player at index ${c} must have a valid ID`);if(!o.name||typeof o.name!="string")throw new Error(`Player at index ${c} must have a valid name`);if(!["sub","dom","vers"].includes(o.role))throw new Error(`Player at index ${c} must have a valid role`);if(typeof o.location!="undefined"&&(typeof o.location!="number"||o.location<0))throw new Error(`Player at index ${c} must have a valid location (non-negative number)`)});const s=e.map(o=>o.id),i=new Set(s);if(s.length!==i.size)throw new Error("All players must have unique IDs");const l=e.map(o=>o.name.toLowerCase()),a=new Set(l);if(l.length!==a.size)throw new Error("All players must have unique names");if(!t||typeof t!="object")throw new Error("Valid settings object is required")}convertDbSessionToSession(r){return{id:r.sessionId,roomId:r.roomId,players:r.players,currentPlayerIndex:r.currentPlayerIndex,isActive:r.isActive,createdAt:r.createdAt,updatedAt:r.updatedAt,settings:r.settings}}};k(N,"instance");let se=N;const v=se.getInstance();var te=Object.defineProperty,oe=Object.defineProperties,ie=Object.getOwnPropertyDescriptors,F=Object.getOwnPropertySymbols,ae=Object.prototype.hasOwnProperty,le=Object.prototype.propertyIsEnumerable,q=(n,r,e)=>r in n?te(n,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[r]=e,A=(n,r)=>{for(var e in r||(r={}))ae.call(r,e)&&q(n,e,r[e]);if(F)for(var e of F(r))le.call(r,e)&&q(n,e,r[e]);return n},j=(n,r)=>oe(n,ie(r)),E=(n,r,e)=>new Promise((t,s)=>{var i=o=>{try{a(e.next(o))}catch(c){s(c)}},l=o=>{try{a(e.throw(o))}catch(c){s(c)}},a=o=>o.done?t(o.value):Promise.resolve(o.value).then(i,l);a((e=e.apply(n,r)).next())});const ce=Q()(W((n,r)=>({session:null,error:null,isLoading:!1,hasLocalPlayers:()=>{const e=r().session;return(e==null?void 0:e.isActive)===!0&&e.players.length>0},isLocalPlayerRoom:()=>{const e=r().session;return(e==null?void 0:e.isActive)===!0},getCurrentPlayer:()=>{const e=r().session;if(!(e!=null&&e.isActive)||!e.players||e.players.length===0)return null;const t=e.currentPlayerIndex||0,s=e.players[t];if(!s)return null;const i=A({},s);return typeof i.location!="number"&&(i.location=0),typeof i.isFinished!="boolean"&&(i.isFinished=!1),i},setSession:e=>{const t=e?r()._migrateSession(e):null;n({session:t,error:null})},_migrateSession:e=>{if(!e||!e.players)return e;const t=e.players.map(s=>j(A({},s),{location:typeof s.location=="number"?s.location:0,isFinished:typeof s.isFinished=="boolean"?s.isFinished:!1,sound:s.sound||""}));return j(A({},e),{players:t})},clearSession:()=>{v.clearCurrentSession(),n({session:null,error:null})},setError:e=>{n({error:e,isLoading:!1})},setLoading:e=>{n({isLoading:e})},initSession:(e,t,s)=>E(null,null,function*(){try{n({isLoading:!0,error:null});const i=yield v.createSession(e,t,s);n({session:i,isLoading:!1,error:null})}catch(i){const l=i instanceof Error?i.message:"Failed to create session";n({error:l,isLoading:!1,session:null})}}),loadSession:e=>E(null,null,function*(){try{n({isLoading:!0,error:null});const t=yield v.getSession(e);n({session:t,isLoading:!1,error:null})}catch(t){const s=t instanceof Error?t.message:"Failed to load session";n({error:s,isLoading:!1,session:null})}}),nextLocalPlayer:()=>E(null,null,function*(){try{n({isLoading:!0,error:null});const e=r().session;if(!e)throw new Error("No active session");yield v.advanceLocalTurn(e.id);const t=yield v.getSession(e.id);n({session:t,isLoading:!1,error:null})}catch(e){const t=e instanceof Error?e.message:"Failed to advance turn";n({error:t,isLoading:!1})}}),updateSessionSettings:e=>E(null,null,function*(){try{n({isLoading:!0,error:null});const t=r().session;if(!t)throw new Error("No active session");const s=yield v.updateSession(t.id,{settings:e});n({session:s,isLoading:!1,error:null})}catch(t){const s=t instanceof Error?t.message:"Failed to update session settings";n({error:s,isLoading:!1})}})}),{name:"local-player-store",partialize:n=>({session:n.session}),onRehydrateStorage:()=>n=>{n&&(n.isLoading=!1,n.error=null)}}));var b=(n,r,e)=>new Promise((t,s)=>{var i=o=>{try{a(e.next(o))}catch(c){s(c)}},l=o=>{try{a(e.throw(o))}catch(c){s(c)}},a=o=>o.done?t(o.value):Promise.resolve(o.value).then(i,l);a((e=e.apply(n,r)).next())});function ye(){var n;const{session:r,error:e,isLoading:t,hasLocalPlayers:s,isLocalPlayerRoom:i,getCurrentPlayer:l,setSession:a,clearSession:o,setError:c,setLoading:S,initSession:w,loadSession:O,nextLocalPlayer:D,updateSessionSettings:$}=ce(),d=f.useMemo(()=>(r==null?void 0:r.players)||[],[r==null?void 0:r.players]),T=l(),y=(n=r==null?void 0:r.currentPlayerIndex)!=null?n:-1,R=r==null?void 0:r.settings,U=f.useCallback((u,p,J)=>b(null,null,function*(){yield w(u,p,J)}),[w]),M=f.useCallback(u=>b(null,null,function*(){yield O(u)}),[O]),V=f.useCallback(()=>b(null,null,function*(){yield D()}),[D]),z=f.useCallback(()=>{o()},[o]),B=f.useCallback(u=>b(null,null,function*(){yield $(u)}),[$]),g=f.useCallback(u=>u>=0&&u<d.length?d[u]:null,[d]),I=f.useCallback(u=>d.find(p=>p.id===u)||null,[d]),Y=f.useCallback(u=>{const p=I(u);return(p==null?void 0:p.isActive)===!0},[I]),G=f.useCallback(()=>{if(d.length===0)return null;const u=(y+1)%d.length;return g(u)},[d,y,g]),H=f.useCallback(()=>{if(d.length===0)return null;const u=y===0?d.length-1:y-1;return g(u)},[d,y,g]);return{session:r,localPlayers:d,currentPlayer:T,currentPlayerIndex:y,sessionSettings:R,error:e,isLoading:t,hasLocalPlayers:s(),isLocalPlayerRoom:i(),playerCount:d.length,isValidSession:(r==null?void 0:r.isActive)===!0&&d.length>=2,createLocalSession:U,loadLocalSession:M,clearLocalSession:z,advanceToNextPlayer:V,updateSettings:B,getPlayerByIndex:g,getPlayerById:I,isPlayerActive:Y,getNextPlayer:G,getPreviousPlayer:H,setSession:a,setError:c,setLoading:S}}export{ce as a,v as l,ye as u};
//# sourceMappingURL=chunk-BO6dzI_Q.js.map
