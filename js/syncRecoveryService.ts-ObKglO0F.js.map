{"version":3,"file":"syncRecoveryService.ts-ObKglO0F.js","sources":["../../src/services/syncRecoveryService.ts"],"sourcesContent":["/**\n * Sync Recovery Service\n *\n * Detects and recovers from sync service data loss bug.\n * Runs on app startup to identify users with corrupted local databases\n * and trigger recovery through migration system.\n */\n\nimport { forceFreshMigration } from '@/services/migrationService';\nimport { getCustomGroups } from '@/stores/customGroups';\nimport { getTiles } from '@/stores/customTiles';\nimport { safeLocalStorage } from '@/services/migration/errorHandling';\nimport { MIGRATION_VERSION } from '@/services/migration/constants';\n\n// Recovery tracking\nconst RECOVERY_STATUS_KEY = 'blitzed-out-sync-recovery-status';\nconst RECOVERY_VERSION = MIGRATION_VERSION;\nconst MIN_DEFAULT_TILE_COUNT = 50; // Should have hundreds of default actions\n\ninterface RecoveryStatus {\n  version: string;\n  recoveryPerformed: boolean;\n  detectedCorruption: boolean;\n  recoveryTimestamp: number;\n}\n\n// Promise guard to prevent concurrent duplicate recoveries\nlet recoveryInFlight: Promise<boolean> | null = null;\n\n/**\n * Main recovery function - call this on app startup\n */\nexport async function runSyncRecovery(): Promise<boolean> {\n  // Check if recovery is already in flight\n  if (recoveryInFlight) {\n    return await recoveryInFlight;\n  }\n\n  // Create and assign new recovery promise\n  recoveryInFlight = (async (): Promise<boolean> => {\n    try {\n      // Check if recovery already performed for this version\n      const recoveryStatus = getRecoveryStatus();\n      if (recoveryStatus?.recoveryPerformed && recoveryStatus?.version === RECOVERY_VERSION) {\n        return false; // Recovery already done\n      }\n\n      // Detect corruption\n      const isCorrupted = await detectDatabaseCorruption();\n\n      if (isCorrupted) {\n        // Force fresh migration to rebuild everything\n        await forceFreshMigration();\n\n        // Mark recovery as completed\n        markRecoveryCompleted(true);\n        return true;\n      } else {\n        // Mark recovery as checked (no corruption found)\n        markRecoveryCompleted(false);\n        return false;\n      }\n    } catch (error) {\n      console.error('[Sync Recovery] Error during recovery:', error);\n      return false;\n    } finally {\n      // Clear the in-flight promise so future calls can run\n      recoveryInFlight = null;\n    }\n  })();\n\n  return await recoveryInFlight;\n}\n\n/**\n * Detect if local database is corrupted by sync bug\n */\nasync function detectDatabaseCorruption(): Promise<boolean> {\n  try {\n    // Check 1: No default groups exist (major red flag)\n    const defaultGroups = await getCustomGroups({ isDefault: true });\n    const hasDefaultGroups = defaultGroups.length > 0;\n\n    // Check 2: Very few total actions (likely only custom ones remain)\n    const allTiles = await getTiles({});\n    const totalTileCount = allTiles.length;\n\n    // Check 3: No enabled default actions (everything was nuked)\n    const enabledDefaults = await getTiles({ isCustom: 0, isEnabled: 1 });\n    const hasEnabledDefaults = enabledDefaults.length > 0;\n\n    // Corruption indicators\n    const corruptionIndicators = {\n      noDefaultGroups: !hasDefaultGroups,\n      fewTotalActions: totalTileCount < MIN_DEFAULT_TILE_COUNT,\n      noEnabledDefaults: !hasEnabledDefaults,\n    };\n\n    const corruptionScore = Object.values(corruptionIndicators).filter(Boolean).length;\n\n    // Analysis for debugging in development\n    if (process.env.NODE_ENV === 'development') {\n      console.debug('[Sync Recovery] Corruption analysis:', {\n        defaultGroups: defaultGroups.length,\n        totalTiles: totalTileCount,\n        enabledDefaults: enabledDefaults.length,\n        indicators: corruptionIndicators,\n        score: corruptionScore,\n      });\n    }\n\n    // If 2 or more indicators, likely corrupted\n    return corruptionScore >= 2;\n  } catch (error) {\n    console.error('[Sync Recovery] Error detecting corruption:', error);\n    return false; // Don't trigger recovery if we can't detect properly\n  }\n}\n\n/**\n * Get recovery status from localStorage\n */\nfunction getRecoveryStatus(): RecoveryStatus | null {\n  return safeLocalStorage.getJSON<RecoveryStatus>(RECOVERY_STATUS_KEY);\n}\n\n/**\n * Mark recovery as completed\n */\nfunction markRecoveryCompleted(detectedCorruption: boolean): void {\n  const status: RecoveryStatus = {\n    version: RECOVERY_VERSION,\n    recoveryPerformed: true,\n    detectedCorruption,\n    recoveryTimestamp: Date.now(),\n  };\n\n  safeLocalStorage.setJSON(RECOVERY_STATUS_KEY, status);\n}\n\n/**\n * Reset recovery status (for testing)\n */\nexport function resetRecoveryStatus(): void {\n  safeLocalStorage.removeItem(RECOVERY_STATUS_KEY);\n  recoveryInFlight = null; // Also reset the in-flight promise\n}\n\n/**\n * Check if user was affected by the sync bug\n */\nexport function wasUserAffectedBySync(): boolean {\n  const status = getRecoveryStatus();\n  return status?.detectedCorruption === true;\n}\n\n/**\n * Force recovery for testing\n */\nexport async function forceRecovery(): Promise<boolean> {\n  resetRecoveryStatus();\n  return await runSyncRecovery();\n}\n"],"names":["RECOVERY_STATUS_KEY","RECOVERY_VERSION","MIGRATION_VERSION","MIN_DEFAULT_TILE_COUNT","recoveryInFlight","runSyncRecovery","recoveryStatus","getRecoveryStatus","detectDatabaseCorruption","forceFreshMigration","markRecoveryCompleted","error","hasDefaultGroups","getCustomGroups","totalTileCount","getTiles","hasEnabledDefaults","corruptionIndicators","safeLocalStorage","detectedCorruption","status"],"mappings":"m3BAeA,MAAMA,EAAsB,mCACtBC,EAAmBC,EACnBC,EAAyB,GAU/B,IAAIC,EAA4C,KAKhD,eAAsBC,GAAoC,CAExD,OAAID,EACK,MAAMA,GAIfA,GAAoB,SAA8B,CAChD,GAAI,CAEF,MAAME,EAAiBC,EAAA,EACvB,OAAID,GAAA,MAAAA,EAAgB,oBAAqBA,GAAA,KAAA,OAAAA,EAAgB,WAAYL,EAC5D,GAIW,MAAMO,EAAA,GAIxB,MAAMC,EAAA,EAGNC,EAAsB,EAAI,EACnB,KAGPA,EAAsB,EAAK,EACpB,GAEX,OAASC,EAAO,CACd,eAAQ,MAAM,yCAA0CA,CAAK,EACtD,EACT,QAAA,CAEEP,EAAmB,IACrB,CACF,GAAA,EAEO,MAAMA,EACf,CAKA,eAAeI,GAA6C,CAC1D,GAAI,CAGF,MAAMI,GADgB,MAAMC,EAAgB,CAAE,UAAW,GAAM,GACxB,OAAS,EAI1CC,GADW,MAAMC,EAAS,EAAE,GACF,OAI1BC,GADkB,MAAMD,EAAS,CAAE,SAAU,EAAG,UAAW,EAAG,GACzB,OAAS,EAG9CE,EAAuB,CAC3B,gBAAiB,CAACL,EAClB,gBAAiBE,EAAiBX,EAClC,kBAAmB,CAACa,CAAA,EAiBtB,OAdwB,OAAO,OAAOC,CAAoB,EAAE,OAAO,OAAO,EAAE,QAclD,CAC5B,OAASN,EAAO,CACd,eAAQ,MAAM,8CAA+CA,CAAK,EAC3D,EACT,CACF,CAKA,SAASJ,GAA2C,CAClD,OAAOW,EAAiB,QAAwBlB,CAAmB,CACrE,CAKA,SAASU,EAAsBS,EAAmC,CAChE,MAAMC,EAAyB,CAC7B,QAASnB,EACT,kBAAmB,GACnB,mBAAAkB,EACA,kBAAmB,KAAK,IAAA,CAAI,EAG9BD,EAAiB,QAAQlB,EAAqBoB,CAAM,CACtD"}