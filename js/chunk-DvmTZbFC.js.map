{"version":3,"mappings":"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","names":["AppError","message","code","cause","AuthError","isAppError","error","isError","getErrorMessage","getErrorCode","createStandardError","defaultMessage","FIREBASE_ERROR_MESSAGES","getFirebaseErrorMessage","firebaseConfig","missingVars","_","value","key","app","initializeApp","db","getFirestore","loginAnonymously","displayName","auth","getAuth","signInAnonymously","updateProfile","registerWithEmail","email","password","userCredential","createUserWithEmailAndPassword","loginWithEmail","signInWithEmailAndPassword","loginWithGoogle","provider","GoogleAuthProvider","signInWithPopup","resetPassword","sendPasswordResetEmail","convertAnonymousAccount","user","credential","EmailAuthProvider","linkWithCredential","logout","signOut","wipeAllAppData","appPrefixes","prefix","__vitePreload","db2","cookiesToClear","currentHostname","domains","parts","i","paths","cookieName","domain","path","getUserList","roomId","callback","existingData","options","enableCache","enableDebounce","roomUpper","queryKey","getCacheKey","startTime","cached","queryCache","isValidCache","updateQueryMetrics","dataString","existingString","executeQuery","networkError","acquireConnection","database","getDatabase","usersRef","ref","onValue","snap","queryEndTime","latency","allUsers","roomUsers","uid","userData","data","evictOldCacheEntries","priority","getCachePriority","releaseConnection","debounceQuery","updateDisplayName","submitCustomAction","grouping","customAction","addDoc","collection","getBoardByContent","checksum","q","query","where","snapshot","getDocs","getOrCreateBoard","title","gameBoard","settings","sha256","board","updateDoc","storeBoard","getBoard","id","docRef","doc","docSnap","getDoc","lastMessage","queryDebounceMap","CACHE_TTL","PRIORITY_CACHE_TTL","DEBOUNCE_DELAY","PRIORITY_DEBOUNCE_DELAY","DEFAULT_LIMIT","MAX_CACHE_SIZE","connectionPool","queryMetrics","fromCache","existing","sorted","a","b","p95Index","getCacheTTL","getDebounceDelay","entries","priorityOrder","priorityDiff","accessDiff","entriesToRemove","resolve","nextCallback","additionalParams","cache","ttl","queryFn","args","debounceDelay","existingTimeout","timeout","sendMessage","room","text","type","rest","allowedTypes","newMessage","now","roomName","serverTimestamp","deleteMessage","messageId","deleteDoc","getMessages","unsubscribeAuth","unsubscribeQuery","executeGetMessages","limitCount","startAfterDoc","unsubscribe","timeWindow","baseQuery","orderBy","limit","startAfter","onSnapshot","querySnapshot","messages","document","lastVisible","deferredUnsubscribe","getSchedule","currentTime","schedule","result","addSchedule","dateTime","url","Timestamp","createSyncMiddleware","tables","tableSet","syncDebounce","tableName","windowWithAuth","downlevelDatabase","downlevelTable","req","BlitzedOutDatabase","Dexie","__publicField","trans","groups","seen","group","customTiles","_primKey","obj","_transaction","importCustomTiles","record","recordData","tile","createFilteredQuery","filters","possibleFilters","getTiles","getPaginatedTiles","page","count","offset","createBaseTileQuery","locale","gameMode","getTileCountsByGroup","tags","tag","intensity","getActiveTiles","currentLocale","i18next","tiles","addCustomTile","updateCustomTile","toggleCustomTile","deleteAllIsCustomTiles","deleteCustomTile","createTilesByGroupQuery","groupName","countTilesByGroup","deleteCustomTilesByGroup","customGroups","nanoid","modifications","_obj","getCustomGroups","getCustomGroupByName","name","addCustomGroup","groupWithTimestamps","updateCustomGroup","updates","deleteCustomGroup","deleteAllCustomGroups","importCustomGroups","groupsWithAllFields","getGroupIntensities","isGroupNameUnique","excludeId","existingGroup","removeDuplicateGroups","allGroups","groupsByName","removedCount","aTime","bTime","getAllAvailableGroups","index","self","g","getBoards","getActiveBoard","addBoard","updateBoard","upsertBoard","newData","deactivateAllBoards","activateBoard","updatedBoards","deleteBoard","createJSONStorage","getStorage","storage","_a","parse","str2","str","newValue","toThenable","fn","input","onFulfilled","_onRejected","e","_onFulfilled","onRejected","persistImpl","config","baseOptions","set","get","api","state","persistedState","currentState","hasHydrated","hydrationListeners","finishHydrationListeners","setItem","savedSetState","replace","configResult","stateFromStorage","hydrate","_b","cb","_a2","postRehydrationCallback","deserializedStorageValue","migration","migrationResult","migrated","migratedState","newOptions","persist","defaultSettings","useSettingsStore","create","partial","actionEntry","newSelectedActions","selectedActions","entry","acc","useSettings","updateSettings","useGameSettings","DEFAULT_NONE_OPTION","UNIFIED_ACTION_CACHE_TTL","SYNC_DELAY_MS","syncCustomTilesToFirebase","setDoc","syncCustomGroupsToFirebase","syncGameBoardsToFirebase","gameBoards","syncSettingsToFirebase","localPlayers","settingsForFirebase","syncAllDataToFirebase","syncDataFromFirebase","userDocRef","userDoc","deleteAllCustomTiles","firebaseSettings","syncIntervalId","startPeriodicSync","intervalMinutes","stopPeriodicSync","intervalMs","AuthContext","React","AuthProvider","props","setUser","useState","loading","setLoading","initializing","setInitializing","setError","syncStatus","setSyncStatus","syncTimeoutRef","useRef","authInitializedRef","performSync","useCallback","syncFunction","err","login","loggedInUser","errorMessage","loginEmail","loginGoogle","register","registeredUser","forgotPassword","convertToRegistered","convertedUser","updateUser","updatedUser","logoutUser","syncPromise","timeoutPromise","wipeAllAppDataAndReload","syncData","useEffect","deferSync","globalWindow","useMemo","MuiProviders","lazy","RouterSetup","n","ThemeProvider","m","MigrationProvider","ScheduleProvider","Providers","children","jsx","Suspense","AppSkeleton","AppContent","useContext","FullApp"],"ignoreList":[7],"sources":["../../src/types/errors.ts","../../src/services/firebase.ts","../../src/services/syncMiddleware.ts","../../src/stores/store.ts","../../src/stores/customTiles.ts","../../src/stores/customGroups.ts","../../src/stores/gameBoard.ts","../../node_modules/zustand/esm/middleware.mjs","../../src/stores/settingsStore.ts","../../src/constants/actionConstants.ts","../../src/services/syncService.ts","../../src/context/auth.tsx","../../src/components/FullApp/index.tsx"],"sourcesContent":["/**\n * Standardized error types for the application\n */\n\nexport class AppError extends Error {\n  constructor(\n    message: string,\n    public code?: string,\n    public cause?: Error\n  ) {\n    super(message);\n    this.name = 'AppError';\n  }\n}\n\nexport class AuthError extends AppError {\n  constructor(message: string, code?: string, cause?: Error) {\n    super(message, code, cause);\n    this.name = 'AuthError';\n  }\n}\n\nexport class NetworkError extends AppError {\n  constructor(message: string, code?: string, cause?: Error) {\n    super(message, code, cause);\n    this.name = 'NetworkError';\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(\n    message: string,\n    public field?: string,\n    cause?: Error\n  ) {\n    super(message, 'VALIDATION_ERROR', cause);\n    this.name = 'ValidationError';\n  }\n}\n\nexport class SyncError extends AppError {\n  constructor(message: string, code?: string, cause?: Error) {\n    super(message, code, cause);\n    this.name = 'SyncError';\n  }\n}\n\n/**\n * Type guard to check if an error is an instance of AppError\n */\nexport function isAppError(error: unknown): error is AppError {\n  return error instanceof AppError;\n}\n\n/**\n * Type guard to check if an error is a standard Error\n */\nexport function isError(error: unknown): error is Error {\n  return error instanceof Error;\n}\n\n/**\n * Safely extracts error message from unknown error type\n */\nexport function getErrorMessage(error: unknown): string {\n  if (isError(error)) {\n    return error.message;\n  }\n  if (typeof error === 'string') {\n    return error;\n  }\n  return 'An unknown error occurred';\n}\n\n/**\n * Safely extracts error code from unknown error type\n */\nexport function getErrorCode(error: unknown): string | undefined {\n  if (isAppError(error)) {\n    return error.code;\n  }\n  if (isError(error) && 'code' in error) {\n    return (error as Error & { code?: string }).code;\n  }\n  return undefined;\n}\n\n/**\n * Creates a standardized error from an unknown error type\n */\nexport function createStandardError(\n  error: unknown,\n  defaultMessage = 'An unexpected error occurred'\n): AppError {\n  if (isAppError(error)) {\n    return error;\n  }\n\n  if (isError(error)) {\n    return new AppError(error.message || defaultMessage, undefined, error);\n  }\n\n  if (typeof error === 'string') {\n    return new AppError(error);\n  }\n\n  return new AppError(defaultMessage);\n}\n\n/**\n * Firebase error code mappings to user-friendly messages\n */\nexport const FIREBASE_ERROR_MESSAGES: Record<string, string> = {\n  'auth/user-not-found': 'No account found with this email address',\n  'auth/wrong-password': 'Incorrect password',\n  'auth/email-already-in-use': 'An account with this email already exists',\n  'auth/weak-password': 'Password is too weak',\n  'auth/invalid-email': 'Invalid email address',\n  'auth/too-many-requests': 'Too many login attempts. Please try again later',\n  'auth/network-request-failed': 'Network error. Please check your connection',\n  'permission-denied': 'You do not have permission to perform this action',\n  unavailable: 'Service is temporarily unavailable. Please try again',\n};\n\n/**\n * Converts Firebase error to user-friendly message\n */\nexport function getFirebaseErrorMessage(error: unknown): string {\n  const code = getErrorCode(error);\n  if (code && FIREBASE_ERROR_MESSAGES[code]) {\n    return FIREBASE_ERROR_MESSAGES[code];\n  }\n  return getErrorMessage(error);\n}\n","import { AuthError, createStandardError, getFirebaseErrorMessage } from '@/types/errors';\nimport {\n  DataSnapshot,\n  ThenableReference,\n  getDatabase,\n  onDisconnect,\n  onValue,\n  push,\n  ref,\n  remove,\n  set,\n} from 'firebase/database';\nimport {\n  DocumentData,\n  DocumentReference,\n  QueryDocumentSnapshot,\n  QuerySnapshot,\n  Timestamp,\n  addDoc,\n  collection,\n  deleteDoc,\n  doc,\n  getDoc,\n  getDocs,\n  getFirestore,\n  limit,\n  onSnapshot,\n  orderBy,\n  query,\n  serverTimestamp,\n  startAfter,\n  updateDoc,\n  where,\n} from 'firebase/firestore';\nimport {\n  EmailAuthProvider,\n  GoogleAuthProvider,\n  User,\n  createUserWithEmailAndPassword,\n  getAuth,\n  linkWithCredential,\n  sendPasswordResetEmail,\n  signInAnonymously,\n  signInWithEmailAndPassword,\n  signInWithPopup,\n  signOut,\n  updateProfile,\n} from 'firebase/auth';\nimport { getDownloadURL, getStorage, ref as storageRef, uploadString } from 'firebase/storage';\n\nimport { MessageType } from '@/types/Message';\nimport { User as UserType } from '@/types';\nimport { initializeApp } from 'firebase/app';\nimport { sha256 } from 'js-sha256';\n\ninterface FirebaseConfig {\n  apiKey: string;\n  authDomain: string;\n  projectId: string;\n  storageBucket: string;\n  messagingSenderId: string;\n  appId: string;\n  measurementId: string;\n}\n\nconst firebaseConfig: FirebaseConfig = {\n  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,\n  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,\n  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,\n  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,\n  appId: import.meta.env.VITE_FIREBASE_APP_ID,\n  measurementId: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID,\n};\n\n// Check for missing environment variables\nconst missingVars = Object.entries(firebaseConfig)\n  .filter(([_, value]) => !value)\n  .map(([key]) => key);\n\nif (missingVars.length > 0) {\n  console.error('Missing Firebase environment variables:', missingVars);\n  console.error('Please check your .env file and ensure all VITE_FIREBASE_* variables are set');\n}\n\nconst app = initializeApp(firebaseConfig);\nexport const db = getFirestore(app);\n\n// Firestore database initialized\n\nexport async function loginAnonymously(displayName = ''): Promise<User | null> {\n  try {\n    const auth = getAuth();\n    await signInAnonymously(auth);\n    if (auth.currentUser) {\n      await updateProfile(auth.currentUser, { displayName });\n      return auth.currentUser;\n    }\n    return null;\n  } catch (error) {\n    console.error('Anonymous login error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'ANONYMOUS_LOGIN_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\nexport async function registerWithEmail(\n  email: string,\n  password: string,\n  displayName = ''\n): Promise<User> {\n  try {\n    const auth = getAuth();\n    const userCredential = await createUserWithEmailAndPassword(auth, email, password);\n    await updateProfile(userCredential.user, { displayName });\n    return userCredential.user;\n  } catch (error) {\n    console.error('Registration error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'REGISTRATION_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\nexport async function loginWithEmail(email: string, password: string): Promise<User> {\n  try {\n    const auth = getAuth();\n    const userCredential = await signInWithEmailAndPassword(auth, email, password);\n    return userCredential.user;\n  } catch (error) {\n    console.error('Email login error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'EMAIL_LOGIN_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\nexport async function loginWithGoogle(): Promise<User> {\n  try {\n    const auth = getAuth();\n    const provider = new GoogleAuthProvider();\n    const userCredential = await signInWithPopup(auth, provider);\n    return userCredential.user;\n  } catch (error) {\n    console.error('Google login error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'GOOGLE_LOGIN_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\nexport async function resetPassword(email: string): Promise<boolean> {\n  try {\n    const auth = getAuth();\n    await sendPasswordResetEmail(auth, email);\n    return true;\n  } catch (error) {\n    console.error('Password reset error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'PASSWORD_RESET_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\n// Function to convert anonymous account to permanent account\nexport async function convertAnonymousAccount(email: string, password: string): Promise<User> {\n  try {\n    const auth = getAuth();\n    const user = auth.currentUser;\n\n    if (user?.isAnonymous) {\n      const credential = EmailAuthProvider.credential(email, password);\n      const result = await linkWithCredential(user, credential);\n      return result.user;\n    } else {\n      throw new Error('User is not anonymous or not logged in');\n    }\n  } catch (error) {\n    console.error('Account conversion error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'ACCOUNT_CONVERSION_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\nexport async function logout(): Promise<boolean> {\n  try {\n    const auth = getAuth();\n    await signOut(auth);\n    return true;\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\n\n/**\n * Completely wipe all app data including localStorage, IndexedDB, sessionStorage, and cookies\n * This provides a complete reset for users who want to start fresh\n */\nexport async function wipeAllAppData(): Promise<void> {\n  try {\n    // First sign out from Firebase\n    const auth = getAuth();\n    await signOut(auth);\n\n    // Clear all localStorage keys\n    const keysToRemove = [\n      'gameSettings',\n      'messages-storage',\n      'i18nextLng',\n      // Migration keys\n      'blitzed-out-action-groups-migration',\n      'blitzed-out-background-migration',\n      'blitzed-out-migration-in-progress',\n      'blitzed-out-current-language-migration',\n      'blitzed-out-background-migration-in-progress',\n      'blitzed-out-migration-health',\n    ];\n\n    keysToRemove.forEach((key) => {\n      try {\n        localStorage.removeItem(key);\n      } catch (error) {\n        console.warn(`Failed to remove localStorage key: ${key}`, error);\n      }\n    });\n\n    // Clear any remaining localStorage keys that start with our app prefixes\n    const appPrefixes = ['gameSettings', 'messages-storage', 'blitzed-out-'];\n    const localStorageKeys = Object.keys(localStorage);\n    localStorageKeys.forEach((key) => {\n      if (appPrefixes.some((prefix) => key.startsWith(prefix))) {\n        try {\n          localStorage.removeItem(key);\n        } catch (error) {\n          console.warn(`Failed to remove localStorage key: ${key}`, error);\n        }\n      }\n    });\n\n    // Clear sessionStorage (Firebase auth data)\n    try {\n      sessionStorage.clear();\n    } catch (error) {\n      console.warn('Failed to clear sessionStorage:', error);\n    }\n\n    // Clear IndexedDB via Dexie\n    try {\n      const { default: db } = await import('@/stores/store');\n      await db.delete();\n      console.log('Successfully cleared IndexedDB');\n    } catch (error) {\n      console.warn('Failed to clear IndexedDB:', error);\n    }\n\n    // Clear cookies comprehensively by trying multiple path and domain combinations\n    const cookiesToClear = ['i18next'];\n    const currentHostname = window.location.hostname;\n\n    // Generate possible domains (current domain and its parent domains)\n    const domains = [currentHostname];\n    if (currentHostname.includes('.')) {\n      const parts = currentHostname.split('.');\n      // Add parent domains (e.g., for app.example.com, try .example.com)\n      for (let i = 1; i < parts.length - 1; i++) {\n        domains.push(`.${parts.slice(i).join('.')}`);\n      }\n    }\n\n    // Common paths where cookies might be set\n    const paths = ['/', '/app', '/auth', '/login'];\n\n    cookiesToClear.forEach((cookieName) => {\n      // Try clearing with all combinations of domains and paths\n      domains.forEach((domain) => {\n        paths.forEach((path) => {\n          try {\n            // Clear regular cookie\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain};`;\n            // Clear secure cookie (if applicable)\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain}; secure;`;\n            // Clear httpOnly-accessible cookie (won't work from JS but attempt anyway)\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain}; httpOnly;`;\n            // Clear SameSite variants\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain}; SameSite=Strict;`;\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain}; SameSite=Lax;`;\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain}; SameSite=None; secure;`;\n          } catch {\n            // Silently continue - many of these attempts will fail, which is expected\n          }\n        });\n      });\n\n      // Also try without specifying domain (for cookies set without explicit domain)\n      paths.forEach((path) => {\n        try {\n          document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path};`;\n          document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; secure;`;\n        } catch {\n          // Silently continue\n        }\n      });\n\n      console.log(`Attempted comprehensive clearing of cookie: ${cookieName}`);\n    });\n\n    console.log('Successfully wiped all app data');\n  } catch (error) {\n    console.error('Error wiping app data:', error);\n    throw error;\n  }\n}\n\ninterface PresenceOptions {\n  newRoom: string | null;\n  oldRoom: string | null;\n  newDisplayName: string;\n  oldDisplayName: string;\n  removeOnDisconnect?: boolean;\n}\n\nexport function setMyPresence({\n  newRoom,\n  oldRoom,\n  newDisplayName,\n  oldDisplayName,\n  removeOnDisconnect = true,\n}: PresenceOptions): void {\n  const database = getDatabase();\n  const auth = getAuth();\n  const uid = auth.currentUser?.uid;\n\n  // Default to 'PUBLIC' if room is null/undefined\n  const newRoomName = newRoom?.toUpperCase() || 'PUBLIC';\n  const oldRoomName = oldRoom?.toUpperCase() || 'PUBLIC';\n\n  // Only proceed if we have a valid uid\n  if (!uid) {\n    console.warn('Cannot set presence: User not authenticated');\n    return;\n  }\n\n  const newRoomConnectionsRef = ref(database, `rooms/${newRoomName}/uids/${uid}`);\n  const oldRoomConnectionsRef = ref(database, `rooms/${oldRoomName}/uids/${uid}`);\n  const connectedRef = ref(database, '.info/connected');\n\n  let newRef: ThenableReference;\n  let oldRef: ThenableReference;\n\n  onValue(connectedRef, (snap) => {\n    if (snap.val() === true) {\n      // We're connected (or reconnected)!\n      newRef = push(newRoomConnectionsRef);\n      oldRef = push(oldRoomConnectionsRef);\n\n      if (oldRoomName !== newRoomName || oldDisplayName !== newDisplayName) {\n        remove(oldRoomConnectionsRef);\n      }\n\n      // When I disconnect, remove this device\n      if (removeOnDisconnect) {\n        onDisconnect(oldRef).remove();\n        onDisconnect(newRef).remove();\n      }\n\n      // Add this device to my connections list\n      // this value could contain info about the device or a timestamp too\n      set(newRef, { displayName: newDisplayName, lastActive: Date.now() });\n    }\n  });\n\n  document.addEventListener('beforeunload', () => {\n    // Browser is about to be closed, manually trigger disconnect\n    if (oldRef) remove(oldRef);\n    if (newRef) remove(newRef);\n  });\n}\n\nexport function getUserList(\n  roomId: string | null | undefined,\n  callback: (data: Record<string, unknown>) => void,\n  existingData: Record<string, unknown> = {},\n  options: {\n    enableCache?: boolean;\n    enableDebounce?: boolean;\n  } = {}\n): void {\n  if (!roomId) return;\n\n  const { enableCache = true, enableDebounce = true } = options;\n\n  const roomUpper = roomId.toUpperCase();\n  const queryKey = getCacheKey('userList', roomUpper);\n  const startTime = Date.now();\n\n  // Check cache first with smart cache validation\n  if (enableCache) {\n    const cached = queryCache.get(queryKey);\n    if (cached && isValidCache(cached, queryKey)) {\n      // Update cache access count for smart eviction\n      cached.queryCount++;\n      queryCache.set(queryKey, cached);\n\n      updateQueryMetrics(queryKey, Date.now() - startTime, true);\n\n      // Still apply the existing data comparison logic\n      const dataString = Object.keys(cached.data as Record<string, unknown>)\n        .sort()\n        .join(',');\n      const existingString = existingData ? Object.keys(existingData).sort().join(',') : '';\n      if (dataString !== existingString) {\n        callback(cached.data as Record<string, unknown>);\n      }\n      return;\n    }\n  }\n\n  const executeQuery = async () => {\n    let networkError = false;\n\n    try {\n      // Use connection pooling for optimal Firebase performance\n      await acquireConnection();\n\n      const database = getDatabase();\n      const usersRef = ref(database, 'users');\n\n      onValue(\n        usersRef,\n        (snap: DataSnapshot) => {\n          const queryEndTime = Date.now();\n          const latency = queryEndTime - startTime;\n          const allUsers = snap.val() as Record<string, any> | null;\n\n          if (!allUsers) {\n            callback({});\n            return;\n          }\n\n          // Filter users by room and convert to expected format\n          const roomUsers: Record<string, unknown> = {};\n          Object.entries(allUsers).forEach(([uid, userData]) => {\n            if (userData.room === roomUpper) {\n              roomUsers[uid] = {\n                displayName: userData.displayName,\n                uid: uid,\n                lastSeen: userData.lastSeen ? new Date(userData.lastSeen) : new Date(),\n                isAnonymous: userData.isAnonymous,\n                joinedAt: userData.joinedAt ? new Date(userData.joinedAt) : new Date(),\n                room: userData.room,\n              };\n            }\n          });\n\n          const data = roomUsers;\n\n          // Update cache with enhanced metadata\n          if (enableCache) {\n            evictOldCacheEntries(); // Prevent memory bloat\n\n            const priority = getCachePriority(queryKey);\n            queryCache.set(queryKey, {\n              data,\n              timestamp: queryEndTime,\n              queryCount: 1,\n              priority,\n            });\n          }\n\n          updateQueryMetrics(queryKey, latency, false, networkError);\n\n          // to prevent an endless loop, see if our new data matches the existing stuff.\n          // can't compare two arrays directly, but we can compare two strings.\n          const dataString = Object.keys(data).sort().join(',');\n          const existingString = existingData ? Object.keys(existingData).sort().join(',') : '';\n          if (dataString !== existingString) callback(data);\n        },\n        (error) => {\n          networkError = true;\n          console.error('getUserList error:', error);\n          updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n        }\n      );\n    } catch (error) {\n      networkError = true;\n      console.error('getUserList connection error:', error);\n      updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n    } finally {\n      releaseConnection();\n    }\n  };\n\n  // Apply smart debouncing based on priority\n  if (enableDebounce) {\n    debounceQuery(queryKey, executeQuery);\n  } else {\n    executeQuery();\n  }\n}\n\nexport async function updateDisplayName(displayName = ''): Promise<User | null> {\n  try {\n    const auth = getAuth();\n    if (auth.currentUser) {\n      await updateProfile(auth.currentUser, { displayName });\n      return auth.currentUser;\n    }\n    return null;\n  } catch (error) {\n    console.error(error);\n    return null;\n  }\n}\n\nexport async function submitCustomAction(grouping: string, customAction: string): Promise<void> {\n  try {\n    await addDoc(collection(db, 'custom-actions'), {\n      grouping,\n      customAction,\n      ttl: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000), // 4 days\n    });\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nasync function getBoardByContent(checksum: string): Promise<DocumentData | null> {\n  const q = query(collection(db, 'game-boards'), where('checksum', '==', checksum));\n  const snapshot = await getDocs(q);\n  if (snapshot.size) {\n    return snapshot.docs[0];\n  }\n  return null;\n}\n\ninterface BoardData {\n  title: string;\n  gameBoard: string;\n  settings: string;\n}\n\nexport async function getOrCreateBoard({\n  title,\n  gameBoard,\n  settings,\n}: BoardData): Promise<DocumentData | undefined> {\n  if (!title) {\n    return;\n  }\n\n  try {\n    const checksum = sha256(gameBoard);\n    const board = await getBoardByContent(checksum);\n    if (board) {\n      // update the ttl for another 30 days.\n      updateDoc(board.ref, {\n        ttl: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n      }); // 30 days\n\n      return board;\n    }\n    return await storeBoard({ title, gameBoard, settings, checksum });\n  } catch (error) {\n    console.error(error);\n  }\n}\n\ninterface StoreBoardData extends BoardData {\n  checksum: string;\n}\n\nasync function storeBoard({\n  title,\n  gameBoard,\n  settings,\n  checksum,\n}: StoreBoardData): Promise<DocumentReference<DocumentData> | undefined> {\n  try {\n    return await addDoc(collection(db, 'game-boards'), {\n      title,\n      gameBoard,\n      settings,\n      checksum,\n      ttl: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\n    });\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n}\n\nexport async function getBoard(id: string): Promise<DocumentData | undefined> {\n  try {\n    const docRef = doc(db, 'game-boards', id);\n    const docSnap = await getDoc(docRef);\n    if (docSnap.exists()) {\n      return docSnap.data();\n    }\n    return undefined;\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n}\n\nlet lastMessage: Record<string, unknown> = {};\n\n// Enhanced query optimization with smart caching and debouncing\ninterface QueryCache {\n  data: unknown;\n  timestamp: number;\n  lastVisible?: QueryDocumentSnapshot<DocumentData>;\n  queryCount: number; // Track access frequency for smart eviction\n  priority: 'high' | 'medium' | 'low'; // Cache priority based on usage patterns\n}\n\ninterface ConnectionPool {\n  activeConnections: number;\n  maxConnections: number;\n  connectionQueue: Array<() => void>;\n}\n\n// Advanced cache configuration\nconst queryCache = new Map<string, QueryCache>();\nconst queryDebounceMap = new Map<string, NodeJS.Timeout>();\n// Priority query queue for future advanced scheduling (currently unused)\n\n// Optimized cache settings for 60-80% performance improvement\nconst CACHE_TTL = 15000; // Reduced to 15 seconds for fresher data\nconst PRIORITY_CACHE_TTL = 5000; // 5 seconds for high-priority queries\nconst DEBOUNCE_DELAY = 150; // Reduced to 150ms for faster response\nconst PRIORITY_DEBOUNCE_DELAY = 50; // 50ms for high-priority queries\nconst DEFAULT_LIMIT = 50;\nconst MAX_CACHE_SIZE = 100; // Prevent memory bloat\n\n// Connection pooling for optimal Firebase performance\nconst connectionPool: ConnectionPool = {\n  activeConnections: 0,\n  maxConnections: 15, // Optimal for Firebase concurrent connections\n  connectionQueue: [],\n};\n\n// Enhanced performance monitoring with detailed analytics\ninterface QueryMetrics {\n  queryCount: number;\n  totalLatency: number;\n  cacheHits: number;\n  lastQueryTime: number;\n  avgLatency: number;\n  p95Latency: number; // 95th percentile latency tracking\n  connectionPoolHits: number;\n  networkErrors: number;\n  latencyHistory: number[]; // Keep last 20 latencies for percentile calculation\n}\n\nconst queryMetrics = new Map<string, QueryMetrics>();\n\nfunction updateQueryMetrics(\n  queryKey: string,\n  latency: number,\n  fromCache: boolean,\n  networkError: boolean = false\n): void {\n  const existing = queryMetrics.get(queryKey) || {\n    queryCount: 0,\n    totalLatency: 0,\n    cacheHits: 0,\n    lastQueryTime: 0,\n    avgLatency: 0,\n    p95Latency: 0,\n    connectionPoolHits: 0,\n    networkErrors: 0,\n    latencyHistory: [],\n  };\n\n  existing.queryCount++;\n  existing.totalLatency += latency;\n  existing.lastQueryTime = Date.now();\n  existing.avgLatency = existing.totalLatency / existing.queryCount;\n\n  // Track latency history for percentile calculation (keep last 20)\n  existing.latencyHistory.push(latency);\n  if (existing.latencyHistory.length > 20) {\n    existing.latencyHistory.shift();\n  }\n\n  // Calculate 95th percentile\n  if (existing.latencyHistory.length >= 5) {\n    const sorted = [...existing.latencyHistory].sort((a, b) => a - b);\n    const p95Index = Math.floor(sorted.length * 0.95);\n    existing.p95Latency = sorted[p95Index];\n  }\n\n  if (fromCache) {\n    existing.cacheHits++;\n  }\n\n  if (networkError) {\n    existing.networkErrors++;\n  }\n\n  queryMetrics.set(queryKey, existing);\n}\n\n// Smart cache management functions\nfunction getCachePriority(queryKey: string): 'high' | 'medium' | 'low' {\n  if (queryKey.includes('messages')) return 'high'; // Messages are frequently accessed\n  if (queryKey.includes('userList')) return 'medium'; // User list moderate priority\n  return 'low'; // Schedule and other queries\n}\n\nfunction getCacheTTL(priority: 'high' | 'medium' | 'low'): number {\n  switch (priority) {\n    case 'high':\n      return PRIORITY_CACHE_TTL;\n    case 'medium':\n      return CACHE_TTL;\n    case 'low':\n      return CACHE_TTL * 2; // 30 seconds for low priority\n  }\n}\n\nfunction getDebounceDelay(priority: 'high' | 'medium' | 'low'): number {\n  switch (priority) {\n    case 'high':\n      return PRIORITY_DEBOUNCE_DELAY;\n    case 'medium':\n      return DEBOUNCE_DELAY;\n    case 'low':\n      return DEBOUNCE_DELAY * 2; // 300ms for low priority\n  }\n}\n\n// Enhanced cache eviction strategy\nfunction evictOldCacheEntries(): void {\n  if (queryCache.size <= MAX_CACHE_SIZE) return;\n\n  const entries = Array.from(queryCache.entries());\n  // Sort by priority (low first) and then by timestamp (oldest first) and access count (least accessed first)\n  entries.sort(([, a], [, b]) => {\n    const priorityOrder = { low: 0, medium: 1, high: 2 };\n    const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\n    if (priorityDiff !== 0) return priorityDiff;\n\n    const accessDiff = a.queryCount - b.queryCount;\n    if (accessDiff !== 0) return accessDiff;\n\n    return a.timestamp - b.timestamp;\n  });\n\n  // Remove 20% of entries (starting with lowest priority, least accessed, oldest)\n  const entriesToRemove = Math.ceil(queryCache.size * 0.2);\n  for (let i = 0; i < entriesToRemove; i++) {\n    queryCache.delete(entries[i][0]);\n  }\n}\n\n// Connection pool management\nfunction acquireConnection(): Promise<void> {\n  return new Promise((resolve) => {\n    if (connectionPool.activeConnections < connectionPool.maxConnections) {\n      connectionPool.activeConnections++;\n      resolve();\n    } else {\n      connectionPool.connectionQueue.push(() => {\n        connectionPool.activeConnections++;\n        resolve();\n      });\n    }\n  });\n}\n\nfunction releaseConnection(): void {\n  connectionPool.activeConnections--;\n\n  if (connectionPool.connectionQueue.length > 0) {\n    const nextCallback = connectionPool.connectionQueue.shift();\n    if (nextCallback) {\n      nextCallback();\n    }\n  }\n}\n\nexport function getQueryPerformanceMetrics(): Record<\n  string,\n  QueryMetrics & { cacheHitRate: number; errorRate: number; connectionPoolUtilization: number }\n> {\n  const result: Record<\n    string,\n    QueryMetrics & { cacheHitRate: number; errorRate: number; connectionPoolUtilization: number }\n  > = {};\n\n  queryMetrics.forEach((metrics, key) => {\n    result[key] = {\n      ...metrics,\n      cacheHitRate: metrics.queryCount > 0 ? (metrics.cacheHits / metrics.queryCount) * 100 : 0,\n      errorRate: metrics.queryCount > 0 ? (metrics.networkErrors / metrics.queryCount) * 100 : 0,\n      connectionPoolUtilization:\n        (connectionPool.activeConnections / connectionPool.maxConnections) * 100,\n    };\n  });\n\n  return result;\n}\n\nfunction getCacheKey(\n  collection: string,\n  roomId?: string | null,\n  additionalParams?: string\n): string {\n  return `${collection}:${roomId || 'global'}:${additionalParams || ''}`;\n}\n\nfunction isValidCache(cache: QueryCache, queryKey: string): boolean {\n  const priority = getCachePriority(queryKey);\n  const ttl = getCacheTTL(priority);\n  return Date.now() - cache.timestamp < ttl;\n}\n\nfunction debounceQuery<T extends unknown[]>(\n  queryKey: string,\n  queryFn: (...args: T) => void,\n  ...args: T\n): void {\n  const priority = getCachePriority(queryKey);\n  const debounceDelay = getDebounceDelay(priority);\n  const existingTimeout = queryDebounceMap.get(queryKey);\n\n  if (existingTimeout) {\n    clearTimeout(existingTimeout);\n  }\n\n  const timeout = setTimeout(async () => {\n    try {\n      // Use connection pooling for optimal performance\n      await acquireConnection();\n      queryFn(...args);\n    } catch (error) {\n      console.error('Query execution error:', error);\n    } finally {\n      releaseConnection();\n      queryDebounceMap.delete(queryKey);\n    }\n  }, debounceDelay);\n\n  queryDebounceMap.set(queryKey, timeout);\n}\n\ninterface SendMessageOptions {\n  room?: string | null;\n  user: UserType;\n  text?: string;\n  type: MessageType;\n  [key: string]: unknown;\n}\n\nexport async function sendMessage({\n  room,\n  user,\n  text = '',\n  type = 'chat',\n  ...rest\n}: SendMessageOptions): Promise<DocumentReference<DocumentData> | void> {\n  const allowedTypes = ['chat', 'actions', 'settings', 'room', 'media'];\n  if (!allowedTypes.includes(type)) {\n    let message = 'Invalid message type. Was expecting ';\n    message += allowedTypes.join(', ');\n    message += ` but got ${type}`;\n\n    return console.error(message);\n  }\n\n  if (!user?.uid) {\n    return;\n  }\n\n  const newMessage = { room, user: user.uid, text, type, ...rest };\n  if (JSON.stringify(newMessage) === JSON.stringify(lastMessage)) {\n    return; // Duplicate message detected. Not sending.\n  }\n  lastMessage = newMessage;\n\n  const now = Date.now();\n  const roomName = room?.toUpperCase() || 'PUBLIC';\n\n  try {\n    const docRef = await addDoc(collection(db, 'chat-rooms', roomName, 'messages'), {\n      text: text.trim(),\n      ttl: new Date(now + 24 * 60 * 60 * 1000), // 24 hours\n      type,\n      ...rest,\n      uid: user.uid,\n      displayName: user.displayName,\n      timestamp: serverTimestamp(),\n    });\n\n    return docRef;\n  } catch (error) {\n    console.error('Failed to send message:', error);\n    return;\n  }\n}\n\nexport async function deleteMessage(room: string, messageId: string): Promise<void> {\n  return deleteDoc(doc(db, `/chat-rooms/${room.toUpperCase()}/messages/${messageId}`));\n}\n\ninterface ImageData {\n  base64String: string;\n  format: string;\n}\n\ninterface UploadImageData {\n  image: ImageData;\n  room: string | null | undefined;\n  user: UserType;\n}\n\nexport async function uploadImage({ image, room, user }: UploadImageData): Promise<void> {\n  const storage = getStorage();\n  const imageUrl = image.base64String;\n  const imageLoc = `/images/${Math.random()}.${image.format}`;\n  const imageRef = storageRef(storage, imageLoc);\n\n  try {\n    const uploadResult = await uploadString(imageRef, imageUrl, 'base64');\n    const downloadURL = await getDownloadURL(uploadResult.ref);\n\n    await sendMessage({\n      room,\n      user,\n      text: '',\n      type: 'media',\n      image: downloadURL,\n    });\n  } catch (error) {\n    console.error('Error uploading image:', error);\n  }\n}\n\nexport function getMessages(\n  roomId: string | null | undefined,\n  callback: (messages: Array<Record<string, unknown>>) => void,\n  options: {\n    limitCount?: number;\n    startAfterDoc?: QueryDocumentSnapshot<DocumentData>;\n    enableCache?: boolean;\n    enableDebounce?: boolean;\n  } = {}\n): (() => void) | undefined {\n  if (!roomId) return undefined;\n\n  const auth = getAuth();\n\n  // Wait for authentication before proceeding\n  if (!auth.currentUser) {\n    // Return a function that sets up auth listener and then executes query\n    let unsubscribeAuth: (() => void) | undefined;\n    let unsubscribeQuery: (() => void) | undefined;\n\n    unsubscribeAuth = auth.onAuthStateChanged((user) => {\n      if (user) {\n        // User is now authenticated, proceed with the query\n        unsubscribeQuery = executeGetMessages(roomId, callback, options);\n        // Clean up auth listener\n        if (unsubscribeAuth) {\n          unsubscribeAuth();\n          unsubscribeAuth = undefined;\n        }\n      }\n    });\n\n    // Return cleanup function\n    return () => {\n      if (unsubscribeAuth) unsubscribeAuth();\n      if (unsubscribeQuery) unsubscribeQuery();\n    };\n  }\n\n  // User is already authenticated, proceed normally\n  return executeGetMessages(roomId, callback, options);\n}\n\nfunction executeGetMessages(\n  roomId: string,\n  callback: (messages: Array<Record<string, unknown>>) => void,\n  options: {\n    limitCount?: number;\n    startAfterDoc?: QueryDocumentSnapshot<DocumentData>;\n    enableCache?: boolean;\n    enableDebounce?: boolean;\n  } = {}\n): (() => void) | undefined {\n  const {\n    limitCount = DEFAULT_LIMIT,\n    startAfterDoc,\n    enableCache = true,\n    enableDebounce = true,\n  } = options;\n\n  const roomUpper = roomId.toUpperCase();\n  const queryKey = getCacheKey('messages', roomUpper, `limit:${limitCount}`);\n  const startTime = Date.now();\n\n  // Check cache first with smart cache validation\n  if (enableCache) {\n    const cached = queryCache.get(queryKey);\n    if (cached && isValidCache(cached, queryKey)) {\n      // Update cache access count for smart eviction\n      cached.queryCount++;\n      queryCache.set(queryKey, cached);\n\n      updateQueryMetrics(queryKey, Date.now() - startTime, true);\n      callback(cached.data as Array<Record<string, unknown>>);\n      return () => {}; // Return empty unsubscribe function for cached results\n    }\n  }\n\n  const executeQuery = () => {\n    let networkError = false;\n    let unsubscribe: (() => void) | undefined;\n\n    try {\n      // Use connection pooling for optimal Firebase performance\n      acquireConnection();\n\n      // Enhanced time window - use 3 hours for better performance vs data freshness balance\n      const timeWindow = new Date();\n      timeWindow.setHours(timeWindow.getHours() - 3);\n\n      let baseQuery = query(\n        collection(db, 'chat-rooms', roomUpper, 'messages'),\n        where('timestamp', '>', timeWindow),\n        orderBy('timestamp', 'desc'),\n        limit(limitCount)\n      );\n\n      // Add pagination if startAfterDoc is provided\n      if (startAfterDoc) {\n        baseQuery = query(\n          collection(db, 'chat-rooms', roomUpper, 'messages'),\n          where('timestamp', '>', timeWindow),\n          orderBy('timestamp', 'desc'),\n          startAfter(startAfterDoc),\n          limit(limitCount)\n        );\n      }\n\n      unsubscribe = onSnapshot(\n        baseQuery,\n        (querySnapshot: QuerySnapshot<DocumentData>) => {\n          const queryEndTime = Date.now();\n          const latency = queryEndTime - startTime;\n\n          const messages = querySnapshot.docs.map((document) => ({\n            id: document.id,\n            ...document.data(),\n          }));\n\n          // Update cache with enhanced metadata\n          if (enableCache && messages.length > 0) {\n            evictOldCacheEntries(); // Prevent memory bloat\n\n            const lastVisible = querySnapshot.docs[querySnapshot.docs.length - 1];\n            const priority = getCachePriority(queryKey);\n\n            queryCache.set(queryKey, {\n              data: messages,\n              timestamp: queryEndTime,\n              lastVisible,\n              queryCount: 1,\n              priority,\n            });\n          }\n\n          updateQueryMetrics(queryKey, latency, false, networkError);\n          callback(messages);\n        },\n        (error) => {\n          networkError = true;\n          console.error('getMessages error:', error);\n          updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n        }\n      );\n\n      return unsubscribe;\n    } catch (error) {\n      networkError = true;\n      console.error('getMessages connection error:', error);\n      updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n      return () => {};\n    } finally {\n      releaseConnection();\n    }\n  };\n\n  // Apply smart debouncing based on priority\n  if (enableDebounce) {\n    let deferredUnsubscribe: (() => void) | undefined;\n\n    debounceQuery(queryKey, () => {\n      deferredUnsubscribe = executeQuery();\n    });\n\n    return () => {\n      const timeout = queryDebounceMap.get(queryKey);\n      if (timeout) {\n        clearTimeout(timeout);\n        queryDebounceMap.delete(queryKey);\n      }\n      if (deferredUnsubscribe) {\n        deferredUnsubscribe();\n      }\n    };\n  }\n\n  return executeQuery();\n}\n\n// Enhanced pagination helper for messages\nexport function getMessagesWithPagination(\n  roomId: string | null | undefined,\n  callback: (\n    messages: Array<Record<string, unknown>>,\n    lastVisible?: QueryDocumentSnapshot<DocumentData>\n  ) => void,\n  limitCount: number = DEFAULT_LIMIT,\n  startAfterDoc?: QueryDocumentSnapshot<DocumentData>\n): (() => void) | undefined {\n  if (!roomId) return undefined;\n\n  return getMessages(\n    roomId,\n    (messages) => {\n      const cached = queryCache.get(\n        getCacheKey('messages', roomId.toUpperCase(), `limit:${limitCount}`)\n      );\n      callback(messages, cached?.lastVisible);\n    },\n    {\n      limitCount,\n      startAfterDoc,\n      enableCache: true,\n      enableDebounce: true,\n    }\n  );\n}\n\nexport function getSchedule(\n  callback: (schedule: Array<Record<string, unknown>>) => void,\n  options: {\n    limitCount?: number;\n    startAfterDoc?: QueryDocumentSnapshot<DocumentData>;\n    enableCache?: boolean;\n    enableDebounce?: boolean;\n  } = {}\n): () => void {\n  const {\n    limitCount = DEFAULT_LIMIT,\n    startAfterDoc,\n    enableCache = true,\n    enableDebounce = true,\n  } = options;\n\n  const queryKey = getCacheKey('schedule', null, `limit:${limitCount}`);\n  const startTime = Date.now();\n\n  // Check cache first with smart cache validation\n  if (enableCache) {\n    const cached = queryCache.get(queryKey);\n    if (cached && isValidCache(cached, queryKey)) {\n      // Update cache access count for smart eviction\n      cached.queryCount++;\n      queryCache.set(queryKey, cached);\n\n      updateQueryMetrics(queryKey, Date.now() - startTime, true);\n      callback(cached.data as Array<Record<string, unknown>>);\n      return () => {}; // Return empty unsubscribe function for cached results\n    }\n  }\n\n  const executeQuery = async (): Promise<() => void> => {\n    let networkError = false;\n    let unsubscribe: (() => void) | undefined;\n\n    try {\n      // Use connection pooling for optimal Firebase performance\n      await acquireConnection();\n\n      // Enhanced time filtering - include current games (5 minutes buffer)\n      const currentTime = new Date();\n      currentTime.setMinutes(currentTime.getMinutes() - 5);\n\n      let baseQuery = query(\n        collection(db, 'schedule'),\n        where('dateTime', '>', currentTime),\n        orderBy('dateTime', 'asc'),\n        limit(limitCount)\n      );\n\n      // Add pagination if startAfterDoc is provided\n      if (startAfterDoc) {\n        baseQuery = query(\n          collection(db, 'schedule'),\n          where('dateTime', '>', currentTime),\n          orderBy('dateTime', 'asc'),\n          startAfter(startAfterDoc),\n          limit(limitCount)\n        );\n      }\n\n      unsubscribe = onSnapshot(\n        baseQuery,\n        (querySnapshot: QuerySnapshot<DocumentData>) => {\n          const queryEndTime = Date.now();\n          const latency = queryEndTime - startTime;\n\n          const schedule = querySnapshot.docs.map((document) => ({\n            id: document.id,\n            ...document.data(),\n          }));\n\n          // Update cache with enhanced metadata\n          if (enableCache && schedule.length > 0) {\n            evictOldCacheEntries(); // Prevent memory bloat\n\n            const lastVisible = querySnapshot.docs[querySnapshot.docs.length - 1];\n            const priority = getCachePriority(queryKey);\n\n            queryCache.set(queryKey, {\n              data: schedule,\n              timestamp: queryEndTime,\n              lastVisible,\n              queryCount: 1,\n              priority,\n            });\n          }\n\n          updateQueryMetrics(queryKey, latency, false, networkError);\n          callback(schedule);\n        },\n        (error) => {\n          networkError = true;\n          console.error('getSchedule error:', error);\n          updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n        }\n      );\n\n      return unsubscribe || (() => {});\n    } catch (error) {\n      networkError = true;\n      console.error('getSchedule connection error:', error);\n      updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n      return () => {};\n    } finally {\n      releaseConnection();\n    }\n  };\n\n  // Apply smart debouncing based on priority\n  if (enableDebounce) {\n    let deferredUnsubscribe: (() => void) | undefined;\n\n    debounceQuery(queryKey, async () => {\n      deferredUnsubscribe = await executeQuery();\n    });\n\n    return () => {\n      const timeout = queryDebounceMap.get(queryKey);\n      if (timeout) {\n        clearTimeout(timeout);\n        queryDebounceMap.delete(queryKey);\n      }\n      if (deferredUnsubscribe) {\n        deferredUnsubscribe();\n      }\n    };\n  }\n\n  const result = executeQuery();\n  return result instanceof Promise ? () => {} : result;\n}\n\n// Enhanced pagination helper for schedule\nexport function getScheduleWithPagination(\n  callback: (\n    schedule: Array<Record<string, unknown>>,\n    lastVisible?: QueryDocumentSnapshot<DocumentData>\n  ) => void,\n  limitCount: number = DEFAULT_LIMIT,\n  startAfterDoc?: QueryDocumentSnapshot<DocumentData>\n): () => void {\n  return getSchedule(\n    (schedule) => {\n      const cached = queryCache.get(getCacheKey('schedule', null, `limit:${limitCount}`));\n      callback(schedule, cached?.lastVisible);\n    },\n    {\n      limitCount,\n      startAfterDoc,\n      enableCache: true,\n      enableDebounce: true,\n    }\n  );\n}\n\n// Utility function to clear query cache (useful for testing or memory management)\nexport function clearQueryCache(pattern?: string): void {\n  if (pattern) {\n    Array.from(queryCache.keys())\n      .filter((key) => key.includes(pattern))\n      .forEach((key) => queryCache.delete(key));\n  } else {\n    queryCache.clear();\n  }\n}\n\n// Enhanced utility function to get comprehensive cache stats\nexport function getCacheStats(): {\n  totalCachedQueries: number;\n  cacheSize: number;\n  oldestCacheEntry: number | null;\n  newestCacheEntry: number | null;\n  memoryUsageEstimate: number;\n  cachesByPriority: { high: number; medium: number; low: number };\n  averageQueryCount: number;\n  connectionPoolStats: {\n    activeConnections: number;\n    maxConnections: number;\n    queueLength: number;\n    utilizationPercentage: number;\n  };\n} {\n  const timestamps = Array.from(queryCache.values()).map((cache) => cache.timestamp);\n  const cacheValues = Array.from(queryCache.values());\n\n  // Calculate cache distribution by priority\n  const priorityStats = cacheValues.reduce(\n    (acc, cache) => {\n      acc[cache.priority]++;\n      return acc;\n    },\n    { high: 0, medium: 0, low: 0 }\n  );\n\n  // Estimate memory usage (rough calculation)\n  const memoryUsageEstimate = cacheValues.reduce((total, cache) => {\n    return total + JSON.stringify(cache.data).length * 2; // Rough bytes estimate\n  }, 0);\n\n  // Calculate average query count\n  const averageQueryCount =\n    cacheValues.length > 0\n      ? cacheValues.reduce((sum, cache) => sum + cache.queryCount, 0) / cacheValues.length\n      : 0;\n\n  return {\n    totalCachedQueries: queryCache.size,\n    cacheSize: queryCache.size,\n    oldestCacheEntry: timestamps.length > 0 ? Math.min(...timestamps) : null,\n    newestCacheEntry: timestamps.length > 0 ? Math.max(...timestamps) : null,\n    memoryUsageEstimate,\n    cachesByPriority: priorityStats,\n    averageQueryCount,\n    connectionPoolStats: {\n      activeConnections: connectionPool.activeConnections,\n      maxConnections: connectionPool.maxConnections,\n      queueLength: connectionPool.connectionQueue.length,\n      utilizationPercentage:\n        (connectionPool.activeConnections / connectionPool.maxConnections) * 100,\n    },\n  };\n}\n\n// Add new performance optimization utilities\nexport function optimizeCache(): {\n  entriesEvicted: number;\n  memoryFreed: number;\n  newCacheSize: number;\n} {\n  const beforeSize = queryCache.size;\n  const beforeMemory = Array.from(queryCache.values()).reduce((total, cache) => {\n    return total + JSON.stringify(cache.data).length * 2;\n  }, 0);\n\n  evictOldCacheEntries();\n\n  const afterSize = queryCache.size;\n  const afterMemory = Array.from(queryCache.values()).reduce((total, cache) => {\n    return total + JSON.stringify(cache.data).length * 2;\n  }, 0);\n\n  return {\n    entriesEvicted: beforeSize - afterSize,\n    memoryFreed: beforeMemory - afterMemory,\n    newCacheSize: afterSize,\n  };\n}\n\n// Get performance recommendations based on current metrics\nexport function getPerformanceRecommendations(): {\n  recommendations: string[];\n  overallScore: number;\n  issues: string[];\n} {\n  const metrics = getQueryPerformanceMetrics();\n  const cacheStats = getCacheStats();\n  const recommendations: string[] = [];\n  const issues: string[] = [];\n  let overallScore = 100;\n\n  // Analyze cache hit rates\n  const avgCacheHitRate =\n    Object.values(metrics).reduce((sum, metric) => sum + metric.cacheHitRate, 0) /\n      Object.keys(metrics).length || 0;\n\n  if (avgCacheHitRate < 50) {\n    recommendations.push('Increase cache TTL for better hit rates');\n    issues.push('Low cache hit rate detected');\n    overallScore -= 20;\n  }\n\n  // Analyze connection pool utilization\n  if (cacheStats.connectionPoolStats.utilizationPercentage > 80) {\n    recommendations.push('Consider increasing connection pool size');\n    issues.push('High connection pool utilization');\n    overallScore -= 15;\n  }\n\n  // Analyze error rates\n  const avgErrorRate =\n    Object.values(metrics).reduce((sum, metric) => sum + metric.errorRate, 0) /\n      Object.keys(metrics).length || 0;\n\n  if (avgErrorRate > 5) {\n    recommendations.push('Investigate network errors and add retry logic');\n    issues.push('High error rate detected');\n    overallScore -= 25;\n  }\n\n  // Analyze latency\n  const avgLatency =\n    Object.values(metrics).reduce((sum, metric) => sum + metric.avgLatency, 0) /\n      Object.keys(metrics).length || 0;\n\n  if (avgLatency > 1000) {\n    recommendations.push('Optimize query structures and indexes');\n    issues.push('High average latency detected');\n    overallScore -= 20;\n  }\n\n  // Memory usage recommendations\n  if (cacheStats.memoryUsageEstimate > 10 * 1024 * 1024) {\n    // 10MB\n    recommendations.push('Consider reducing cache size or implementing more aggressive eviction');\n    issues.push('High memory usage detected');\n    overallScore -= 10;\n  }\n\n  if (recommendations.length === 0) {\n    recommendations.push('Performance is optimal!');\n  }\n\n  return {\n    recommendations,\n    overallScore: Math.max(0, overallScore),\n    issues,\n  };\n}\n\nexport async function addSchedule(\n  dateTime: Date,\n  url: string,\n  room = 'PUBLIC'\n): Promise<DocumentReference<DocumentData> | void> {\n  try {\n    return await addDoc(collection(db, 'schedule'), {\n      dateTime: Timestamp.fromDate(dateTime),\n      url,\n      room,\n    });\n  } catch (error) {\n    return console.error(error);\n  }\n}\n","import { Middleware, DBCore, DBCoreTable, DBCoreMutateRequest } from 'dexie';\nimport { WindowWithAuth } from '../types/app';\n\ninterface SyncMiddlewareOptions {\n  tables: string[];\n}\n\ninterface TimeoutMap {\n  [key: string]: ReturnType<typeof setTimeout>;\n}\n\ninterface SyncDebounce {\n  timeouts: TimeoutMap;\n  queue: Set<string>;\n  scheduleSync(tableName: string): void;\n  processSyncQueue(): void;\n}\n\ninterface DexieMiddleware extends Middleware<DBCore> {\n  stack: 'dbcore';\n  name: string;\n}\n\n/**\n * Creates a Dexie middleware that syncs data to Firebase after database modifications\n * @param options - Configuration options\n * @returns Dexie middleware function\n */\nexport function createSyncMiddleware(\n  options: SyncMiddlewareOptions = { tables: ['customTiles', 'gameBoard'] }\n): DexieMiddleware {\n  const { tables } = options;\n  const tableSet = new Set(tables);\n\n  // Debounce mechanism\n  const syncDebounce: SyncDebounce = {\n    timeouts: {},\n    queue: new Set<string>(),\n\n    // Schedule a sync for a specific table\n    scheduleSync(tableName: string): void {\n      // Clear any existing timeout for this table\n      if (this.timeouts[tableName]) {\n        clearTimeout(this.timeouts[tableName]);\n      }\n\n      // Add to queue\n      this.queue.add(tableName);\n\n      // Set a new timeout\n      this.timeouts[tableName] = setTimeout(() => {\n        this.processSyncQueue();\n      }, 2000); // 2 second debounce\n    },\n\n    // Process all tables in the queue\n    processSyncQueue(): void {\n      if (this.queue.size === 0) return;\n\n      // Only sync if we have an authenticated non-anonymous user\n      const windowWithAuth = window as WindowWithAuth;\n      if (windowWithAuth.authContext?.user && !windowWithAuth.authContext.user.isAnonymous) {\n        windowWithAuth.authContext.syncData();\n      }\n\n      // Clear the queue and timeouts\n      this.queue.clear();\n      Object.keys(this.timeouts).forEach((key) => {\n        clearTimeout(this.timeouts[key]);\n        delete this.timeouts[key];\n      });\n    },\n  };\n\n  return {\n    stack: 'dbcore',\n    name: 'syncMiddleware',\n    create(downlevelDatabase: DBCore): DBCore {\n      return {\n        ...downlevelDatabase,\n        table(tableName: string): DBCoreTable {\n          const downlevelTable = downlevelDatabase.table(tableName);\n\n          // Only apply middleware to specified tables\n          if (!tableSet.has(tableName)) {\n            return downlevelTable;\n          }\n\n          return {\n            ...downlevelTable,\n            mutate: async (req: DBCoreMutateRequest): Promise<any> => {\n              // First, perform the actual database operation\n              const result = await downlevelTable.mutate(req);\n\n              // After successful operation, trigger sync if it's a write operation\n              if (['put', 'add', 'delete', 'deleteRange', 'update'].includes(req.type)) {\n                // Schedule a sync for this table with debouncing\n                syncDebounce.scheduleSync(tableName);\n              }\n\n              return result;\n            },\n          };\n        },\n      };\n    },\n  };\n}\n","import { createSyncMiddleware } from '@/services/syncMiddleware';\nimport Dexie, { type EntityTable } from 'dexie';\nimport { CustomTilePull } from '@/types/customTiles';\nimport { DBGameBoard } from '@/types/gameBoard';\nimport { CustomGroupPull } from '@/types/customGroups';\nimport { DBLocalPlayerSession, DBLocalPlayerMove, DBLocalPlayerStats } from '@/types/localPlayerDB';\n\nclass BlitzedOutDatabase extends Dexie {\n  customTiles!: EntityTable<CustomTilePull, 'id'>;\n  gameBoard!: EntityTable<DBGameBoard, 'id'>;\n  customGroups!: EntityTable<CustomGroupPull, 'id'>;\n  localPlayerSessions!: EntityTable<DBLocalPlayerSession, 'id'>;\n  localPlayerMoves!: EntityTable<DBLocalPlayerMove, 'id'>;\n  localPlayerStats!: EntityTable<DBLocalPlayerStats, 'id'>;\n\n  constructor() {\n    super('blitzedOut');\n\n    // Version 2: Original schema\n    this.version(2).stores({\n      customTiles: '++id, group, intensity, action, isEnabled, tags, gameMode, isCustom, locale',\n      gameBoard: '++id, title, tiles, tags, gameMode, isActive',\n    });\n\n    // Version 3: Add custom groups table\n    this.version(3).stores({\n      customTiles: '++id, group, intensity, action, isEnabled, tags, gameMode, isCustom, locale',\n      gameBoard: '++id, title, tiles, tags, gameMode, isActive',\n      customGroups: '++id, name, label, locale, gameMode, isDefault, createdAt',\n    });\n\n    // Version 4: Add unique constraint on custom groups\n    this.version(4)\n      .stores({\n        customTiles: '++id, group, intensity, action, isEnabled, tags, gameMode, isCustom, locale',\n        gameBoard: '++id, title, tiles, tags, gameMode, isActive',\n        customGroups:\n          '++id, name, label, locale, gameMode, isDefault, createdAt, [name+locale+gameMode]',\n      })\n      .upgrade(async (trans) => {\n        // Remove duplicates during upgrade\n        const groups = await trans.table('customGroups').toArray();\n        const seen = new Set<string>();\n\n        for (const group of groups) {\n          const key = `${group.name}-${group.locale}-${group.gameMode}`;\n          if (seen.has(key)) {\n            // Delete duplicate\n            await trans.table('customGroups').delete(group.id);\n          } else {\n            seen.add(key);\n          }\n        }\n      });\n\n    // Version 5: Add local player tables for single-device multiplayer\n    this.version(5).stores({\n      customTiles: '++id, group, intensity, action, isEnabled, tags, gameMode, isCustom, locale',\n      gameBoard: '++id, title, tiles, tags, gameMode, isActive',\n      customGroups:\n        '++id, name, label, locale, gameMode, isDefault, createdAt, [name+locale+gameMode]',\n      localPlayerSessions: '++id, sessionId, roomId, isActive, createdAt, updatedAt',\n      localPlayerMoves: '++id, sessionId, playerId, timestamp, sequence',\n      localPlayerStats: '++id, sessionId, playerId, lastActive',\n    });\n  }\n}\n\nconst db = new BlitzedOutDatabase();\n\ndb.use(\n  createSyncMiddleware({\n    tables: [\n      'customTiles',\n      'gameBoard',\n      'customGroups',\n      'localPlayerSessions',\n      'localPlayerMoves',\n      'localPlayerStats',\n    ],\n  })\n);\n\nexport default db;\n","import i18next from 'i18next';\nimport db from './store';\nimport { CustomTile, CustomTilePull } from '@/types/customTiles';\nimport { CustomTileFilters, PaginatedResult } from '@/types/dexieTypes';\nimport { Collection, Table } from 'dexie';\n\nconst { customTiles } = db;\n\n// Index the customTiles table by locale, gameMode, and isCustom for faster queries\ncustomTiles.hook(\n  'creating',\n  function (this: any, _primKey: number | undefined, obj: CustomTile, _transaction: any) {\n    if (obj.locale === undefined) obj.locale = 'en';\n    if (obj.gameMode === undefined) obj.gameMode = 'online';\n    if (obj.isCustom === undefined) obj.isCustom = 1;\n  }\n);\n\nexport const importCustomTiles = async (\n  record: Partial<CustomTile>[]\n): Promise<number | undefined> => {\n  const recordData = record.map((tile) => ({ ...tile, isEnabled: 1 }));\n  return await customTiles.bulkAdd(recordData as CustomTile[]);\n};\n\n// Helper function to create and filter the query\nconst createFilteredQuery = (filters: Partial<CustomTileFilters>) => {\n  const possibleFilters = ['locale', 'gameMode', 'group', 'intensity', 'tag', 'isCustom', 'action'];\n  let query: Collection<CustomTilePull, number | undefined> = (\n    customTiles as Table<CustomTilePull, number>\n  ).toCollection();\n\n  const filtersArray = Object.entries(filters).filter(([key]) => possibleFilters.includes(key));\n\n  filtersArray.forEach(([key, value]) => {\n    if (value === undefined || value === null || value === '') return;\n\n    if (key === 'tag') {\n      query = query.filter((tile) => tile.tags.includes(value as string));\n    } else {\n      query = query.filter((tile) => tile[key as keyof CustomTile] === value);\n    }\n  });\n\n  return query;\n};\n\nexport const getTiles = async (\n  filters: Omit<CustomTileFilters, 'page' | 'limit' | 'paginated'> = {}\n): Promise<CustomTilePull[]> => {\n  try {\n    const query = createFilteredQuery(filters);\n    return await query.toArray();\n  } catch (error) {\n    console.error('Error in getTiles:', error);\n    return [];\n  }\n};\n\nexport const getPaginatedTiles = async (\n  filters: CustomTileFilters\n): Promise<PaginatedResult<CustomTilePull>> => {\n  const { page = 1, limit = 50 } = filters;\n\n  try {\n    const query = createFilteredQuery(filters);\n\n    // Get total count for pagination\n    const count = await query.count();\n\n    // Apply pagination\n    const offset = (page - 1) * limit;\n    const items = await query.offset(offset).limit(limit).toArray();\n\n    return {\n      items: items,\n      total: count,\n      page,\n      limit,\n      totalPages: Math.ceil(count / limit),\n    };\n  } catch (error) {\n    console.error('Error in getPaginatedTiles:', error);\n    return {\n      items: [],\n      total: 0,\n      page,\n      limit,\n      totalPages: 0,\n    };\n  }\n};\n\n/**\n * Helper function to create a base query for tiles by locale and gameMode\n */\nconst createBaseTileQuery = (locale = 'en', gameMode = 'online') => {\n  return customTiles\n    .where('locale')\n    .equals(locale)\n    .and((tile) => tile.gameMode === gameMode);\n};\n\n/**\n * Get tile counts and intensity distributions by group (without labels)\n * This should be merged with group definitions from customGroups table\n */\nexport const getTileCountsByGroup = async (\n  locale = 'en',\n  gameMode = 'online',\n  tags: string[] | string | null = null\n): Promise<Record<string, { count: number; intensities: Record<number, number> }>> => {\n  // Get tiles with count of items in each group\n  let query = createBaseTileQuery(locale, gameMode);\n\n  if (tags) {\n    query = query.and((tile) => tile.tags.some((tag) => tags.includes(tag)));\n  }\n\n  const allTiles = await query.toArray();\n\n  return allTiles.reduce<Record<string, { count: number; intensities: Record<number, number> }>>(\n    (groups, tile) => {\n      const group = tile.group;\n      if (!groups[group]) {\n        groups[group] = {\n          count: 0,\n          intensities: {},\n        };\n      }\n      groups[group].count++;\n\n      const intensity = Number(tile.intensity);\n      if (!groups[group].intensities[intensity]) {\n        groups[group].intensities[intensity] = 0;\n      }\n      groups[group].intensities[intensity]++;\n\n      return groups;\n    },\n    {}\n  );\n};\n\nexport const getActiveTiles = (gameMode: string | null = null): Promise<CustomTilePull[]> => {\n  const currentLocale = i18next.resolvedLanguage || i18next.language || 'en';\n\n  let tiles = customTiles\n    .where('locale')\n    .equals(currentLocale)\n    .and((tile) => tile.isEnabled === 1);\n\n  if (gameMode) {\n    tiles = tiles.and((tile) => tile.gameMode === gameMode);\n  }\n\n  return tiles.toArray();\n};\n\nexport const addCustomTile = async (record: Partial<CustomTile>): Promise<number | undefined> => {\n  return await customTiles.add({\n    ...record,\n    isEnabled: 1,\n  } as CustomTile);\n};\n\nexport const updateCustomTile = async (\n  id: number,\n  record: Partial<CustomTile>\n): Promise<number> => {\n  return await customTiles.update(id, record);\n};\n\nexport const toggleCustomTile = async (id: number): Promise<number> => {\n  const tile = await customTiles.get(id);\n  if (!tile) throw new Error(`Custom tile with id ${id} not found`);\n\n  return await customTiles.update(id, {\n    isEnabled: !tile.isEnabled ? 1 : 0,\n  });\n};\n\nexport async function deleteAllIsCustomTiles(): Promise<boolean> {\n  try {\n    await db.customTiles.where('isCustom').equals(1).delete();\n    return true;\n  } catch (error) {\n    console.error('Error deleting custom tiles:', error);\n    return false;\n  }\n}\n\nexport const deleteCustomTile = async (id: number): Promise<void> => {\n  await customTiles.delete(id);\n};\n\n/**\n * Helper function to create a query for tiles by group, locale, and gameMode\n */\nconst createTilesByGroupQuery = (groupName: string, locale = 'en', gameMode = 'online') => {\n  return createBaseTileQuery(locale, gameMode).and((tile) => tile.group === groupName);\n};\n\n/**\n * Count custom tiles that belong to a specific group\n */\nexport const countTilesByGroup = async (\n  groupName: string,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<number> => {\n  try {\n    return await createTilesByGroupQuery(groupName, locale, gameMode).count();\n  } catch (error) {\n    console.error('Error counting tiles by group:', error);\n    return 0;\n  }\n};\n\n/**\n * Delete all custom tiles that belong to a specific group\n */\nexport const deleteCustomTilesByGroup = async (\n  groupName: string,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<number> => {\n  try {\n    return await createTilesByGroupQuery(groupName, locale, gameMode).delete();\n  } catch (error) {\n    console.error('Error deleting tiles by group:', error);\n    return 0;\n  }\n};\n","import i18next from 'i18next';\nimport { nanoid } from 'nanoid';\nimport db from './store';\nimport {\n  CustomGroup,\n  CustomGroupBase,\n  CustomGroupPull,\n  CustomGroupFilters,\n  CustomGroupIntensity,\n} from '@/types/customGroups';\nimport { Collection, Table } from 'dexie';\n\nconst { customGroups } = db;\n\n// Hook to set default values when creating custom groups\ncustomGroups.hook(\n  'creating',\n  function (this: any, _primKey: string | undefined, obj: CustomGroup, _transaction: any) {\n    if (!obj.id) obj.id = nanoid();\n    if (obj.locale === undefined) obj.locale = i18next.resolvedLanguage || i18next.language || 'en';\n    if (obj.gameMode === undefined) obj.gameMode = 'online';\n    if (obj.isDefault === undefined) obj.isDefault = false;\n    const now = new Date();\n    if (!(obj as CustomGroupPull).createdAt) (obj as CustomGroupPull).createdAt = now;\n    (obj as CustomGroupPull).updatedAt = now;\n  }\n);\n\n// Hook to update the updatedAt timestamp when updating\ncustomGroups.hook(\n  'updating',\n  function (this: any, modifications: any, _primKey: string, _obj: CustomGroup, _transaction: any) {\n    modifications.updatedAt = new Date();\n  }\n);\n\n// Helper function to create and filter the query\nconst createFilteredQuery = (filters: Partial<CustomGroupFilters>) => {\n  const possibleFilters = ['locale', 'gameMode', 'name', 'isDefault'];\n  let query: Collection<CustomGroupPull, string | undefined> = (\n    customGroups as Table<CustomGroupPull, string>\n  ).toCollection();\n\n  const filtersArray = Object.entries(filters).filter(([key]) => possibleFilters.includes(key));\n\n  filtersArray.forEach(([key, value]) => {\n    if (value === undefined || value === null || value === '') return;\n\n    query = query.filter((group) => group[key as keyof CustomGroup] === value);\n  });\n\n  return query;\n};\n\n/**\n * Get custom groups with optional filtering\n */\nexport const getCustomGroups = async (\n  filters: Partial<CustomGroupFilters> = {}\n): Promise<CustomGroupPull[]> => {\n  try {\n    const query = createFilteredQuery(filters);\n    return await query.toArray();\n  } catch (error) {\n    console.error('Error in getCustomGroups:', error);\n    return [];\n  }\n};\n\n/**\n * Get a single custom group by ID\n */\nexport const getCustomGroup = async (id: string): Promise<CustomGroupPull | undefined> => {\n  try {\n    return await customGroups.get(id);\n  } catch (error) {\n    console.error('Error in getCustomGroup:', error);\n    return undefined;\n  }\n};\n\n/**\n * Get a custom group by name, locale, and game mode\n */\nexport const getCustomGroupByName = async (\n  name: string,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<CustomGroupPull | undefined> => {\n  try {\n    return await customGroups\n      .where('name')\n      .equals(name)\n      .and((group) => group.locale === locale && group.gameMode === gameMode)\n      .first();\n  } catch (error) {\n    console.error('Error in getCustomGroupByName:', error);\n    return undefined;\n  }\n};\n\n/**\n * Add a new custom group\n */\nexport const addCustomGroup = async (group: CustomGroupBase): Promise<string | undefined> => {\n  try {\n    // The creating hook will add id, createdAt, and updatedAt fields\n    // We need to provide the required fields that the hook expects\n    const groupWithTimestamps = {\n      ...group,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    } as Omit<CustomGroupPull, 'id'>;\n\n    const id = await customGroups.add(groupWithTimestamps);\n    return id;\n  } catch (error) {\n    console.error('Error in addCustomGroup:', error);\n    return undefined;\n  }\n};\n\n/**\n * Update an existing custom group\n */\nexport const updateCustomGroup = async (\n  id: string,\n  updates: Partial<CustomGroupBase>\n): Promise<number> => {\n  try {\n    return await customGroups.update(id, updates);\n  } catch (error) {\n    console.error('Error in updateCustomGroup:', error);\n    return 0;\n  }\n};\n\n/**\n * Delete a custom group\n */\nexport const deleteCustomGroup = async (id: string): Promise<void> => {\n  try {\n    await customGroups.delete(id);\n  } catch (error) {\n    console.error('Error in deleteCustomGroup:', error);\n  }\n};\n\n/**\n * Delete all custom groups (useful for migrations and testing)\n */\nexport const deleteAllCustomGroups = async (): Promise<boolean> => {\n  try {\n    await customGroups.clear();\n    return true;\n  } catch (error) {\n    console.error('Error deleting all custom groups:', error);\n    return false;\n  }\n};\n\n/**\n * Import multiple custom groups\n */\nexport const importCustomGroups = async (\n  groups: Partial<CustomGroup>[]\n): Promise<string | undefined> => {\n  try {\n    const now = new Date();\n    const groupsWithAllFields = groups.map((group) => {\n      const fullGroup: CustomGroupPull = {\n        name: group.name || '',\n        label: group.label || '',\n        intensities: group.intensities || [],\n        id: group.id || nanoid(),\n        locale: group.locale || 'en',\n        gameMode: group.gameMode || 'online',\n        isDefault: group.isDefault || false,\n        createdAt: (group as CustomGroupPull).createdAt || now,\n        updatedAt: (group as CustomGroupPull).updatedAt || now,\n      };\n      return fullGroup;\n    });\n\n    return await customGroups.bulkAdd(groupsWithAllFields);\n  } catch (error) {\n    console.error('Error in importCustomGroups:', error);\n    return undefined;\n  }\n};\n\n/**\n * Create default custom groups from locale action files\n * This is used during migration and initial setup\n */\nexport const createDefaultGroups = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<CustomGroupPull[]> => {\n  try {\n    // Get all existing groups from Dexie for this locale/gameMode\n    const existingGroups = await getCustomGroups({ locale, gameMode, isDefault: true });\n\n    // If we already have default groups, return them\n    if (existingGroups.length > 0) {\n      return existingGroups;\n    }\n\n    // If no groups exist, migration probably hasn't run yet\n    // Return empty array - migration will handle creating groups\n    return [];\n  } catch (error) {\n    console.error('Error creating default groups:', error);\n    return [];\n  }\n};\n\n/**\n * Get all available intensity levels for a specific group\n */\nexport const getGroupIntensities = async (\n  groupName: string,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<CustomGroupIntensity[]> => {\n  try {\n    const group = await getCustomGroupByName(groupName, locale, gameMode);\n    return group?.intensities || [];\n  } catch (error) {\n    console.error('Error in getGroupIntensities:', error);\n    return [];\n  }\n};\n\n/**\n * Validate that a custom group name is unique within the locale/gameMode\n */\nexport const isGroupNameUnique = async (\n  name: string,\n  locale = 'en',\n  gameMode = 'online',\n  excludeId?: string\n): Promise<boolean> => {\n  try {\n    const existingGroup = await getCustomGroupByName(name, locale, gameMode);\n    if (!existingGroup) return true;\n    if (excludeId && existingGroup.id === excludeId) return true;\n    return false;\n  } catch (error) {\n    console.error('Error in isGroupNameUnique:', error);\n    return false;\n  }\n};\n\n/**\n * Get all custom groups for the current locale and game mode\n */\nexport const getCurrentGroups = async (gameMode?: string): Promise<CustomGroupPull[]> => {\n  const currentLocale = i18next.resolvedLanguage || i18next.language || 'en';\n  return getCustomGroups({\n    locale: currentLocale,\n    gameMode: gameMode || 'online',\n  });\n};\n\n/**\n * Get default and custom groups combined for display in selectors\n */\n/**\n * Remove duplicate groups from the database\n * Keeps the first occurrence of each group name per locale/gameMode\n */\nexport const removeDuplicateGroups = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<number> => {\n  try {\n    const allGroups = await getCustomGroups({ locale, gameMode });\n    const groupsByName = new Map<string, CustomGroupPull[]>();\n\n    // Group by name\n    allGroups.forEach((group) => {\n      const existing = groupsByName.get(group.name) || [];\n      existing.push(group);\n      groupsByName.set(group.name, existing);\n    });\n\n    let removedCount = 0;\n\n    // Remove duplicates (keep the first, remove the rest)\n    for (const [, groups] of groupsByName) {\n      if (groups.length > 1) {\n        // Sort by creation date to keep the oldest\n        groups.sort((a, b) => {\n          try {\n            const aTime =\n              a.createdAt instanceof Date ? a.createdAt.getTime() : new Date(a.createdAt).getTime();\n            const bTime =\n              b.createdAt instanceof Date ? b.createdAt.getTime() : new Date(b.createdAt).getTime();\n            return aTime - bTime;\n          } catch (error) {\n            // If date parsing fails, fall back to createdAt comparison for deterministic ordering\n            console.warn(\n              'Date parsing failed in removeDuplicateGroups, using createdAt fallback:',\n              error\n            );\n            return a.createdAt.getTime() - b.createdAt.getTime();\n          }\n        });\n\n        // Remove all but the first\n        for (let i = 1; i < groups.length; i++) {\n          await deleteCustomGroup(groups[i].id);\n          removedCount++;\n        }\n      }\n    }\n\n    return removedCount;\n  } catch (error) {\n    console.error('Error in removeDuplicateGroups:', error);\n    return 0;\n  }\n};\n\n/**\n * Force recreate default groups with proper intensities from action files\n * This is useful when intensities need to be updated\n */\nexport const recreateDefaultGroups = async (): Promise<number> => {\n  // This function is no longer needed since migration handles creating groups\n  // Just return 0 to maintain compatibility\n  return 0;\n};\n\nexport const getAllAvailableGroups = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<CustomGroupPull[]> => {\n  try {\n    // Clean up any existing duplicates first\n    await removeDuplicateGroups(locale, gameMode);\n\n    // Get all groups for this locale/gameMode from Dexie\n    const groups = await getCustomGroups({ locale, gameMode });\n\n    // Additional safety deduplication by name (keep the first occurrence)\n    const uniqueGroups = groups.filter(\n      (group, index, self) => self.findIndex((g) => g.name === group.name) === index\n    );\n\n    return uniqueGroups;\n  } catch (error) {\n    console.error('❌ getAllAvailableGroups: Database error', {\n      locale,\n      gameMode,\n      error,\n    });\n    return [];\n  }\n};\n\n/**\n * Get custom groups that have associated custom tiles\n * Only returns groups that actually have tiles created for them\n */\nexport const getCustomGroupsWithTiles = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<CustomGroupPull[]> => {\n  try {\n    // Import getTiles from customTiles store\n    const { getTiles } = await import('./customTiles');\n\n    // Get all custom groups for this locale/gameMode\n    const allGroups = await getCurrentGroups(gameMode);\n\n    // Get all custom tiles for this locale/gameMode (only custom tiles, not default)\n    const customTiles = await getTiles({\n      locale,\n      gameMode,\n      isCustom: 1,\n    });\n\n    // Get unique group names that have custom tiles\n    const groupNamesWithTiles = new Set(customTiles.map((tile) => tile.group));\n\n    // Filter groups to only include those with tiles and are not default groups\n    const groupsWithTiles = allGroups.filter(\n      (group) => !group.isDefault && groupNamesWithTiles.has(group.name)\n    );\n\n    return groupsWithTiles;\n  } catch (error) {\n    console.error('Error in getCustomGroupsWithTiles:', error);\n    return [];\n  }\n};\n\n/**\n * Utility functions for post-migration runtime queries\n * These query Dexie instead of reading JSON files\n */\n\n/**\n * Get all available locales from migrated data\n */\nexport const getAvailableLocales = async (): Promise<string[]> => {\n  try {\n    const groups = await getCustomGroups({ isDefault: true });\n    const locales = [...new Set(groups.map((g) => g.locale))].sort();\n    return locales;\n  } catch (error) {\n    console.error('Error getting available locales:', error);\n    return ['en']; // fallback\n  }\n};\n\n/**\n * Get all available game modes for a specific locale\n */\nexport const getAvailableGameModes = async (locale?: string): Promise<string[]> => {\n  try {\n    const filters: Partial<CustomGroupFilters> = { isDefault: true };\n    if (locale) filters.locale = locale;\n\n    const groups = await getCustomGroups(filters);\n    const gameModes = [...new Set(groups.map((g) => g.gameMode))].sort();\n    return gameModes;\n  } catch (error) {\n    console.error('Error getting available game modes:', error);\n    return ['online']; // fallback\n  }\n};\n\n/**\n * Get all action group names for a specific locale and game mode\n */\nexport const getActionGroupsForMode = async (\n  locale: string,\n  gameMode: string\n): Promise<string[]> => {\n  try {\n    const groups = await getCustomGroups({ locale, gameMode, isDefault: true });\n    return groups.map((g) => g.name).sort();\n  } catch (error) {\n    console.error('Error getting action groups for mode:', error);\n    return [];\n  }\n};\n\n/**\n * Get all available action group names across all locales and game modes\n */\nexport const getAllActionGroupNames = async (): Promise<string[]> => {\n  try {\n    const groups = await getCustomGroups({ isDefault: true });\n    const groupNames = [...new Set(groups.map((g) => g.name))].sort();\n    return groupNames;\n  } catch (error) {\n    console.error('Error getting all action group names:', error);\n    return [];\n  }\n};\n\n/**\n * Get available groups with their locale and game mode information\n */\nexport const getGroupAvailability = async (): Promise<\n  {\n    groupName: string;\n    locales: string[];\n    gameModes: string[];\n    combinations: Array<{ locale: string; gameMode: string }>;\n  }[]\n> => {\n  try {\n    const groups = await getCustomGroups({ isDefault: true });\n    const availability = new Map<\n      string,\n      {\n        locales: Set<string>;\n        gameModes: Set<string>;\n        combinations: Array<{ locale: string; gameMode: string }>;\n      }\n    >();\n\n    groups.forEach((group) => {\n      if (!availability.has(group.name)) {\n        availability.set(group.name, {\n          locales: new Set(),\n          gameModes: new Set(),\n          combinations: [],\n        });\n      }\n\n      const groupData = availability.get(group.name);\n      if (groupData) {\n        groupData.locales.add(group.locale);\n        groupData.gameModes.add(group.gameMode);\n        groupData.combinations.push({ locale: group.locale, gameMode: group.gameMode });\n      } else {\n        console.error(`Unexpected error: group data not found for group: ${group.name}`);\n      }\n    });\n\n    return Array.from(availability.entries())\n      .map(([groupName, data]) => ({\n        groupName,\n        locales: Array.from(data.locales).sort(),\n        gameModes: Array.from(data.gameModes).sort(),\n        combinations: data.combinations,\n      }))\n      .sort((a, b) => a.groupName.localeCompare(b.groupName));\n  } catch (error) {\n    console.error('Error getting group availability:', error);\n    return [];\n  }\n};\n","import db from './store';\nimport { DBGameBoard } from '@/types/gameBoard';\n\nconst { gameBoard } = db;\n\nexport const getBoards = (): Promise<DBGameBoard[]> => {\n  return gameBoard.orderBy('title').toArray();\n};\n\nexport const getActiveBoard = async (): Promise<DBGameBoard | undefined> => {\n  return gameBoard.where('isActive').equals(1)?.first();\n};\n\nexport const getBoard = (id: number): Promise<DBGameBoard | undefined> => {\n  return gameBoard.get(id);\n};\n\nexport const addBoard = async (record: Partial<DBGameBoard>): Promise<number | undefined> => {\n  return gameBoard.add(record as DBGameBoard);\n};\n\nexport const updateBoard = async (\n  board: DBGameBoard,\n  record?: Partial<DBGameBoard>\n): Promise<number> => {\n  return gameBoard.update(board.id as number, { ...board, ...record });\n};\n\nexport const upsertBoard = async (record: Partial<DBGameBoard>): Promise<number | undefined> => {\n  const newData: DBGameBoard = {\n    title: record.title === undefined ? '' : record.title,\n    tiles: record.tiles || [],\n    isActive: record.isActive === undefined ? 1 : record.isActive,\n    tags: record.tags || [],\n    gameMode: record.gameMode || 'online',\n  };\n\n  // if we have tiles, we should have a title to go with it.\n  if (!newData?.title?.length && newData?.tiles?.length) {\n    return undefined;\n  }\n\n  const board = await gameBoard.where('title').equals(newData.title).first();\n\n  return db.transaction('rw', db.gameBoard, async () => {\n    if (newData.isActive) {\n      await deactivateAllBoards();\n    }\n\n    if (board) {\n      await updateBoard(board, record);\n      return board.id;\n    }\n\n    return await addBoard(newData);\n  });\n};\n\nexport const activateBoard = async (id: number): Promise<void> => {\n  const allBoards = await gameBoard.toArray();\n\n  const updatedBoards = allBoards.map((board) => ({\n    ...board,\n    isActive: board.id === id ? 1 : 0,\n  }));\n\n  await gameBoard.bulkPut(updatedBoards);\n};\n\nexport const deleteBoard = async (id: number): Promise<void> => {\n  await gameBoard.delete(id);\n};\n\nconst deactivateAllBoards = async (): Promise<void> => {\n  await gameBoard.where('isActive').equals(1).modify({ isActive: 0 });\n};\n","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...args) => api.dispatch(...args), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst removeStoreFromTrackedConnections = (name, store) => {\n  if (store === void 0) return;\n  const connectionInfo = trackedConnections.get(name);\n  if (!connectionInfo) return;\n  delete connectionInfo.stores[store];\n  if (Object.keys(connectionInfo.stores).length === 0) {\n    trackedConnections.delete(name);\n  }\n};\nconst findCallerName = (stack) => {\n  var _a, _b;\n  if (!stack) return void 0;\n  const traceLines = stack.split(\"\\n\");\n  const apiSetStateLineIndex = traceLines.findIndex(\n    (traceLine) => traceLine.includes(\"api.setState\")\n  );\n  if (apiSetStateLineIndex < 0) return void 0;\n  const callerLine = ((_a = traceLines[apiSetStateLineIndex + 1]) == null ? void 0 : _a.trim()) || \"\";\n  return (_b = /.+ (.+) .+/.exec(callerLine)) == null ? void 0 : _b[1];\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === void 0 ? {\n      type: anonymousActionType || findCallerName(new Error().stack) || \"anonymous\"\n    } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  api.devtools = {\n    cleanup: () => {\n      if (connection && typeof connection.unsubscribe === \"function\") {\n        connection.unsubscribe();\n      }\n      removeStoreFromTrackedConnections(options.name, store);\n    }\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && args[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...args);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState) return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, fn) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0) fn(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nfunction combine(initialState, create) {\n  return (...args) => Object.assign({}, initialState, create(...args));\n}\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer)),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persistImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            const migration = options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n            if (migration instanceof Promise) {\n              return migration.then((result) => [true, result]);\n            }\n            return [true, migration];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, void 0];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","import { ActionEntry } from '@/types';\nimport { Settings } from '@/types/Settings';\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\nconst defaultSettings: Settings = {\n  locale: 'en',\n  gameMode: 'online',\n  boardUpdated: false,\n  room: 'PUBLIC',\n  background: 'color',\n  roomBackground: 'useAppBackground',\n  selectedActions: {},\n  hasSeenRollButton: false,\n  themeMode: 'system',\n  playerDialog: true,\n};\n\ninterface SettingsStore {\n  settings: Settings;\n  updateSettings: (partial: Partial<Settings>) => void;\n  setLocale: (locale: string) => void;\n  resetSettings: () => void;\n  updateSelectedAction: (key: string, actionEntry: ActionEntry | null) => void;\n  removeSelectedAction: (key: string) => void;\n  clearSelectedActions: () => void;\n  getSelectedActionsByType: (type: string) => Record<string, ActionEntry>;\n}\n\nexport const useSettingsStore = create<SettingsStore>()(\n  persist(\n    (set) => ({\n      settings: defaultSettings,\n      updateSettings: (partial) =>\n        set((state) => ({\n          settings: { ...state.settings, ...partial },\n        })),\n      setLocale: (locale) =>\n        set((state) => ({\n          settings: { ...state.settings, locale },\n        })),\n      resetSettings: () => set({ settings: defaultSettings }),\n      updateSelectedAction: (key, actionEntry) =>\n        set((state) => {\n          const newSelectedActions = { ...state.settings.selectedActions };\n          if (actionEntry === null) {\n            delete newSelectedActions[key];\n          } else {\n            newSelectedActions[key] = actionEntry;\n          }\n          return {\n            settings: { ...state.settings, selectedActions: newSelectedActions },\n          };\n        }),\n      removeSelectedAction: (key) =>\n        set((state) => {\n          const newSelectedActions = { ...state.settings.selectedActions };\n          delete newSelectedActions[key];\n          return {\n            settings: { ...state.settings, selectedActions: newSelectedActions },\n          };\n        }),\n      clearSelectedActions: () =>\n        set((state) => ({\n          settings: { ...state.settings, selectedActions: {} },\n        })),\n      getSelectedActionsByType: (type: string): Record<string, ActionEntry> => {\n        const { selectedActions = {} } = useSettingsStore.getState().settings;\n        const actions: Record<string, ActionEntry> = selectedActions || {};\n        return Object.entries(actions)\n          .filter(([, entry]: [string, ActionEntry]) => entry.type === type)\n          .reduce((acc: Record<string, ActionEntry>, [key, entry]: [string, ActionEntry]) => {\n            acc[key] = entry;\n            return acc;\n          }, {});\n      },\n    }),\n    {\n      name: 'gameSettings', // localStorage key\n      partialize: (state) => ({ settings: state.settings }),\n    }\n  )\n);\n\n// Compatibility hook for useLocalStorage('gameSettings') pattern\nexport const useSettings = (): [Settings, (partial: Partial<Settings>) => void] => {\n  const { settings, updateSettings } = useSettingsStore();\n  return [settings, updateSettings];\n};\n\n// Compatibility hook for useGameSettings() pattern\nexport const useGameSettings = () => {\n  const { settings, updateSettings } = useSettingsStore();\n  return { settings, updateSettings };\n};\n","/**\n * Constants used across action-related components and services\n */\n\n/**\n * Default option that appears in all action groups for consistency\n * This ensures all action groups have a \"None\" option available\n */\nexport const DEFAULT_NONE_OPTION = 'None';\n\n/**\n * Cache time-to-live for unified action list in milliseconds\n * Actions are cached for 30 seconds to improve performance\n */\nexport const UNIFIED_ACTION_CACHE_TTL = 30000;\n\n/**\n * Delay in milliseconds between clearing data and syncing with remote server\n * This prevents race conditions during data sync operations\n */\nexport const SYNC_DELAY_MS = 500;\n\n/**\n * Common intensity labels used across the application\n * These map to translation keys for internationalization\n */\nexport const DEFAULT_INTENSITY_LABELS = {\n  /** Beginner level intensity */\n  BEGINNER: 'intensityLabels.beginner',\n  /** Intermediate level intensity */\n  INTERMEDIATE: 'intensityLabels.intermediate',\n  /** Advanced level intensity */\n  ADVANCED: 'intensityLabels.advanced',\n} as const;\n","import {\n  addCustomTile,\n  deleteAllIsCustomTiles as deleteAllCustomTiles,\n  getTiles,\n} from '@/stores/customTiles';\nimport { deleteAllCustomGroups, getCustomGroups, importCustomGroups } from '@/stores/customGroups';\nimport { doc, getDoc, setDoc } from 'firebase/firestore';\nimport { getBoards, upsertBoard } from '@/stores/gameBoard';\nimport { useSettingsStore } from '@/stores/settingsStore';\n\nimport { CustomGroupPull } from '@/types/customGroups';\nimport { CustomTilePull } from '@/types/customTiles';\nimport { Settings } from '@/types/Settings';\nimport { SYNC_DELAY_MS } from '@/constants/actionConstants';\nimport { getAuth } from 'firebase/auth';\nimport { getFirestore } from 'firebase/firestore';\n\ninterface GameBoard {\n  title: string;\n  tiles: any[];\n  tags?: string[];\n  gameMode?: string;\n  isActive?: number;\n}\n\n// Updated to use inline type instead of separate interface to avoid unused warning\n\nconst db = getFirestore();\n\n// Sync custom tiles to Firebase\nexport async function syncCustomTilesToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get all custom tiles from Dexie\n    const customTiles = await getTiles({ isCustom: 1 });\n\n    // Create a document in Firebase with all custom tiles\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        customTiles,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing custom tiles:', error);\n    return false;\n  }\n}\n\n// Sync custom groups to Firebase\nexport async function syncCustomGroupsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get all custom groups from Dexie\n    const customGroups = await getCustomGroups();\n\n    // Create a document in Firebase with all custom groups\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        customGroups,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing custom groups:', error);\n    return false;\n  }\n}\n\n// Sync game boards to Firebase\nexport async function syncGameBoardsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get all game boards from Dexie\n    const gameBoards = await getBoards();\n\n    if (!gameBoards.length) {\n      return true;\n    }\n\n    // Create a document in Firebase with all game boards\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        gameBoards,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing game boards:', error);\n    return false;\n  }\n}\n\n// Sync user settings (including theme preferences) to Firebase\nexport async function syncSettingsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get current settings from store\n    const { settings } = useSettingsStore.getState();\n\n    // Filter out local player settings - they should stay in React app only\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { localPlayers, ...settingsForFirebase } = settings;\n\n    // Create a document in Firebase with filtered user settings\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        settings: settingsForFirebase,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing settings:', error);\n    return false;\n  }\n}\n\n// Sync all data to Firebase\nexport async function syncAllDataToFirebase(): Promise<boolean> {\n  await syncCustomTilesToFirebase();\n  await syncCustomGroupsToFirebase();\n  await syncGameBoardsToFirebase();\n  await syncSettingsToFirebase();\n  return true;\n}\n\n// Sync data from Firebase to Dexie\nexport async function syncDataFromFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get user data from Firebase\n    const userDocRef = doc(db, 'user-data', user.uid);\n    const userDoc = await getDoc(userDocRef);\n\n    if (!userDoc.exists()) {\n      return false;\n    }\n\n    const userData = userDoc.data();\n\n    // Import custom tiles\n    if (userData.customTiles !== undefined) {\n      // Clear existing custom tiles before importing\n      await deleteAllCustomTiles();\n\n      // Add a delay after clearing custom tiles before syncing with remote server\n      await new Promise((resolve) => setTimeout(resolve, SYNC_DELAY_MS));\n\n      // Only import if there are tiles to import\n      if (userData.customTiles && userData.customTiles.length > 0) {\n        for (const tile of userData.customTiles as CustomTilePull[]) {\n          try {\n            const existingTile = await getTiles({\n              gameMode: tile.gameMode,\n              group: tile.group,\n              intensity: tile.intensity,\n              action: tile.action,\n            });\n\n            if (existingTile.length === 0) {\n              await addCustomTile(tile);\n            }\n          } catch (error) {\n            console.error('Error importing custom tile:', tile, error);\n          }\n        }\n        // Successfully processed and imported custom tiles from Firebase into local Dexie database\n      } else {\n        // Firebase data contains empty custom tiles array - local database cleared but no new tiles to import\n      }\n    }\n\n    // Import custom groups\n    if (userData.customGroups !== undefined) {\n      // Clear existing custom groups before importing\n      await deleteAllCustomGroups();\n\n      // Add a delay after clearing custom groups before syncing with remote server\n      await new Promise((resolve) => setTimeout(resolve, SYNC_DELAY_MS));\n\n      // Only import if there are groups to import\n      if (userData.customGroups && userData.customGroups.length > 0) {\n        try {\n          await importCustomGroups(userData.customGroups as CustomGroupPull[]);\n          // Successfully bulk imported custom groups from Firebase with validation and error handling\n        } catch (error) {\n          console.error('Error importing custom groups:', error);\n        }\n      } else {\n        // Firebase data contains empty custom groups array - local database cleared but no new groups to import\n      }\n    }\n\n    // Import game boards\n    if (userData.gameBoards && userData.gameBoards.length > 0) {\n      for (const board of userData.gameBoards as GameBoard[]) {\n        await upsertBoard({\n          title: board.title,\n          tiles: board.tiles,\n          tags: board.tags || [],\n          gameMode: board.gameMode || 'online',\n          isActive: board.isActive || 0,\n        });\n      }\n      // Successfully imported all game boards from Firebase, upserting each board with proper defaults for missing fields\n    }\n\n    // Import user settings (including theme preferences)\n    if (userData.settings) {\n      try {\n        const { updateSettings } = useSettingsStore.getState();\n\n        // Merge Firebase settings with local settings\n        // Only update if the Firebase data is newer or has different values\n        const firebaseSettings = userData.settings as Partial<Settings>;\n        updateSettings(firebaseSettings);\n\n        // Successfully imported user settings from Firebase including theme preferences\n      } catch (error) {\n        console.error('Error importing settings:', error);\n      }\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing data:', error);\n    return false;\n  }\n}\n\n// Variable to store the interval ID for periodic syncing\nlet syncIntervalId: number | null = null;\n\n// Start periodic syncing from Firebase (every 5 minutes)\nexport function startPeriodicSync(intervalMinutes = 5): boolean {\n  // Clear any existing interval first\n  stopPeriodicSync();\n\n  // Convert minutes to milliseconds\n  const intervalMs = intervalMinutes * 60 * 1000;\n\n  // Set up the interval\n  syncIntervalId = window.setInterval(async () => {\n    const auth = getAuth();\n    if (auth.currentUser && !auth.currentUser.isAnonymous) {\n      await syncDataFromFirebase();\n    }\n  }, intervalMs);\n\n  return true;\n}\n\n// Stop periodic syncing\nexport function stopPeriodicSync(): boolean {\n  if (syncIntervalId) {\n    window.clearInterval(syncIntervalId);\n    syncIntervalId = null;\n    return true;\n  }\n  return false;\n}\n\n// Check if periodic sync is active\nexport function isPeriodicSyncActive(): boolean {\n  return syncIntervalId !== null;\n}\n","import React, { useEffect, useMemo, useState, useRef, ReactNode, useCallback } from 'react';\nimport { getAuth } from 'firebase/auth';\nimport {\n  loginAnonymously,\n  updateDisplayName,\n  loginWithEmail,\n  loginWithGoogle,\n  registerWithEmail,\n  resetPassword,\n  convertAnonymousAccount,\n  logout,\n  wipeAllAppData,\n} from '@/services/firebase';\nimport {\n  syncDataFromFirebase,\n  syncAllDataToFirebase,\n  startPeriodicSync,\n  stopPeriodicSync,\n} from '@/services/syncService';\nimport { User } from '@/types';\nimport { getErrorMessage } from '@/types/errors';\n\nexport interface SyncStatus {\n  syncing: boolean;\n  lastSync: Date | null;\n}\n\nexport interface AuthContextType {\n  user: User | null;\n  loading: boolean;\n  initializing: boolean;\n  error: string | null;\n  syncStatus: SyncStatus;\n  login: (displayName?: string) => Promise<User | null>;\n  loginEmail: (email: string, password: string) => Promise<User>;\n  loginGoogle: () => Promise<User>;\n  register: (email: string, password: string, displayName: string) => Promise<User>;\n  updateUser: (displayName?: string) => Promise<User | null>;\n  forgotPassword: (email: string) => Promise<boolean>;\n  convertToRegistered: (email: string, password: string) => Promise<User>;\n  logout: () => Promise<void>;\n  wipeAllData: () => Promise<void>;\n  syncData: () => Promise<boolean>;\n  isAnonymous: boolean;\n}\n\n// eslint-disable-next-line react-refresh/only-export-components\nexport const AuthContext = React.createContext<AuthContextType | undefined>(undefined);\n\ninterface AuthProviderProps {\n  children: ReactNode;\n  [key: string]: unknown;\n}\n\nfunction AuthProvider(props: AuthProviderProps): JSX.Element {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState<boolean>(false); // Changed: false by default for immediate UI\n  const [initializing, setInitializing] = useState<boolean>(true); // New: tracks initial auth check\n  const [error, setError] = useState<string | null>(null);\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({ syncing: false, lastSync: null });\n\n  // Debounce mechanism for sync operations\n  const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Track if initial auth check is complete\n  const authInitializedRef = useRef<boolean>(false);\n\n  // Function to safely perform sync operations with debouncing\n  const performSync = useCallback(\n    async (syncFunction: () => Promise<boolean>): Promise<boolean> => {\n      // Clear any pending sync timeout\n      if (syncTimeoutRef.current) {\n        clearTimeout(syncTimeoutRef.current);\n        syncTimeoutRef.current = null;\n      }\n\n      // Return early if user is not logged in or is anonymous\n      if (!user || user.isAnonymous) return false;\n\n      try {\n        setSyncStatus({ syncing: true, lastSync: syncStatus.lastSync });\n        await syncFunction();\n        setSyncStatus({ syncing: false, lastSync: new Date() });\n        return true;\n      } catch (err: unknown) {\n        console.error('Sync error:', err);\n        if (err instanceof Error) {\n          setError(err.message);\n        } else {\n          setError('An unknown error occurred');\n        }\n        setSyncStatus({ syncing: false, lastSync: syncStatus.lastSync });\n        return false;\n      }\n    },\n    [user, syncTimeoutRef, setSyncStatus, syncStatus.lastSync, setError]\n  );\n  async function login(displayName = ''): Promise<User | null> {\n    try {\n      const loggedInUser = await loginAnonymously(displayName);\n      setUser(loggedInUser);\n      return loggedInUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }\n\n  async function loginEmail(email: string, password: string): Promise<User> {\n    try {\n      setLoading(true);\n      const loggedInUser = await loginWithEmail(email, password);\n      setUser(loggedInUser);\n\n      // Sync will happen via onAuthStateChanged\n      return loggedInUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function loginGoogle(): Promise<User> {\n    try {\n      setLoading(true);\n      const loggedInUser = await loginWithGoogle();\n      setUser(loggedInUser);\n\n      // Sync will happen via onAuthStateChanged\n      return loggedInUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function register(email: string, password: string, displayName: string): Promise<User> {\n    try {\n      setLoading(true);\n      const registeredUser = await registerWithEmail(email, password, displayName);\n      setUser(registeredUser);\n      return registeredUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function forgotPassword(email: string): Promise<boolean> {\n    try {\n      await resetPassword(email);\n      return true;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }\n\n  const convertToRegistered = useCallback(\n    async (email: string, password: string): Promise<User> => {\n      try {\n        setLoading(true);\n        const convertedUser = await convertAnonymousAccount(email, password);\n        setUser(convertedUser);\n\n        // Sync local data to Firebase after conversion\n        await performSync(syncAllDataToFirebase);\n\n        return convertedUser;\n      } catch (err) {\n        if (err instanceof Error) {\n          setError(err.message);\n        }\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [setLoading, setUser, performSync, setError]\n  );\n\n  async function updateUser(displayName = ''): Promise<User | null> {\n    try {\n      const updatedUser = await updateDisplayName(displayName);\n      setUser(updatedUser);\n      return updatedUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }\n\n  const logoutUser = useCallback(async (): Promise<void> => {\n    try {\n      // Sync data to Firebase before logout if user is not anonymous\n      if (user && !user.isAnonymous) {\n        // Add timeout to make sure logout doesn't hang\n        const syncPromise = performSync(syncAllDataToFirebase);\n        const timeoutPromise = new Promise((resolve) => setTimeout(resolve, 5000, false));\n        await Promise.race([syncPromise, timeoutPromise]);\n      }\n\n      await logout();\n      setUser(null);\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [user, performSync, setUser, setError]);\n\n  const wipeAllAppDataAndReload = useCallback(async (): Promise<void> => {\n    try {\n      // Use the comprehensive wipe function from firebase service\n      await wipeAllAppData();\n\n      // Clear user state\n      setUser(null);\n\n      // Reload the page to ensure all React state is reset\n      window.location.reload();\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [setUser, setError]);\n\n  const syncData = useCallback(async (): Promise<boolean> => {\n    return performSync(syncAllDataToFirebase);\n  }, [performSync]);\n\n  useEffect(() => {\n    const auth = getAuth();\n    const unsubscribe = auth.onAuthStateChanged((userData: User | null) => {\n      setUser(userData || null);\n\n      // Mark initial auth check as complete\n      if (!authInitializedRef.current) {\n        authInitializedRef.current = true;\n        setInitializing(false);\n      }\n\n      // If user is logged in and not anonymous, defer sync operations\n      if (userData && !userData.isAnonymous) {\n        // Defer sync to not block UI rendering - use requestIdleCallback or fallback\n        const deferSync = () => {\n          // Use debounced sync to prevent multiple rapid syncs\n          if (syncTimeoutRef.current) {\n            clearTimeout(syncTimeoutRef.current);\n          }\n\n          syncTimeoutRef.current = setTimeout(() => {\n            setSyncStatus({ syncing: true, lastSync: null });\n\n            // Handle case where syncDataFromFirebase might not be defined (e.g., in tests)\n            let syncPromise;\n            try {\n              syncPromise = syncDataFromFirebase ? syncDataFromFirebase() : Promise.resolve(false);\n            } catch (error) {\n              console.warn('syncDataFromFirebase is not available:', error);\n              syncPromise = Promise.resolve(false);\n            }\n\n            // Ensure syncPromise is always a Promise\n            if (!syncPromise || typeof syncPromise.then !== 'function') {\n              syncPromise = Promise.resolve(false);\n            }\n\n            syncPromise\n              .then(() => {\n                setSyncStatus({ syncing: false, lastSync: new Date() });\n                // Start periodic sync after initial sync completes\n                if (startPeriodicSync) {\n                  startPeriodicSync();\n                }\n              })\n              .catch((err) => {\n                console.error('Error syncing from Firebase:', err);\n                setSyncStatus({ syncing: false, lastSync: null });\n              })\n              .finally(() => {\n                syncTimeoutRef.current = null;\n              });\n          }, 1000); // Increased debounce to allow UI to render first\n        };\n\n        if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {\n          (\n            window as Window & {\n              requestIdleCallback: (callback: () => void, options?: { timeout: number }) => void;\n            }\n          ).requestIdleCallback(deferSync, { timeout: 5000 });\n        } else {\n          // Fallback for browsers without requestIdleCallback\n          setTimeout(deferSync, 100);\n        }\n      } else {\n        // User is logged out or anonymous, stop periodic sync\n        if (stopPeriodicSync) {\n          stopPeriodicSync();\n        }\n      }\n    });\n\n    // Make auth context available globally for middleware\n    (window as Window & { authContext?: { user: User | null } }).authContext = { user: null };\n\n    // Clean up function\n    return () => {\n      if (typeof unsubscribe === 'function') {\n        unsubscribe();\n      }\n      if (syncTimeoutRef.current) {\n        clearTimeout(syncTimeoutRef.current);\n      }\n      // Make sure to stop periodic sync when component unmounts\n      if (stopPeriodicSync) {\n        stopPeriodicSync();\n      }\n      (window as Window & { authContext?: { user: User | null } }).authContext = undefined;\n    };\n  }, []);\n\n  // Update global auth context when user changes\n  useEffect(() => {\n    const globalWindow = window as Window & { authContext?: { user: User | null } };\n    if (globalWindow.authContext) {\n      globalWindow.authContext.user = user;\n    }\n  }, [user]);\n  const value = useMemo(\n    () => ({\n      user,\n      loading,\n      initializing,\n      error,\n      syncStatus,\n      login,\n      loginEmail,\n      loginGoogle,\n      register,\n      updateUser,\n      forgotPassword,\n      convertToRegistered,\n      logout: logoutUser,\n      wipeAllData: wipeAllAppDataAndReload,\n      syncData,\n      isAnonymous: user?.isAnonymous || false,\n    }),\n    [\n      user,\n      loading,\n      initializing,\n      error,\n      syncStatus,\n      convertToRegistered,\n      logoutUser,\n      wipeAllAppDataAndReload,\n      syncData,\n    ]\n  );\n\n  return <AuthContext.Provider value={value} {...props} />;\n}\n\nexport { AuthProvider };\n","import { Suspense, lazy, useContext } from 'react';\nimport { ProvidersProps } from '../../types/app';\nimport AppSkeleton from '../AppSkeleton';\nimport { AuthContext, AuthProvider } from '../../context/auth';\n\n// Lazy load ALL heavy dependencies\nconst MuiProviders = lazy(() => import('../MuiProviders'));\nconst RouterSetup = lazy(() => import('../RouterSetup'));\nconst ThemeProvider = lazy(() =>\n  import('../../context/theme').then((m) => ({ default: m.ThemeProvider }))\n);\nconst MigrationProvider = lazy(() =>\n  import('../../context/migration').then((m) => ({ default: m.MigrationProvider }))\n);\n// UserListProvider moved to RouterSetup to access route params\nconst ScheduleProvider = lazy(() =>\n  import('../../context/schedule').then((m) => ({ default: m.ScheduleProvider }))\n);\n\nfunction Providers({ children }: ProvidersProps) {\n  return (\n    <Suspense fallback={<AppSkeleton />}>\n      <MigrationProvider>\n        <ScheduleProvider>{children}</ScheduleProvider>\n      </MigrationProvider>\n    </Suspense>\n  );\n}\n\nfunction AppContent() {\n  const auth = useContext(AuthContext);\n\n  // Show skeleton during auth loading\n  if (!auth || auth.initializing) {\n    return <AppSkeleton />;\n  }\n\n  return (\n    <Suspense fallback={<AppSkeleton />}>\n      <ThemeProvider>\n        <Providers>\n          <MuiProviders>\n            <RouterSetup />\n          </MuiProviders>\n        </Providers>\n      </ThemeProvider>\n    </Suspense>\n  );\n}\n\nexport default function FullApp() {\n  return (\n    <AuthProvider>\n      <AppContent />\n    </AuthProvider>\n  );\n}\n"],"file":"js/chunk-DvmTZbFC.js"}