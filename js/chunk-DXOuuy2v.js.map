{"version":3,"mappings":"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","names":["shouldSilenceError","error","logError","level","context","details","errorMessage","logMessage","safeLocalStorage","key","value","item","withErrorHandling","operation","fallback","isDuplicateError","isMigrationInProgress","status","MIGRATION_IN_PROGRESS_KEY","STALE_LOCK_TIMEOUT","setMigrationInProgress","inProgress","isLanguageMigrationInProgress","locale","CURRENT_LANGUAGE_MIGRATION_KEY","setLanguageMigrationInProgress","l","isBackgroundMigrationInProgress","BACKGROUND_MIGRATION_IN_PROGRESS_KEY","setBackgroundMigrationInProgress","markMigrationComplete","MIGRATION_VERSION","MIGRATION_KEY","markLanguageMigrated","bgStatus","BACKGROUND_MIGRATION_KEY","completedSet","markBackgroundMigrationInProgress","isMigrationCompleted","isCurrentLanguageMigrationCompleted","SUPPORTED_LANGUAGES","lang","getMigrationStatus","resetMigrationStatus","checkAndHandleVersionChange","oldVersion","clearAllMigrationData","getCurrentLanguage","resolved","i18n","currentLang","storedLanguage","browserLang","getActionGroupNames","gameMode","allActionFiles","__vitePreload","existingGroups","targetPath","filePath","variant","fileName","groupName","createDeterministicGroupId","baseId","hash","i","char","hashStr","importActionFile","actionFile","__variableDynamicImportRuntimeHelper","label","type","actions","intensities","intensityName","index","deterministicId","customGroup","customTiles","actionList","intensity","action","addCustomGroupSafely","addCustomGroup","validateTilesHaveGroupId","tiles","tile","getNewTiles","existingTiles","getTiles","existing","importCustomTilesSafely","importCustomTiles","importGroupsForLocaleAndGameMode","groupNames","groupsImported","tilesImported","db","module","getCustomGroupByName","result","newTiles","tilesAdded","cleanupDuplicateGroups","locales","totalDuplicatesRemoved","gameModes","GAME_MODES","duplicatesRemoved","removeDuplicateGroups","migrateActionGroups","cleanupDuplicatesIfNeeded","_a","_b","_c","migrateCurrentLanguage","currentLocale","waitForMigrationCompletion","migrateRemainingLanguages","excludeLocale","remainingLocales","resolve","BACKGROUND_MIGRATION_DELAY","n","completedLanguages","queueBackgroundMigration","IDLE_CALLBACK_TIMEOUT","QUEUE_BACKGROUND_MIGRATION_DELAY","ensureLanguageMigrated","runMigrationIfNeeded","versionChanged","success","forceFreshMigration","checkInProgress","operationName","startTime","MIGRATION_TIMEOUT"],"ignoreList":[],"sources":["../../src/services/migration/errorHandling.ts","../../src/services/migration/statusManager.ts","../../src/services/migration/versionManager.ts","../../src/services/migration/fileDiscovery.ts","../../src/services/migration/groupIdMigration.ts","../../src/services/migration/importOperations.ts","../../src/services/migration/index.ts"],"sourcesContent":["/**\n * Centralized error handling utilities for the migration service\n */\n\nexport type ErrorLevel = 'debug' | 'warn' | 'error';\n\n/**\n * Check if an error should be silenced (non-critical Dexie timing issues)\n */\nconst shouldSilenceError = (error: unknown): boolean => {\n  if (error instanceof Error) {\n    // Silence Dexie \"Transaction committed too early\" errors\n    // This is a timing issue that doesn't affect functionality\n    return error.message.includes('Transaction committed too early');\n  }\n  return false;\n};\n\n/**\n * Standardized error logging with consistent format\n */\nexport const logError = (\n  level: ErrorLevel,\n  context: string,\n  error: unknown,\n  details?: any\n): void => {\n  // Silence specific non-critical errors\n  if (shouldSilenceError(error)) {\n    return;\n  }\n\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  const logMessage = `[Migration ${context}] ${errorMessage}`;\n\n  if (details) {\n    console[level](logMessage, details);\n  } else {\n    console[level](logMessage);\n  }\n};\n\n/**\n * Safe localStorage operation wrapper\n */\nexport const safeLocalStorage = {\n  getItem: (key: string): string | null => {\n    try {\n      return localStorage.getItem(key);\n    } catch (error) {\n      logError('warn', 'localStorage.getItem', error, { key });\n      return null;\n    }\n  },\n\n  setItem: (key: string, value: string): boolean => {\n    try {\n      localStorage.setItem(key, value);\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.setItem', error, { key });\n      return false;\n    }\n  },\n\n  removeItem: (key: string): boolean => {\n    try {\n      localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.removeItem', error, { key });\n      return false;\n    }\n  },\n\n  getJSON: <T>(key: string): T | null => {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      logError('warn', 'localStorage.getJSON', error, { key });\n      return null;\n    }\n  },\n\n  setJSON: (key: string, value: any): boolean => {\n    try {\n      localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.setJSON', error, { key });\n      return false;\n    }\n  },\n};\n\n/**\n * Async operation wrapper with consistent error handling\n */\nexport const withErrorHandling = async <T>(\n  operation: () => Promise<T>,\n  context: string,\n  fallback?: T\n): Promise<T | null> => {\n  try {\n    return await operation();\n  } catch (error) {\n    logError('error', context, error);\n    return fallback ?? null;\n  }\n};\n\n/**\n * Retry wrapper for potentially failing operations\n */\nexport const withRetry = async <T>(\n  operation: () => Promise<T>,\n  maxRetries: number = 3,\n  delay: number = 100\n): Promise<T> => {\n  let lastError: any;\n\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      if (attempt === maxRetries) {\n        throw error;\n      }\n      await new Promise((resolve) => setTimeout(resolve, delay * attempt));\n    }\n  }\n\n  throw lastError;\n};\n\n/**\n * Check if an error indicates a duplicate/conflict that can be safely ignored\n */\nexport const isDuplicateError = (error: unknown): boolean => {\n  if (error instanceof Error) {\n    return (\n      error.message.includes('already exists') ||\n      error.message.includes('duplicate') ||\n      error.message.includes('unique constraint')\n    );\n  }\n  return false;\n};\n\n/**\n * Safe timeout wrapper for promises\n */\nexport const withTimeout = <T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  errorMessage: string = 'Operation timed out'\n): Promise<T> => {\n  return Promise.race([\n    promise,\n    new Promise<never>((_, reject) => setTimeout(() => reject(new Error(errorMessage)), timeoutMs)),\n  ]);\n};\n","/**\n * Status management module for localStorage-based migration tracking\n */\n\nimport {\n  MIGRATION_KEY,\n  BACKGROUND_MIGRATION_KEY,\n  MIGRATION_IN_PROGRESS_KEY,\n  CURRENT_LANGUAGE_MIGRATION_KEY,\n  BACKGROUND_MIGRATION_IN_PROGRESS_KEY,\n  MIGRATION_VERSION,\n  STALE_LOCK_TIMEOUT,\n  SUPPORTED_LANGUAGES,\n} from './constants';\nimport {\n  MigrationStatus,\n  BackgroundMigrationStatus,\n  MigrationLockStatus,\n  LanguageMigrationStatus,\n  MigrationStatusSnapshot,\n} from './types';\nimport { safeLocalStorage, logError } from './errorHandling';\n\n/**\n * Check if main migration is in progress\n */\nexport const isMigrationInProgress = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationLockStatus>(MIGRATION_IN_PROGRESS_KEY);\n  if (!status) return false;\n\n  // Auto-cleanup stale locks\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT) {\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n    return false;\n  }\n\n  return status.inProgress;\n};\n\n/**\n * Set main migration progress status\n */\nexport const setMigrationInProgress = (inProgress: boolean): void => {\n  if (inProgress) {\n    const status: MigrationLockStatus = {\n      inProgress: true,\n      startedAt: new Date().toISOString(),\n    };\n    safeLocalStorage.setJSON(MIGRATION_IN_PROGRESS_KEY, status);\n  } else {\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n  }\n};\n\n/**\n * Check if language migration is in progress\n */\nexport const isLanguageMigrationInProgress = (locale: string): boolean => {\n  const status = safeLocalStorage.getJSON<LanguageMigrationStatus>(CURRENT_LANGUAGE_MIGRATION_KEY);\n  if (!status) return false;\n\n  // Auto-cleanup stale locks\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT) {\n    safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    return false;\n  }\n\n  return status.locales && status.locales.includes(locale);\n};\n\n/**\n * Set language migration progress status\n */\nexport const setLanguageMigrationInProgress = (locale: string, inProgress: boolean): void => {\n  const status = safeLocalStorage.getJSON<LanguageMigrationStatus>(\n    CURRENT_LANGUAGE_MIGRATION_KEY\n  ) || {\n    locales: [],\n    startedAt: new Date().toISOString(),\n  };\n\n  if (inProgress) {\n    if (!status.locales.includes(locale)) {\n      status.locales.push(locale);\n      status.startedAt = new Date().toISOString();\n    }\n  } else {\n    status.locales = status.locales.filter((l) => l !== locale);\n    if (status.locales.length === 0) {\n      safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n      return;\n    }\n  }\n\n  safeLocalStorage.setJSON(CURRENT_LANGUAGE_MIGRATION_KEY, status);\n};\n\n/**\n * Check if background migration is in progress\n */\nexport const isBackgroundMigrationInProgress = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationLockStatus>(\n    BACKGROUND_MIGRATION_IN_PROGRESS_KEY\n  );\n  if (!status) return false;\n\n  // Auto-cleanup stale locks (longer timeout for background operations)\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT * 2) {\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n    return false;\n  }\n\n  return status.inProgress;\n};\n\n/**\n * Set background migration progress status\n */\nexport const setBackgroundMigrationInProgress = (inProgress: boolean): void => {\n  if (inProgress) {\n    const status: MigrationLockStatus = {\n      inProgress: true,\n      startedAt: new Date().toISOString(),\n    };\n    safeLocalStorage.setJSON(BACKGROUND_MIGRATION_IN_PROGRESS_KEY, status);\n  } else {\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n  }\n};\n\n/**\n * Mark migration as completed\n */\nexport const markMigrationComplete = (): void => {\n  const status: MigrationStatus = {\n    version: MIGRATION_VERSION,\n    completed: true,\n    completedAt: new Date(),\n  };\n  safeLocalStorage.setJSON(MIGRATION_KEY, status);\n};\n\n/**\n * Mark a specific language as migrated in background status\n */\nexport const markLanguageMigrated = (locale: string): void => {\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(\n    BACKGROUND_MIGRATION_KEY\n  ) || {\n    version: MIGRATION_VERSION,\n    completedLanguages: [],\n    inProgress: false,\n  };\n\n  // Use Set to ensure uniqueness and atomic update\n  const completedSet = new Set(bgStatus.completedLanguages);\n  completedSet.add(locale);\n  bgStatus.completedLanguages = Array.from(completedSet);\n\n  safeLocalStorage.setJSON(BACKGROUND_MIGRATION_KEY, bgStatus);\n};\n\n/**\n * Mark background migration as in progress\n */\nexport const markBackgroundMigrationInProgress = (inProgress: boolean): void => {\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(\n    BACKGROUND_MIGRATION_KEY\n  ) || {\n    version: MIGRATION_VERSION,\n    completedLanguages: [],\n    inProgress: false,\n  };\n\n  bgStatus.inProgress = inProgress;\n  if (inProgress) {\n    bgStatus.startedAt = new Date();\n  } else {\n    bgStatus.completedAt = new Date();\n  }\n\n  safeLocalStorage.setJSON(BACKGROUND_MIGRATION_KEY, bgStatus);\n};\n\n/**\n * Check if migration has been completed\n */\nexport const isMigrationCompleted = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n  if (!status) return false;\n\n  return status.completed && status.version === MIGRATION_VERSION;\n};\n\n/**\n * Check if current language migration has been completed\n */\nexport const isCurrentLanguageMigrationCompleted = (locale: string): boolean => {\n  // Check background migration status for specific language\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(BACKGROUND_MIGRATION_KEY);\n\n  if (bgStatus && bgStatus.completedLanguages.includes(locale)) {\n    return true;\n  }\n\n  // Fallback: check if full migration is complete AND all languages are done\n  const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n  if (status && status.completed && status.version === MIGRATION_VERSION) {\n    // Only return true if this is a full migration (not just current language)\n    if (bgStatus) {\n      return SUPPORTED_LANGUAGES.every((lang) => bgStatus.completedLanguages.includes(lang));\n    }\n    // If no background status, assume full migration means all languages are done\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Get migration status for debugging\n */\nexport const getMigrationStatus = (): MigrationStatusSnapshot => {\n  return {\n    main: safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY),\n    background: safeLocalStorage.getJSON<BackgroundMigrationStatus>(BACKGROUND_MIGRATION_KEY),\n  };\n};\n\n/**\n * Reset migration status (for debugging/development)\n */\nexport const resetMigrationStatus = (): void => {\n  try {\n    safeLocalStorage.removeItem(MIGRATION_KEY);\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n    safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n  } catch (error) {\n    logError('error', 'resetMigrationStatus', error);\n  }\n};\n","/**\n * Version management module for handling version checks and updates\n */\n\nimport {\n  MIGRATION_KEY,\n  BACKGROUND_MIGRATION_KEY,\n  MIGRATION_IN_PROGRESS_KEY,\n  CURRENT_LANGUAGE_MIGRATION_KEY,\n  BACKGROUND_MIGRATION_IN_PROGRESS_KEY,\n  MIGRATION_VERSION,\n} from './constants';\nimport { MigrationStatus, VersionCheckResult } from './types';\nimport { safeLocalStorage, logError } from './errorHandling';\n\n/**\n * Check if migration version has changed and clear outdated data\n */\nexport const checkAndHandleVersionChange = (): VersionCheckResult => {\n  try {\n    const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n    if (!status) {\n      return { versionChanged: false };\n    }\n\n    const oldVersion = status.version;\n    const versionChanged = oldVersion !== MIGRATION_VERSION;\n\n    if (versionChanged) {\n      // Clear all migration-related localStorage\n      clearAllMigrationData();\n      return { versionChanged: true, oldVersion };\n    }\n\n    return { versionChanged: false, oldVersion };\n  } catch (error) {\n    logError('error', 'checkAndHandleVersionChange', error);\n    return { versionChanged: false };\n  }\n};\n\n/**\n * Clear all migration-related data from localStorage\n */\nexport const clearAllMigrationData = (): void => {\n  safeLocalStorage.removeItem(MIGRATION_KEY);\n  safeLocalStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n  safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n  safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n  safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n};\n\n/**\n * Get current migration version\n */\nexport const getCurrentMigrationVersion = (): string => {\n  return MIGRATION_VERSION;\n};\n\n/**\n * Check if a version change requires data migration\n */\nexport const requiresDataMigration = (oldVersion?: string): boolean => {\n  if (!oldVersion) return true;\n\n  // Add logic here for version-specific migration requirements\n  // For now, any version change requires migration\n  return oldVersion !== MIGRATION_VERSION;\n};\n","/**\n * File discovery utilities for dynamic locale and game mode detection\n */\n\nimport { SUPPORTED_LANGUAGES } from './constants';\nimport { logError } from './errorHandling';\nimport i18n from '@/i18n';\n\n/**\n * Get current user language from i18next with fallbacks\n */\nexport const getCurrentLanguage = async (): Promise<string> => {\n  try {\n    // First try: get current language from i18next using proper API\n    const resolved = i18n.resolvedLanguage;\n    if (resolved !== undefined) {\n      return resolved;\n    }\n\n    // Second try: get language from i18next instance\n    const currentLang = i18n.language;\n    if (currentLang !== undefined) {\n      return currentLang;\n    }\n\n    // Third try: localStorage fallback\n    const storedLanguage = localStorage.getItem('i18nextLng');\n    if (storedLanguage && storedLanguage !== 'undefined') {\n      return storedLanguage;\n    }\n\n    // Fourth try: browser language with proper validation\n    if (typeof navigator !== 'undefined' && navigator.language) {\n      const browserLang = navigator.language.split('-')[0];\n      if (SUPPORTED_LANGUAGES.includes(browserLang as (typeof SUPPORTED_LANGUAGES)[number])) {\n        return browserLang;\n      }\n    }\n\n    // Final fallback: English\n    return 'en';\n  } catch (error) {\n    logError('error', 'getCurrentLanguage', error);\n    return 'en'; // Safe fallback\n  }\n};\n\n/**\n * Dynamically discover action group names for a specific locale and game mode\n * Uses Vite's import.meta.glob to automatically discover all JSON files at build time\n */\nexport const getActionGroupNames = async (locale: string, gameMode: string): Promise<string[]> => {\n  // Use Vite's glob import to get all action group files for all locales and game modes\n  // This automatically discovers files at build time, eliminating the need for hardcoded lists\n  const allActionFiles = import.meta.glob('@/locales/*/*/*.json');\n\n  const existingGroups: string[] = [];\n  const targetPath = `@/locales/${locale}/${gameMode}/`;\n\n  // Filter for files matching the current locale and game mode\n  for (const filePath of Object.keys(allActionFiles)) {\n    // Check both @/ prefixed paths and resolved paths\n    const pathVariants = [\n      targetPath, // @/locales/en/online/\n      targetPath.replace('@/', '/src/'), // /src/locales/en/online/\n      `/${locale}/${gameMode}/`, // /en/online/\n      `locales/${locale}/${gameMode}/`, // locales/en/online/\n    ];\n\n    const pathMatches = pathVariants.some((variant) => filePath.includes(variant));\n    if (pathMatches) {\n      // Extract the group name from the file path\n      const fileName = filePath.split('/').pop();\n      if (fileName?.endsWith('.json')) {\n        const groupName = fileName.replace('.json', '');\n\n        try {\n          // Verify the file can be imported (additional safety check)\n          await allActionFiles[filePath]();\n          existingGroups.push(groupName);\n        } catch (error) {\n          // File exists but can't be imported, skip it\n          logError('warn', `getActionGroupNames: ${groupName} for ${locale}/${gameMode}`, error);\n        }\n      }\n    }\n  }\n\n  return existingGroups.sort(); // Sort for consistent ordering\n};\n","/**\n * Group ID Migration Service\n *\n * Migrates tiles from string-based group matching to foreign key group_id relationships\n * for improved data consistency, performance, and sync reliability.\n *\n * CRITICAL: Handles deterministic IDs for default groups to ensure consistency across devices\n */\n\nimport db from '@/stores/store';\nimport { getCustomGroups } from '@/stores/customGroups';\nimport { updateCustomTile } from '@/stores/customTiles';\n\n/**\n * Creates a deterministic group ID for default groups\n * This ensures default groups have the same ID across all devices for sync consistency\n */\nexport function createDeterministicGroupId(\n  groupName: string,\n  locale: string,\n  gameMode: string\n): string {\n  // Create a consistent hash-like ID based on group properties\n  // Format: default-{locale}-{gameMode}-{groupName}\n  // This ensures all devices generate the same ID for default groups\n  const baseId = `default-${locale}-${gameMode}-${groupName}`;\n\n  // Create a simple hash to keep IDs reasonably short but still unique\n  let hash = 0;\n  for (let i = 0; i < baseId.length; i++) {\n    const char = baseId.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n\n  // Convert to a positive hex string with prefix\n  const hashStr = Math.abs(hash).toString(16).padStart(8, '0');\n  return `default_${locale}_${gameMode}_${groupName}_${hashStr}`.slice(0, 50);\n}\n\nexport interface MigrationResult {\n  success: boolean;\n  migratedCount: number;\n  orphanedCount: number;\n  skippedCount: number;\n  errors: Array<{\n    tileId: number;\n    error: string;\n  }>;\n}\n\nexport interface AuditResult {\n  totalTiles: number;\n  tilesWithGroupId: number;\n  tilesMissingGroupId: number;\n  inconsistentMappings: Array<{\n    group: string;\n    groupIds: string[];\n    count: number;\n  }>;\n  orphanedTiles: Array<{\n    id: number;\n    group: string;\n    locale: string;\n    gameMode: string;\n  }>;\n}\n\n/**\n * Audits the current state of group_id usage in tiles\n */\nexport async function auditGroupIdUsage(): Promise<AuditResult> {\n  try {\n    // Get all tiles\n    const allTiles = await db.customTiles.toArray();\n    const totalTiles = allTiles.length;\n\n    // Count tiles with/without group_id\n    const tilesWithGroupId = allTiles.filter(\n      (tile) => tile.group_id && tile.group_id.trim()\n    ).length;\n    const tilesMissingGroupId = totalTiles - tilesWithGroupId;\n\n    // Find inconsistent mappings (tiles with invalid group_ids)\n    // Since migration is complete, we now check for group_id consistency\n    const inconsistentMappings: Array<{\n      group: string;\n      groupIds: string[];\n      count: number;\n    }> = []; // Empty since all tiles should now have valid group_ids\n\n    // Find orphaned tiles (tiles without matching groups)\n    const allGroups = await db.customGroups.toArray();\n    const validGroupIds = new Set(allGroups.map((group) => group.id));\n\n    const orphanedTiles = allTiles\n      .filter((tile) => tile.group_id && tile.group_id.trim() && !validGroupIds.has(tile.group_id))\n      .map((tile) => ({\n        id: tile.id!,\n        group: tile.group_id || 'unknown', // Use group_id since group name no longer exists on tiles\n        locale: 'unknown', // Locale is now on groups, not tiles\n        gameMode: 'unknown', // GameMode is now on groups, not tiles\n      }));\n\n    const result: AuditResult = {\n      totalTiles,\n      tilesWithGroupId,\n      tilesMissingGroupId,\n      inconsistentMappings,\n      orphanedTiles,\n    };\n    return result;\n  } catch (error) {\n    console.error('Error during group ID audit:', error);\n    throw error;\n  }\n}\n\n/**\n * Resolves a group_id for a tile based on group name, locale, and gameMode\n * CRITICAL: For default groups, generates deterministic IDs to ensure sync consistency\n */\nexport async function resolveGroupId(\n  groupName: string,\n  locale: string = 'en',\n  gameMode: string = 'online',\n  isDefault: boolean = false\n): Promise<string | null> {\n  try {\n    // For default groups, first try to find existing group with deterministic ID\n    if (isDefault) {\n      const deterministicId = createDeterministicGroupId(groupName, locale, gameMode);\n\n      // Check if a group with this deterministic ID already exists\n      const existingById = await db.customGroups.where('id').equals(deterministicId).first();\n      if (existingById) {\n        return deterministicId;\n      }\n\n      // Check if a default group with this name exists (might need ID migration)\n      await getCustomGroups({\n        name: groupName,\n        locale,\n        gameMode,\n        isDefault: true,\n      });\n\n      // If no default group exists, return the deterministic ID that should be created\n      return deterministicId;\n    }\n\n    // For custom (user-created) groups, use existing logic\n    // First try exact match\n    const exactMatches = await getCustomGroups({\n      name: groupName,\n      locale,\n      gameMode,\n    });\n\n    if (exactMatches.length > 0) {\n      return exactMatches[0].id;\n    }\n\n    // Try without gameMode specificity (fallback to any gameMode)\n    const localeMatches = await getCustomGroups({\n      name: groupName,\n      locale,\n    });\n\n    if (localeMatches.length > 0) {\n      return localeMatches[0].id;\n    }\n\n    // Try without locale specificity (fallback to any locale)\n    const nameMatches = await getCustomGroups({\n      name: groupName,\n    });\n\n    if (nameMatches.length > 0) {\n      // Prefer groups with matching locale or gameMode if available\n      const bestMatch =\n        nameMatches.find((group) => group.locale === locale || group.gameMode === gameMode) ||\n        nameMatches[0];\n\n      return bestMatch.id;\n    }\n\n    return null;\n  } catch (error) {\n    console.error(`Error resolving group ID for \"${groupName}\":`, error);\n    return null;\n  }\n}\n\n/**\n * Migrates default groups to use deterministic IDs for cross-device consistency\n */\nexport async function migrateDefaultGroupIds(): Promise<{\n  migratedCount: number;\n  errors: Array<{ groupId: string; error: string }>;\n}> {\n  const result = {\n    migratedCount: 0,\n    errors: [] as Array<{ groupId: string; error: string }>,\n  };\n\n  try {\n    // Get all default groups\n    const defaultGroups = await getCustomGroups({ isDefault: true });\n\n    for (const group of defaultGroups) {\n      try {\n        const expectedId = createDeterministicGroupId(\n          group.name,\n          group.locale || 'en',\n          group.gameMode || 'online'\n        );\n\n        if (group.id !== expectedId) {\n          // Check if the target ID already exists\n          const existingWithTargetId = await db.customGroups.where('id').equals(expectedId).first();\n          if (existingWithTargetId) {\n            continue;\n          }\n\n          // Update all tiles that reference the old group ID\n          const tilesToUpdate = await db.customTiles.where('group_id').equals(group.id).toArray();\n          for (const tile of tilesToUpdate) {\n            await updateCustomTile(tile.id!, { group_id: expectedId });\n          }\n\n          // Delete the old group and create with new ID\n          await db.customGroups.delete(group.id);\n          await db.customGroups.add({\n            ...group,\n            id: expectedId,\n            updatedAt: new Date(),\n          });\n\n          result.migratedCount++;\n        }\n      } catch (error) {\n        console.error(`Error migrating default group ${group.id}:`, error);\n        result.errors.push({\n          groupId: group.id,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n    return result;\n  } catch (error) {\n    console.error('Default group ID migration failed:', error);\n    result.errors.push({\n      groupId: 'unknown',\n      error: error instanceof Error ? error.message : String(error),\n    });\n    return result;\n  }\n}\n\n/**\n * Migrates all tiles to use group_id instead of string-based group matching\n */\nexport async function migrateGroupIds(\n  options: {\n    dryRun?: boolean;\n    batchSize?: number;\n  } = {}\n): Promise<MigrationResult> {\n  const { dryRun = false, batchSize = 100 } = options;\n\n  const result: MigrationResult = {\n    success: false,\n    migratedCount: 0,\n    orphanedCount: 0,\n    skippedCount: 0,\n    errors: [],\n  };\n\n  try {\n    // Get all tiles missing group_id\n    const tilesToMigrate = await db.customTiles\n      .filter((tile) => !tile.group_id || !tile.group_id.trim())\n      .toArray();\n\n    // Process in batches to avoid overwhelming the database\n    for (let i = 0; i < tilesToMigrate.length; i += batchSize) {\n      const batch = tilesToMigrate.slice(i, i + batchSize);\n\n      // Since migration is complete, tiles without group_id are likely corrupted\n      // Skip migration for tiles that don't have the old properties\n      batch.forEach((tile) => {\n        console.warn(\n          `Found tile ${tile.id} without group_id but migration has already completed. This may indicate data corruption.`\n        );\n        result.orphanedCount++;\n      });\n    }\n\n    // Validate migration results\n    if (!dryRun) {\n      const auditResults = await auditGroupIdUsage();\n      const remainingTiles = auditResults.tilesMissingGroupId;\n\n      if (remainingTiles > 0) {\n        console.warn(`Migration completed but ${remainingTiles} tiles still missing group_id`);\n      }\n\n      result.skippedCount = remainingTiles;\n    }\n\n    result.success = result.errors.length === 0;\n\n    return result;\n  } catch (error) {\n    console.error('Group ID migration failed:', error);\n    result.errors.push({\n      tileId: -1,\n      error: error instanceof Error ? error.message : String(error),\n    });\n    return result;\n  }\n}\n\n/**\n * Validates that all tiles have valid group_id references\n */\nexport async function validateGroupIdIntegrity(): Promise<{\n  isValid: boolean;\n  issues: Array<{\n    type: 'missing_group_id' | 'invalid_group_id' | 'orphaned_group';\n    tileId?: number;\n    groupId?: string;\n    message: string;\n  }>;\n}> {\n  const issues: Array<{\n    type: 'missing_group_id' | 'invalid_group_id' | 'orphaned_group';\n    tileId?: number;\n    groupId?: string;\n    message: string;\n  }> = [];\n\n  try {\n    // Get all tiles and groups\n    const allTiles = await db.customTiles.toArray();\n    const allGroups = await db.customGroups.toArray();\n    const validGroupIds = new Set(allGroups.map((group) => group.id));\n\n    // Check each tile\n    for (const tile of allTiles) {\n      // Check for missing group_id\n      if (!tile.group_id || !tile.group_id.trim()) {\n        issues.push({\n          type: 'missing_group_id',\n          tileId: tile.id,\n          message: `Tile ${tile.id} missing group_id`,\n        });\n        continue;\n      }\n\n      // Check for invalid group_id reference\n      if (!validGroupIds.has(tile.group_id)) {\n        issues.push({\n          type: 'invalid_group_id',\n          tileId: tile.id,\n          groupId: tile.group_id,\n          message: `Tile ${tile.id} has invalid group_id: ${tile.group_id}`,\n        });\n      }\n    }\n\n    // Check for orphaned groups (groups with no tiles)\n    const tilesGroupIds = new Set(\n      allTiles.filter((tile) => tile.group_id && tile.group_id.trim()).map((tile) => tile.group_id!)\n    );\n\n    for (const group of allGroups) {\n      if (!group.isDefault && !tilesGroupIds.has(group.id)) {\n        issues.push({\n          type: 'orphaned_group',\n          groupId: group.id,\n          message: `Group ${group.id} (${group.name}) has no associated tiles`,\n        });\n      }\n    }\n\n    const isValid = issues.length === 0;\n\n    return { isValid, issues };\n  } catch (error) {\n    console.error('Error during group ID integrity validation:', error);\n    return {\n      isValid: false,\n      issues: [\n        {\n          type: 'invalid_group_id',\n          message: `Validation error: ${error instanceof Error ? error.message : String(error)}`,\n        },\n      ],\n    };\n  }\n}\n\n/**\n * Utility function to run all migration steps in sequence\n */\nexport async function runFullGroupIdMigration(\n  options: {\n    dryRun?: boolean;\n    skipAudit?: boolean;\n  } = {}\n): Promise<{\n  auditResult?: AuditResult;\n  defaultGroupMigrationResult: Awaited<ReturnType<typeof migrateDefaultGroupIds>>;\n  migrationResult: MigrationResult;\n  validationResult: Awaited<ReturnType<typeof validateGroupIdIntegrity>>;\n}> {\n  const { dryRun = false, skipAudit = false } = options;\n\n  // Step 1: Audit current state (optional)\n  let auditResult: AuditResult | undefined;\n  if (!skipAudit) {\n    auditResult = await auditGroupIdUsage();\n  }\n\n  // Step 2: Migrate default groups to deterministic IDs first\n  const defaultGroupMigrationResult = await migrateDefaultGroupIds();\n\n  // Step 3: Run tile migration (includes both default and custom tiles)\n  const migrationResult = await migrateGroupIds({ dryRun });\n\n  // Step 4: Validate results\n  const validationResult = await validateGroupIdIntegrity();\n\n  return {\n    auditResult,\n    defaultGroupMigrationResult,\n    migrationResult,\n    validationResult,\n  };\n}\n","/**\n * Import operations module for handling action file imports and data conversion\n */\n\nimport { addCustomGroup, getCustomGroupByName, removeDuplicateGroups } from '@/stores/customGroups';\nimport { importCustomTiles, getTiles } from '@/stores/customTiles';\nimport { CustomGroupBase } from '@/types/customGroups';\nimport { CustomTileBase } from '@/types/customTiles';\nimport { ImportResult } from './types';\nimport { logError, withErrorHandling, isDuplicateError } from './errorHandling';\nimport { getActionGroupNames } from './fileDiscovery';\nimport { createDeterministicGroupId } from './groupIdMigration';\nimport { GAME_MODES, SUPPORTED_LANGUAGES } from './constants';\n\n/**\n * Import a single action file and convert it to a custom group with custom tiles\n */\nexport const importActionFile = async (\n  groupName: string,\n  locale: string,\n  gameMode: string\n): Promise<{ customGroup: CustomGroupBase; customTiles: CustomTileBase[] } | null> => {\n  return withErrorHandling(async () => {\n    // Import the action file\n    const actionFile = await import(`@/locales/${locale}/${gameMode}/${groupName}.json`);\n\n    // Extract data from the JSON file\n    const label = actionFile.label || groupName;\n    const type = actionFile.type || 'action';\n    const actions = actionFile.actions || {};\n\n    // Convert actions object to intensities array\n    // Skip the first entry as it's always the \"None\" equivalent across all languages\n    const intensities = Object.keys(actions)\n      .slice(1) // Skip first entry (None/Ninguna/Aucun/etc.)\n      .map((intensityName, index) => ({\n        id: `${groupName}-${index + 1}`,\n        label: intensityName,\n        value: index + 1,\n        isDefault: true,\n      }));\n\n    // Create deterministic ID for default groups to ensure consistency across devices\n    const deterministicId = createDeterministicGroupId(groupName, locale, gameMode);\n\n    // Create the custom group with deterministic ID\n    const customGroup: CustomGroupBase & { id?: string } = {\n      id: deterministicId, // Set deterministic ID for sync consistency\n      name: groupName,\n      label,\n      intensities,\n      type,\n      isDefault: true,\n      locale,\n      gameMode,\n    };\n\n    // Create custom tiles from the actions\n    const customTiles: CustomTileBase[] = [];\n\n    for (const [intensityName, actionList] of Object.entries(actions)) {\n      if (intensityName === Object.keys(actions)[0] || !Array.isArray(actionList)) continue; // Skip first entry (None equivalent)\n\n      // Find the intensity value for this intensity name\n      const intensity = intensities.find((i) => i.label === intensityName);\n      if (!intensity) continue;\n\n      // Create a tile for each action in this intensity\n      for (const action of actionList) {\n        if (typeof action === 'string' && action.trim()) {\n          customTiles.push({\n            group_id: deterministicId, // Assign the deterministic group ID\n            intensity: intensity.value,\n            action: action.trim(),\n            tags: ['default'], // Mark as default tiles from JSON files\n            isEnabled: 1,\n            isCustom: 0, // These are default tiles, not custom\n          });\n        }\n      }\n    }\n\n    return { customGroup, customTiles };\n  }, `importActionFile:${groupName}:${locale}/${gameMode}`);\n};\n\n/**\n * Add a custom group with error handling for duplicates\n */\nconst addCustomGroupSafely = async (customGroup: CustomGroupBase): Promise<boolean> => {\n  try {\n    await addCustomGroup(customGroup);\n    return true;\n  } catch (error) {\n    if (isDuplicateError(error)) {\n      // Group was already added by concurrent process, this is ok\n      return false;\n    }\n    throw error; // Re-throw other errors\n  }\n};\n\n/**\n * Validates that all tiles have proper group_id assignment\n */\nconst validateTilesHaveGroupId = (tiles: CustomTileBase[]): void => {\n  for (const tile of tiles) {\n    if (!tile.group_id || !tile.group_id.trim()) {\n      throw new Error(`Tile missing group_id during import: ${tile.action}`);\n    }\n  }\n};\n\n/**\n * Filter out existing tiles to prevent duplicates using group_id-based matching\n */\nconst getNewTiles = async (\n  customTiles: CustomTileBase[],\n  locale: string,\n  gameMode: string,\n  groupName: string\n): Promise<CustomTileBase[]> => {\n  try {\n    // Validate all tiles have proper group_id\n    validateTilesHaveGroupId(customTiles);\n\n    const existingTiles = await getTiles({ locale, gameMode, group: groupName });\n\n    if (!existingTiles || !Array.isArray(existingTiles)) {\n      return customTiles; // If no existing tiles, all tiles are new\n    }\n\n    return customTiles.filter((tile) => {\n      return !existingTiles.some(\n        (existing) =>\n          existing.group_id === tile.group_id &&\n          existing.intensity === tile.intensity &&\n          existing.action === tile.action\n      );\n    });\n  } catch (error) {\n    logError('warn', `getNewTiles:${groupName}:${locale}/${gameMode}`, error);\n    return customTiles; // On error, import all tiles\n  }\n};\n\n/**\n * Import custom tiles with duplicate handling\n */\nconst importCustomTilesSafely = async (tiles: CustomTileBase[]): Promise<number> => {\n  if (tiles.length === 0) return 0;\n\n  try {\n    await importCustomTiles(tiles);\n    return tiles.length;\n  } catch (error) {\n    logError('warn', 'importCustomTilesSafely', error);\n    // Continue processing, don't fail the entire migration\n    return 0;\n  }\n};\n\n/**\n * Import all action groups for a specific locale and game mode\n * Uses Dexie transactions to prevent cursor invalidation during concurrent operations\n */\nexport const importGroupsForLocaleAndGameMode = async (\n  locale: string,\n  gameMode: string\n): Promise<ImportResult> => {\n  const groupNames = await getActionGroupNames(locale, gameMode);\n  let groupsImported = 0;\n  let tilesImported = 0;\n\n  // Import Dexie database for transaction usage\n  const db = await import('@/stores/store').then((module) => module.default);\n\n  // Use transaction to prevent cursor invalidation\n  return await db.transaction('rw', [db.customGroups, db.customTiles], async () => {\n    for (const groupName of groupNames) {\n      // Check if group already exists to prevent duplicates\n      const existingGroup = await getCustomGroupByName(groupName, locale, gameMode);\n      if (existingGroup) {\n        continue; // Group already exists, skip\n      }\n\n      const result = await importActionFile(groupName, locale, gameMode);\n      if (!result) continue;\n\n      const { customGroup, customTiles } = result;\n\n      try {\n        // Add the custom group with error handling for duplicates\n        const groupAdded = await addCustomGroupSafely(customGroup);\n        if (groupAdded) {\n          groupsImported++;\n        }\n\n        // Add the custom tiles if there are any\n        if (customTiles.length > 0) {\n          const newTiles = await getNewTiles(customTiles, locale, gameMode, groupName);\n          const tilesAdded = await importCustomTilesSafely(newTiles);\n          tilesImported += tilesAdded;\n        }\n      } catch (error) {\n        logError(\n          'error',\n          `importGroupsForLocaleAndGameMode:${groupName}:${locale}/${gameMode}`,\n          error\n        );\n      }\n    }\n\n    return { groupsImported, tilesImported };\n  });\n};\n\n/**\n * Clean up duplicate groups across all locales and game modes\n */\nexport const cleanupDuplicateGroups = async (): Promise<number> => {\n  const result = await withErrorHandling(\n    async () => {\n      const locales = SUPPORTED_LANGUAGES;\n      let totalDuplicatesRemoved = 0;\n\n      for (const locale of locales) {\n        const gameModes = GAME_MODES;\n        for (const gameMode of gameModes) {\n          const duplicatesRemoved = await removeDuplicateGroups(locale, gameMode);\n          totalDuplicatesRemoved += duplicatesRemoved;\n        }\n      }\n\n      return totalDuplicatesRemoved;\n    },\n    'cleanupDuplicateGroups',\n    0\n  );\n\n  return result !== null ? result : 0;\n};\n","/**\n * Main migration service that orchestrates all migration modules\n *\n * This is the refactored migration service broken down into focused modules:\n * - types: Type definitions and interfaces\n * - constants: Configuration and constant values\n * - errorHandling: Centralized error handling patterns\n * - statusManager: localStorage-based migration tracking\n * - versionManager: Version checking and updates\n * - fileDiscovery: Dynamic file and locale discovery\n * - importOperations: File importing and data conversion\n * - validationUtils: Integrity checks and validation\n */\n\nimport {\n  MIGRATION_TIMEOUT,\n  BACKGROUND_MIGRATION_DELAY,\n  QUEUE_BACKGROUND_MIGRATION_DELAY,\n  IDLE_CALLBACK_TIMEOUT,\n  SUPPORTED_LANGUAGES,\n  GAME_MODES,\n} from './constants';\nimport {\n  isMigrationInProgress,\n  setMigrationInProgress,\n  isLanguageMigrationInProgress,\n  setLanguageMigrationInProgress,\n  isBackgroundMigrationInProgress,\n  setBackgroundMigrationInProgress,\n  markMigrationComplete,\n  markLanguageMigrated,\n  markBackgroundMigrationInProgress,\n  isMigrationCompleted,\n  isCurrentLanguageMigrationCompleted,\n  getMigrationStatus,\n  resetMigrationStatus,\n} from './statusManager';\nimport { checkAndHandleVersionChange } from './versionManager';\nimport { getCurrentLanguage } from './fileDiscovery';\nimport { importGroupsForLocaleAndGameMode, cleanupDuplicateGroups } from './importOperations';\nimport { withErrorHandling, logError, safeLocalStorage } from './errorHandling';\n\n// Re-export types for external consumption\nexport type {\n  MigrationStatus,\n  BackgroundMigrationStatus,\n  ImportResult,\n  VersionCheckResult,\n  MigrationStatusSnapshot,\n} from './types';\n\n// Re-export key functions that are used by external components\nexport {\n  isMigrationCompleted,\n  isCurrentLanguageMigrationCompleted,\n  getMigrationStatus,\n  resetMigrationStatus,\n} from './statusManager';\n\nexport { checkAndHandleVersionChange } from './versionManager';\nexport { verifyMigrationIntegrity, fixMigrationStatusCorruption } from './validationUtils';\n\n/**\n * Main migration function with dynamic discovery\n */\nexport const migrateActionGroups = async (): Promise<boolean> => {\n  const result = await withErrorHandling(\n    async () => {\n      // Get available locales\n      const locales = SUPPORTED_LANGUAGES;\n\n      for (const locale of locales) {\n        // Use known game modes\n        const gameModes = GAME_MODES;\n\n        for (const gameMode of gameModes) {\n          try {\n            await importGroupsForLocaleAndGameMode(locale, gameMode);\n          } catch (error) {\n            logError('error', `migrateActionGroups:${locale}/${gameMode}`, error);\n          }\n        }\n      }\n\n      // Clean up any duplicates that might exist from previous migrations\n      await cleanupDuplicateGroups();\n\n      markMigrationComplete();\n      return true;\n    },\n    'migrateActionGroups',\n    false\n  );\n\n  return result !== null ? result : false;\n};\n\n/**\n * Clean up duplicate groups across all locales and game modes\n * Can be called independently of migration\n */\nexport const cleanupDuplicatesIfNeeded = async (): Promise<number> => {\n  const result = await withErrorHandling(\n    async () => {\n      const status = getMigrationStatus();\n      if (status.main?.completed || status.background?.completedLanguages?.length) {\n        return await cleanupDuplicateGroups();\n      }\n      return 0;\n    },\n    'cleanupDuplicatesIfNeeded',\n    0\n  );\n\n  return result !== null ? result : 0;\n};\n\n/**\n * Migration function for current language only (fast path)\n */\nexport const migrateCurrentLanguage = async (locale?: string): Promise<boolean> => {\n  const currentLocale = locale || (await getCurrentLanguage());\n\n  try {\n    // Check if this language is already migrated\n    if (isCurrentLanguageMigrationCompleted(currentLocale)) {\n      return true;\n    }\n\n    // Prevent concurrent migrations for the same language\n    if (isLanguageMigrationInProgress(currentLocale)) {\n      // Wait for the current migration to complete with timeout\n      await waitForMigrationCompletion(\n        () => isLanguageMigrationInProgress(currentLocale),\n        `${currentLocale} migration`\n      );\n      // Re-check if migration is now completed\n      return isCurrentLanguageMigrationCompleted(currentLocale);\n    }\n\n    setLanguageMigrationInProgress(currentLocale, true);\n\n    try {\n      const gameModes = GAME_MODES;\n\n      for (const gameMode of gameModes) {\n        try {\n          await importGroupsForLocaleAndGameMode(currentLocale, gameMode);\n        } catch (error) {\n          logError('error', `migrateCurrentLanguage:${currentLocale}/${gameMode}`, error);\n        }\n      }\n\n      // Clean up duplicates for current language\n      for (const gameMode of gameModes) {\n        try {\n          const { removeDuplicateGroups } = await import('@/stores/customGroups');\n          await removeDuplicateGroups(currentLocale, gameMode);\n        } catch (error) {\n          logError('warn', `cleanup:${currentLocale}/${gameMode}`, error);\n        }\n      }\n\n      // Mark this language as migrated\n      markLanguageMigrated(currentLocale);\n      return true;\n    } finally {\n      setLanguageMigrationInProgress(currentLocale, false);\n    }\n  } catch (error) {\n    logError('error', 'migrateCurrentLanguage', error);\n    setLanguageMigrationInProgress(currentLocale, false);\n    return false;\n  }\n};\n\n/**\n * Background migration for remaining languages\n */\nexport const migrateRemainingLanguages = async (excludeLocale?: string): Promise<void> => {\n  try {\n    // Prevent concurrent background migrations\n    if (isBackgroundMigrationInProgress()) {\n      return;\n    }\n\n    setBackgroundMigrationInProgress(true);\n    const currentLocale = excludeLocale || (await getCurrentLanguage());\n    markBackgroundMigrationInProgress(true);\n\n    const allLocales = SUPPORTED_LANGUAGES;\n    const remainingLocales = allLocales.filter((locale) => locale !== currentLocale);\n\n    for (const locale of remainingLocales) {\n      // Check if already migrated\n      if (isCurrentLanguageMigrationCompleted(locale)) {\n        continue;\n      }\n\n      try {\n        const gameModes = GAME_MODES;\n\n        for (const gameMode of gameModes) {\n          await importGroupsForLocaleAndGameMode(locale, gameMode);\n          // Add small delay to prevent blocking the main thread\n          await new Promise((resolve) => setTimeout(resolve, BACKGROUND_MIGRATION_DELAY));\n        }\n\n        // Clean up duplicates\n        for (const gameMode of gameModes) {\n          const { removeDuplicateGroups } = await import('@/stores/customGroups');\n          await removeDuplicateGroups(locale, gameMode);\n        }\n\n        markLanguageMigrated(locale);\n      } catch (error) {\n        logError('warn', `migrateRemainingLanguages:${locale}`, error);\n        // Continue with other languages even if one fails\n      }\n    }\n\n    markBackgroundMigrationInProgress(false);\n\n    // Check if all languages are now migrated\n    const { BACKGROUND_MIGRATION_KEY } = await import('./constants');\n    const bgStatus = safeLocalStorage.getJSON(BACKGROUND_MIGRATION_KEY);\n    const completedLanguages = new Set((bgStatus as any)?.completedLanguages || []);\n    const allLanguagesCompleted = SUPPORTED_LANGUAGES.every((lang) => completedLanguages.has(lang));\n\n    if (allLanguagesCompleted) {\n      markMigrationComplete(); // Mark full migration as complete\n    }\n  } catch (error) {\n    logError('error', 'migrateRemainingLanguages', error);\n    markBackgroundMigrationInProgress(false);\n    setBackgroundMigrationInProgress(false);\n  } finally {\n    setBackgroundMigrationInProgress(false);\n  }\n};\n\n/**\n * Queue background migration for remaining languages\n */\nexport const queueBackgroundMigration = (excludeLocale?: string): void => {\n  try {\n    if (typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function') {\n      window.requestIdleCallback(() => migrateRemainingLanguages(excludeLocale), {\n        timeout: IDLE_CALLBACK_TIMEOUT,\n      });\n    } else {\n      // Fallback for browsers without requestIdleCallback\n      setTimeout(() => migrateRemainingLanguages(excludeLocale), QUEUE_BACKGROUND_MIGRATION_DELAY);\n    }\n  } catch (error) {\n    logError('error', 'queueBackgroundMigration', error);\n  }\n};\n\n/**\n * Force migration for a specific language (useful when switching languages)\n */\nexport const ensureLanguageMigrated = async (locale: string): Promise<boolean> => {\n  try {\n    // Quick check first\n    const isCompleted = isCurrentLanguageMigrationCompleted(locale);\n    if (isCompleted) {\n      return true;\n    }\n\n    // If migration is in progress for this language, wait for it\n    if (isLanguageMigrationInProgress(locale)) {\n      await waitForMigrationCompletion(\n        () => isLanguageMigrationInProgress(locale),\n        `${locale} migration`\n      );\n      return isCurrentLanguageMigrationCompleted(locale);\n    }\n\n    return await migrateCurrentLanguage(locale);\n  } catch (error) {\n    logError('error', `ensureLanguageMigrated:${locale}`, error);\n    // Graceful fallback: allow the app to continue even if migration fails\n    logError('warn', 'Migration failed but app will continue', null, { locale });\n    return false;\n  }\n};\n\n/**\n * Run migration if needed (optimized for current language first)\n */\nexport const runMigrationIfNeeded = async (): Promise<boolean> => {\n  try {\n    // Check for version changes first\n    const { versionChanged } = checkAndHandleVersionChange();\n    if (versionChanged) {\n      // Version changed, force fresh migration\n    }\n\n    const currentLocale = await getCurrentLanguage();\n\n    // Check if the current language is already migrated\n    if (isCurrentLanguageMigrationCompleted(currentLocale)) {\n      return true;\n    }\n\n    // Prevent concurrent migrations\n    if (isMigrationInProgress()) {\n      await waitForMigrationCompletion(() => isMigrationInProgress(), 'main migration');\n      // Re-check if migration is now completed\n      return (\n        isMigrationCompleted() || isCurrentLanguageMigrationCompleted(await getCurrentLanguage())\n      );\n    }\n\n    setMigrationInProgress(true);\n\n    try {\n      // Fast path: migrate current language only\n      const success = await migrateCurrentLanguage(currentLocale);\n\n      if (success) {\n        // Queue background migration for other languages\n        queueBackgroundMigration(currentLocale);\n      }\n\n      return success;\n    } finally {\n      setMigrationInProgress(false);\n    }\n  } catch (error) {\n    logError('error', 'runMigrationIfNeeded', error);\n    setMigrationInProgress(false);\n    // Graceful fallback: allow app to continue even if migration fails\n    logError('warn', 'Migration failed but app will continue with existing data', null);\n    return false;\n  }\n};\n\n/**\n * Developer utility: Force a fresh migration by clearing all data\n */\nexport const forceFreshMigration = async (): Promise<void> => {\n  try {\n    // Clear all localStorage\n    resetMigrationStatus();\n\n    // Optionally clear Dexie database too for a completely fresh start\n    const db = await import('@/stores/store');\n    await db.default.customGroups.clear();\n    await db.default.customTiles.clear();\n  } catch (error) {\n    logError('error', 'forceFreshMigration', error);\n  }\n};\n\n/**\n * Wait for a migration to complete with timeout\n */\nconst waitForMigrationCompletion = async (\n  checkInProgress: () => boolean,\n  operationName: string\n): Promise<void> => {\n  const startTime = Date.now();\n\n  while (checkInProgress()) {\n    if (Date.now() - startTime > MIGRATION_TIMEOUT) {\n      logError(\n        'warn',\n        `Migration timeout: ${operationName} took longer than ${MIGRATION_TIMEOUT}ms`,\n        null\n      );\n      break;\n    }\n    await new Promise((resolve) => setTimeout(resolve, 50));\n  }\n};\n"],"file":"js/chunk-DXOuuy2v.js"}