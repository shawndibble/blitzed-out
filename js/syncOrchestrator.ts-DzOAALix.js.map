{"version":3,"file":"syncOrchestrator.ts-DzOAALix.js","sources":["../../src/services/sync/base.ts","../../src/services/sync/customGroupsSync.ts","../../src/services/sync/tileMatcher.ts","../../src/services/sync/customTilesSync.ts","../../src/services/sync/disabledDefaultsSync.ts","../../src/services/sync/gameBoardsSync.ts","../../src/services/sync/settingsSync.ts","../../src/services/sync/syncOrchestrator.ts"],"sourcesContent":["/**\n * Base utilities for sync operations\n */\nimport { getAuth } from 'firebase/auth';\nimport { doc, getDoc } from 'firebase/firestore';\nimport { db } from '@/services/firebase';\nimport type { SyncResult } from '@/types/sync';\n\nexport const SYNC_DELAY_MS = 50;\n\nexport class SyncBase {\n  /**\n   * Get authenticated user or throw error\n   */\n  static getAuthenticatedUser() {\n    const auth = getAuth();\n    const user = auth.currentUser;\n\n    if (!user) {\n      throw new Error('No user logged in');\n    }\n\n    return user;\n  }\n\n  /**\n   * Get user document from Firebase\n   */\n  static async getUserDocument(userId: string) {\n    const userDocRef = doc(db, 'user-data', userId);\n    return await getDoc(userDocRef);\n  }\n\n  /**\n   * Add sync delay between operations\n   */\n  static async addSyncDelay() {\n    await new Promise((resolve) => setTimeout(resolve, SYNC_DELAY_MS));\n  }\n\n  /**\n   * Safely remove ID field from object to avoid constraint errors\n   */\n  static removeId<T extends { id?: any }>(obj: T): Omit<T, 'id'> {\n    const { id, ...objWithoutId } = obj;\n    void id; // Explicitly ignore the id\n    return objWithoutId;\n  }\n\n  /**\n   * Handle sync operation errors consistently\n   */\n  static handleSyncError(operation: string, error: unknown): SyncResult {\n    console.error(`Error in ${operation}:`, error);\n    return {\n      success: false,\n      errors: [error instanceof Error ? error.message : String(error)],\n    };\n  }\n\n  /**\n   * Create success result\n   */\n  static createSuccessResult(itemsProcessed = 0): SyncResult {\n    return {\n      success: true,\n      itemsProcessed,\n    };\n  }\n}\n","import type { SyncOptions, SyncResult } from '@/types/sync';\nimport { clearUserCustomGroups, syncCustomGroupsToFirebase } from '../syncService';\n/**\n * Custom groups synchronization logic\n */\nimport { getCustomGroups, importCustomGroups } from '@/stores/customGroups';\n\nimport type { CustomGroupPull } from '@/types/customGroups';\nimport { SyncBase } from './base';\n\nexport class CustomGroupsSync extends SyncBase {\n  /**\n   * Sync custom groups from Firebase with smart conflict resolution\n   */\n  static async syncFromFirebase(\n    firebaseGroups: CustomGroupPull[],\n    options: SyncOptions\n  ): Promise<SyncResult> {\n    try {\n      const localGroups = await getCustomGroups({ isDefault: false });\n\n      // Smart conflict resolution\n      if (firebaseGroups.length === 0 && localGroups.length > 0 && !options.forceSync) {\n        await syncCustomGroupsToFirebase();\n        return this.createSuccessResult(localGroups.length);\n      }\n\n      if (firebaseGroups.length > 0 && localGroups.length > 0 && !options.forceSync) {\n        return await this.mergeConflicts(firebaseGroups, localGroups);\n      }\n\n      if (firebaseGroups.length > 0 && (localGroups.length === 0 || options.forceSync)) {\n        return await this.replaceLocal(firebaseGroups);\n      }\n\n      return this.createSuccessResult(0);\n    } catch (error) {\n      return this.handleSyncError('custom groups sync', error);\n    }\n  }\n\n  /**\n   * Merge Firebase groups with local groups (no conflicts)\n   */\n  private static async mergeConflicts(\n    firebaseGroups: CustomGroupPull[],\n    localGroups: any[]\n  ): Promise<SyncResult> {\n    let addedCount = 0;\n\n    for (const group of firebaseGroups) {\n      try {\n        const existingGroups = await getCustomGroups({\n          locale: group.locale,\n          gameMode: group.gameMode,\n          name: group.name,\n        });\n\n        if (existingGroups.length === 0) {\n          const groupWithoutId = this.removeId(group);\n          await importCustomGroups([groupWithoutId]);\n          addedCount++;\n        }\n      } catch (error) {\n        console.error('Error merging custom group:', group, error);\n      }\n    }\n\n    // Sync the merged result back to Firebase\n    await syncCustomGroupsToFirebase();\n\n    return this.createSuccessResult(addedCount + localGroups.length);\n  }\n\n  /**\n   * Replace local groups with Firebase groups\n   */\n  private static async replaceLocal(firebaseGroups: CustomGroupPull[]): Promise<SyncResult> {\n    await clearUserCustomGroups();\n    await this.addSyncDelay();\n\n    try {\n      const groupsWithoutIds = firebaseGroups.map((group) => this.removeId(group));\n      await importCustomGroups(groupsWithoutIds);\n\n      return this.createSuccessResult(firebaseGroups.length);\n    } catch (error) {\n      console.error('Error importing custom groups:', error);\n      return this.handleSyncError('groups import', error);\n    }\n  }\n}\n","/**\n * Tile Matching Service with Group ID Support\n *\n * Provides consistent tile matching logic using group_id-based keys instead of string matching\n * for improved sync reliability and performance.\n */\n\nimport { getTiles } from '@/stores/customTiles';\nimport type { CustomTilePull, CustomTileBase } from '@/types/customTiles';\n\nexport interface TileMatchKey {\n  group_id: string;\n  intensity: number;\n  action: string;\n  gameMode: string;\n  locale: string;\n}\n\nexport interface TileMatchResult {\n  existingTile: CustomTilePull | null;\n  isExactMatch: boolean;\n  matchKey: string;\n}\n\nexport class TileMatcher {\n  /**\n   * Creates a consistent matching key for tiles using group_id\n   */\n  static createKey(tile: CustomTileBase | CustomTilePull): string {\n    if (!tile.group_id) {\n      throw new Error(\n        `Tile missing group_id for matching: ${JSON.stringify({\n          id: (tile as CustomTilePull).id,\n          group_id: tile.group_id,\n          action: tile.action,\n        })}`\n      );\n    }\n\n    return `${tile.group_id}|${tile.intensity}|${tile.action}`;\n  }\n\n  /**\n   * Finds an existing tile that matches the provided tile using group_id-based matching\n   */\n  static async findExistingTile(tile: CustomTileBase): Promise<TileMatchResult> {\n    if (!tile.group_id) {\n      throw new Error(\n        `Cannot match tile without group_id: ${JSON.stringify({\n          group_id: tile.group_id,\n          action: tile.action,\n        })}`\n      );\n    }\n\n    try {\n      // Use group_id-based matching (preferred)\n      const existingTiles = await getTiles({\n        group_id: tile.group_id,\n        intensity: tile.intensity,\n        action: tile.action,\n      });\n\n      if (existingTiles.length > 0) {\n        return {\n          existingTile: existingTiles[0],\n          isExactMatch: true,\n          matchKey: this.createKey(tile),\n        };\n      }\n\n      return {\n        existingTile: null,\n        isExactMatch: false,\n        matchKey: this.createKey(tile),\n      };\n    } catch (error) {\n      console.error('Error finding existing tile:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Batch matching for multiple tiles to improve performance\n   */\n  static async batchFindExistingTiles(\n    tiles: CustomTileBase[]\n  ): Promise<Map<string, TileMatchResult>> {\n    const results = new Map<string, TileMatchResult>();\n\n    // Group tiles by group_id to optimize database queries\n    const tilesByGroupId = new Map<string, CustomTileBase[]>();\n\n    for (const tile of tiles) {\n      if (!tile.group_id) {\n        throw new Error(\n          `Tile missing group_id: ${JSON.stringify({\n            group_id: tile.group_id,\n            action: tile.action,\n          })}`\n        );\n      }\n\n      const groupTiles = tilesByGroupId.get(tile.group_id) || [];\n      groupTiles.push(tile);\n      tilesByGroupId.set(tile.group_id, groupTiles);\n    }\n\n    // Process each group\n    for (const [groupId, groupTiles] of tilesByGroupId) {\n      try {\n        // Get all existing tiles for this group\n        const existingTiles = await getTiles({ group_id: groupId });\n\n        // Create lookup map for existing tiles\n        const existingTileMap = new Map<string, CustomTilePull>();\n        for (const existing of existingTiles) {\n          const key = this.createKey(existing);\n          existingTileMap.set(key, existing);\n        }\n\n        // Match each tile in the group\n        for (const tile of groupTiles) {\n          const tileKey = this.createKey(tile);\n          const existingTile = existingTileMap.get(tileKey) || null;\n\n          results.set(tileKey, {\n            existingTile,\n            isExactMatch: existingTile !== null,\n            matchKey: tileKey,\n          });\n        }\n      } catch (error) {\n        console.error(`Error batch matching tiles for group ${groupId}:`, error);\n\n        // Fall back to individual matching for this group\n        for (const tile of groupTiles) {\n          try {\n            const result = await this.findExistingTile(tile);\n            results.set(this.createKey(tile), result);\n          } catch (individualError) {\n            console.error(`Error matching individual tile:`, individualError);\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Validates that a tile has all required fields for matching\n   */\n  static validateTileForMatching(tile: CustomTileBase): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    if (!tile.group_id || !tile.group_id.trim()) {\n      errors.push('Missing group_id');\n    }\n\n    if (tile.intensity === undefined || tile.intensity === null) {\n      errors.push('Missing intensity');\n    }\n\n    if (!tile.action || !tile.action.trim()) {\n      errors.push('Missing action');\n    }\n\n    // Note: locale and gameMode have defaults, so they're not strictly required\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Compares two tiles to determine if they represent the same tile\n   */\n  static tilesEqual(tile1: CustomTileBase, tile2: CustomTileBase): boolean {\n    // Both tiles must have group_id\n    if (!tile1.group_id || !tile2.group_id) {\n      throw new Error('Cannot compare tiles without group_id');\n    }\n\n    return (\n      tile1.group_id === tile2.group_id &&\n      tile1.intensity === tile2.intensity &&\n      tile1.action === tile2.action\n    );\n  }\n\n  /**\n   * Generates matching statistics for debugging and monitoring\n   */\n  static async generateMatchingStats(tiles: CustomTileBase[]): Promise<{\n    totalTiles: number;\n    tilesWithGroupId: number;\n    tilesMissingGroupId: number;\n    duplicateKeys: string[];\n    matchingErrors: Array<{ tile: CustomTileBase; error: string }>;\n  }> {\n    const stats = {\n      totalTiles: tiles.length,\n      tilesWithGroupId: 0,\n      tilesMissingGroupId: 0,\n      duplicateKeys: [] as string[],\n      matchingErrors: [] as Array<{ tile: CustomTileBase; error: string }>,\n    };\n\n    const keyCount = new Map<string, number>();\n\n    for (const tile of tiles) {\n      // Count tiles with/without group_id\n      if (tile.group_id && tile.group_id.trim()) {\n        stats.tilesWithGroupId++;\n      } else {\n        stats.tilesMissingGroupId++;\n      }\n\n      // Validate tile for matching\n      const validation = this.validateTileForMatching(tile);\n      if (!validation.valid) {\n        stats.matchingErrors.push({\n          tile,\n          error: validation.errors.join(', '),\n        });\n        continue;\n      }\n\n      // Check for duplicate keys\n      try {\n        const key = this.createKey(tile);\n        const count = keyCount.get(key) || 0;\n        keyCount.set(key, count + 1);\n\n        if (count > 0) {\n          stats.duplicateKeys.push(key);\n        }\n      } catch (error) {\n        stats.matchingErrors.push({\n          tile,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    return stats;\n  }\n}\n\nexport default TileMatcher;\n","import type { SyncOptions, SyncResult } from '@/types/sync';\n/**\n * Custom tiles synchronization logic\n * Updated to use group_id-based matching for improved sync reliability\n */\nimport { addCustomTile, getTiles, updateCustomTile } from '@/stores/customTiles';\nimport { deleteAllCustomTiles, syncCustomTilesToFirebase } from '../syncService';\n\nimport type { CustomTilePull } from '@/types/customTiles';\nimport { SyncBase } from './base';\nimport { TileMatcher } from './tileMatcher';\n\nexport class CustomTilesSync extends SyncBase {\n  /**\n   * Sync custom tiles from Firebase with smart conflict resolution\n   */\n  static async syncFromFirebase(\n    firebaseTiles: CustomTilePull[],\n    options: SyncOptions\n  ): Promise<SyncResult> {\n    try {\n      const localTiles = await getTiles({ isCustom: 1 });\n\n      // Smart conflict resolution\n      if (firebaseTiles.length === 0 && localTiles.length > 0 && !options.forceSync) {\n        await syncCustomTilesToFirebase();\n        return this.createSuccessResult(localTiles.length);\n      }\n\n      if (firebaseTiles.length > 0 && localTiles.length > 0 && !options.forceSync) {\n        return await this.mergeConflicts(firebaseTiles, localTiles);\n      }\n\n      if (firebaseTiles.length > 0 && (localTiles.length === 0 || options.forceSync)) {\n        return await this.replaceLocal(firebaseTiles);\n      }\n\n      return this.createSuccessResult(0);\n    } catch (error) {\n      return this.handleSyncError('custom tiles sync', error);\n    }\n  }\n\n  /**\n   * Merge Firebase tiles with local tiles using group_id-based matching\n   */\n  private static async mergeConflicts(\n    firebaseTiles: CustomTilePull[],\n    localTiles: any[]\n  ): Promise<SyncResult> {\n    let addedCount = 0;\n    let updatedCount = 0;\n\n    for (const tile of firebaseTiles) {\n      try {\n        // Only process actual custom tiles (isCustom: 1)\n        if (tile.isCustom !== 1) {\n          console.warn(`Skipping non-custom tile in custom tiles sync: ${tile.action}`);\n          continue;\n        }\n\n        // Validate tile has group_id (required for new sync system)\n        if (!tile.group_id || !tile.group_id.trim()) {\n          console.error(\n            `Tile missing group_id during sync: ${tile.action} (group_id: ${tile.group_id})`\n          );\n          throw new Error(`All tiles must have group_id for sync. Tile: ${tile.action}`);\n        }\n\n        const matchResult = await TileMatcher.findExistingTile(tile);\n\n        if (matchResult.existingTile) {\n          // Update existing tile if needed (only isEnabled can be synced)\n          if (matchResult.existingTile.isEnabled !== tile.isEnabled) {\n            await updateCustomTile(matchResult.existingTile.id!, {\n              isEnabled: tile.isEnabled,\n            });\n            updatedCount++;\n          }\n        } else {\n          // Add new tile\n          const tileWithoutId = this.removeId(tile);\n          await addCustomTile(tileWithoutId);\n          addedCount++;\n        }\n      } catch (error) {\n        console.error('Error merging custom tile:', tile, error);\n      }\n    }\n\n    // Sync the merged result back to Firebase\n    await syncCustomTilesToFirebase();\n\n    return this.createSuccessResult(addedCount + updatedCount + localTiles.length);\n  }\n\n  /**\n   * Replace local tiles with Firebase tiles using group_id-based matching\n   */\n  private static async replaceLocal(firebaseTiles: CustomTilePull[]): Promise<SyncResult> {\n    await deleteAllCustomTiles();\n    await this.addSyncDelay();\n\n    let importedCount = 0;\n\n    for (const tile of firebaseTiles) {\n      try {\n        // Only process actual custom tiles (isCustom: 1)\n        if (tile.isCustom !== 1) {\n          console.warn(`Skipping non-custom tile in custom tiles sync: ${tile.action}`);\n          continue;\n        }\n\n        // Validate tile has group_id (required for new sync system)\n        if (!tile.group_id || !tile.group_id.trim()) {\n          console.error(\n            `Tile missing group_id during import: ${tile.action} (group_id: ${tile.group_id})`\n          );\n          throw new Error(`All tiles must have group_id for sync. Tile: ${tile.action}`);\n        }\n\n        const matchResult = await TileMatcher.findExistingTile(tile);\n\n        if (!matchResult.existingTile) {\n          const tileWithoutId = this.removeId(tile);\n          await addCustomTile(tileWithoutId);\n          importedCount++;\n        }\n      } catch (error) {\n        console.error('Error importing custom tile:', tile, error);\n      }\n    }\n\n    return this.createSuccessResult(importedCount);\n  }\n}\n","/**\n * Disabled defaults synchronization logic\n */\nimport { SyncBase } from './base';\nimport { resetDisabledDefaults, applyDisabledDefaults } from '../syncService';\nimport type { SyncResult } from '@/types/sync';\n\nexport class DisabledDefaultsSync extends SyncBase {\n  /**\n   * Sync disabled defaults from Firebase\n   */\n  static async syncFromFirebase(disabledDefaults: any[]): Promise<SyncResult> {\n    try {\n      if (!disabledDefaults || disabledDefaults.length === 0) {\n        // Still reset any existing disabled defaults to clean state\n        await resetDisabledDefaults();\n        return this.createSuccessResult(0);\n      }\n\n      // Add validation to prevent applying excessive disabled defaults\n      const MAX_REASONABLE_DISABLED_DEFAULTS = 100;\n      if (disabledDefaults.length > MAX_REASONABLE_DISABLED_DEFAULTS) {\n        console.warn(\n          `⚠️ Firebase contains ${disabledDefaults.length} disabled defaults, which seems excessive.`\n        );\n        console.warn('Skipping disabled defaults sync to prevent data corruption.');\n\n        // Don't apply the disabled defaults but don't fail the sync either\n        return this.createSuccessResult(0);\n      }\n\n      await resetDisabledDefaults();\n\n      // Add sync delay\n      await this.addSyncDelay();\n\n      await applyDisabledDefaults(disabledDefaults);\n\n      return this.createSuccessResult(disabledDefaults.length);\n    } catch (error) {\n      return this.handleSyncError('disabled defaults sync', error);\n    }\n  }\n}\n","import type { DBGameBoard } from '@/types/gameBoard';\nimport { SyncBase } from './base';\nimport type { SyncResult } from '@/types/sync';\n/**\n * Game boards synchronization logic\n */\nimport { upsertBoard } from '@/stores/gameBoard';\n\nexport class GameBoardsSync extends SyncBase {\n  /**\n   * Sync game boards from Firebase\n   */\n  static async syncFromFirebase(gameBoards: DBGameBoard[]): Promise<SyncResult> {\n    if (!gameBoards || gameBoards.length === 0) {\n      return this.createSuccessResult(0);\n    }\n\n    try {\n      let importedCount = 0;\n      for (const board of gameBoards) {\n        try {\n          await upsertBoard({\n            title: board.title,\n            tiles: board.tiles || [],\n            tags: board.tags || [],\n            gameMode: board.gameMode || 'online',\n            isActive: board.isActive || 0,\n          });\n          importedCount++;\n        } catch (error) {\n          console.error('Error importing game board:', board, error);\n        }\n      }\n\n      return this.createSuccessResult(importedCount);\n    } catch (error) {\n      return this.handleSyncError('game boards sync', error);\n    }\n  }\n}\n","import { SyncBase } from './base';\nimport type { SyncResult } from '@/types/sync';\n/**\n * Settings synchronization logic\n */\nimport { useSettingsStore } from '@/stores/settingsStore';\n\nexport class SettingsSync extends SyncBase {\n  /**\n   * Sync settings from Firebase\n   */\n  static async syncFromFirebase(firebaseSettings: Record<string, any>): Promise<SyncResult> {\n    if (!firebaseSettings || Object.keys(firebaseSettings).length === 0) {\n      return this.createSuccessResult(0);\n    }\n\n    try {\n      const { updateSettings } = useSettingsStore.getState();\n\n      // Filter out any undefined values and localPlayers (which should stay local-only)\n      const cleanSettings = Object.fromEntries(\n        Object.entries(firebaseSettings).filter(\n          ([key, value]) => value !== undefined && key !== 'localPlayers'\n        )\n      );\n\n      if (Object.keys(cleanSettings).length > 0) {\n        updateSettings(cleanSettings);\n        return this.createSuccessResult(Object.keys(cleanSettings).length);\n      }\n\n      return this.createSuccessResult(0);\n    } catch (error) {\n      return this.handleSyncError('settings sync', error);\n    }\n  }\n}\n","import type { SyncOptions, SyncResult } from '@/types/sync';\nimport { cleanupDuplicateTiles, syncAllDataToFirebase } from '../syncService';\n\nimport { CustomGroupsSync } from './customGroupsSync';\n/**\n * Main sync orchestrator - coordinates all sync operations\n */\nimport { CustomTilesSync } from './customTilesSync';\nimport { DisabledDefaultsSync } from './disabledDefaultsSync';\nimport { GameBoardsSync } from './gameBoardsSync';\nimport { SettingsSync } from './settingsSync';\nimport { SyncBase } from './base';\n\nexport class SyncOrchestrator extends SyncBase {\n  /**\n   * Main sync function - refactored from the original syncDataFromFirebase\n   */\n  static async syncFromFirebase(options: SyncOptions = {}): Promise<boolean> {\n    try {\n      const user = this.getAuthenticatedUser();\n      const userDoc = await this.getUserDocument(user.uid);\n\n      if (!userDoc.exists()) {\n        return await syncAllDataToFirebase();\n      }\n\n      const userData = userDoc.data();\n\n      // Clean up any duplicate tiles first\n      await cleanupDuplicateTiles();\n\n      // Run all sync operations in parallel for better performance\n      const syncOperations = [\n        this.syncCustomTiles(userData, options),\n        this.syncCustomGroups(userData, options),\n        this.syncDisabledDefaults(userData),\n        this.syncGameBoards(userData),\n        this.syncSettings(userData),\n      ];\n\n      const results = await Promise.allSettled(syncOperations);\n\n      // Check if all operations succeeded\n      let totalSuccess = true;\n\n      results.forEach((result, index) => {\n        const operationNames = [\n          'Custom Tiles',\n          'Custom Groups',\n          'Disabled Defaults',\n          'Game Boards',\n          'Settings',\n        ];\n\n        if (result.status === 'fulfilled') {\n          const syncResult = result.value;\n          if (!syncResult.success) {\n            totalSuccess = false;\n            console.error(`❌ ${operationNames[index]} sync failed:`, syncResult.errors);\n          }\n        } else {\n          totalSuccess = false;\n          console.error(`❌ ${operationNames[index]} sync rejected:`, result.reason);\n        }\n      });\n\n      return totalSuccess;\n    } catch (error) {\n      console.error('Error in sync orchestrator:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Sync custom tiles with error handling\n   */\n  private static async syncCustomTiles(userData: any, options: SyncOptions): Promise<SyncResult> {\n    if (userData.customTiles !== undefined) {\n      const tiles = userData.customTiles || [];\n\n      // Check if any are actually disabled defaults (this shouldn't happen)\n      const invalidTiles = tiles.filter((tile: any) => tile.isCustom === 0);\n      if (invalidTiles.length > 0) {\n        console.warn(\n          `⚠️ Found ${invalidTiles.length} default tiles in customTiles field - data corruption detected`\n        );\n      }\n\n      return await CustomTilesSync.syncFromFirebase(tiles, options);\n    }\n    return this.createSuccessResult(0);\n  }\n\n  /**\n   * Sync custom groups with error handling\n   */\n  private static async syncCustomGroups(userData: any, options: SyncOptions): Promise<SyncResult> {\n    if (userData.customGroups !== undefined) {\n      return await CustomGroupsSync.syncFromFirebase(userData.customGroups || [], options);\n    }\n    return this.createSuccessResult(0);\n  }\n\n  /**\n   * Sync disabled defaults with error handling\n   */\n  private static async syncDisabledDefaults(userData: any): Promise<SyncResult> {\n    if (userData.disabledDefaults !== undefined) {\n      return await DisabledDefaultsSync.syncFromFirebase(userData.disabledDefaults || []);\n    }\n    return this.createSuccessResult(0);\n  }\n\n  /**\n   * Sync game boards with error handling\n   */\n  private static async syncGameBoards(userData: any): Promise<SyncResult> {\n    if (userData.gameBoards !== undefined) {\n      return await GameBoardsSync.syncFromFirebase(userData.gameBoards);\n    }\n    return this.createSuccessResult(0);\n  }\n\n  /**\n   * Sync settings with error handling\n   */\n  private static async syncSettings(userData: any): Promise<SyncResult> {\n    if (userData.settings !== undefined) {\n      return await SettingsSync.syncFromFirebase(userData.settings || {});\n    }\n    return this.createSuccessResult(0);\n  }\n}\n"],"names":["SYNC_DELAY_MS","SyncBase","user","getAuth","userId","userDocRef","doc","db","getDoc","resolve","obj","id","objWithoutId","operation","error","itemsProcessed","CustomGroupsSync","firebaseGroups","options","localGroups","getCustomGroups","syncCustomGroupsToFirebase","addedCount","group","groupWithoutId","importCustomGroups","clearUserCustomGroups","groupsWithoutIds","TileMatcher","tile","existingTiles","getTiles","tiles","results","tilesByGroupId","groupTiles","groupId","existingTileMap","existing","key","tileKey","existingTile","result","individualError","errors","tile1","tile2","stats","keyCount","validation","count","CustomTilesSync","firebaseTiles","localTiles","syncCustomTilesToFirebase","updatedCount","matchResult","updateCustomTile","tileWithoutId","addCustomTile","deleteAllCustomTiles","importedCount","DisabledDefaultsSync","disabledDefaults","resetDisabledDefaults","applyDisabledDefaults","GameBoardsSync","gameBoards","board","upsertBoard","SettingsSync","firebaseSettings","updateSettings","useSettingsStore","cleanSettings","value","SyncOrchestrator","userDoc","syncAllDataToFirebase","userData","cleanupDuplicateTiles","syncOperations","totalSuccess","index","operationNames","syncResult","invalidTiles"],"mappings":"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"}