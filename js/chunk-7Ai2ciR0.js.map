{"version":3,"file":"chunk-7Ai2ciR0.js","sources":["../../src/helpers/cssUrl.ts","../../src/components/DirectMediaHandler/index.tsx","../../src/components/ImageSlideshow/index.tsx","../../src/services/redditService.ts","../../src/hooks/useRedditFeed.ts","../../src/components/RedditSlideshow/index.tsx","../../src/components/RoomBackground/index.tsx","../../src/services/getBackgroundSource.ts","../../src/hooks/useTurnIndicator.ts"],"sourcesContent":["/**\n * Creates a properly formatted CSS url() string with safe escaping\n * @param url - The URL to format for CSS\n * @returns A properly formatted CSS url() string\n */\nexport function cssUrl(url: string): string {\n  // Convert to string and strip control characters by iterating over code points\n  let cleanedUrl = '';\n  for (const char of String(url)) {\n    const codePoint = char.codePointAt(0)!; // Non-null assertion safe here since char is from string iteration\n\n    // Filter out control characters:\n    // - C0 controls: U+0000 to U+001F\n    // - DEL: U+007F\n    // - C1 controls: U+0080 to U+009F\n    // - Line separator: U+2028\n    // - Paragraph separator: U+2029\n    if (\n      !(\n        (codePoint >= 0x00 && codePoint <= 0x1f) ||\n        codePoint === 0x7f ||\n        (codePoint >= 0x80 && codePoint <= 0x9f) ||\n        codePoint === 0x2028 ||\n        codePoint === 0x2029\n      )\n    ) {\n      cleanedUrl += char;\n    }\n  }\n\n  // Escape backslashes and double quotes\n  const escapedUrl = cleanedUrl.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n\n  return `url(\"${escapedUrl}\")`;\n}\n","import { useEffect, useState } from 'react';\n\nimport { cssUrl } from '@/helpers/cssUrl';\n\ninterface DirectMediaHandlerProps {\n  url: string | null;\n}\n\nconst inferMediaType = (u: string | null): 'video' | 'image' => {\n  if (!u) return 'video';\n  // Treat image formats as images (including GIFs and modern formats)\n  if (/\\.(jpe?g|png|webp|bmp|svg|gif|avif|tiff?|heic|heif|jfif)(\\?.*)?$/i.test(u)) return 'image';\n  // Default to video for video extensions or unknown URLs\n  return 'video';\n};\n\nfunction DirectMediaHandler({ url }: DirectMediaHandlerProps) {\n  const [mediaType, setMediaType] = useState<'video' | 'image'>(inferMediaType(url));\n  const [currentUrl, setCurrentUrl] = useState(url);\n\n  // Reset state when URL prop changes\n  useEffect(() => {\n    setCurrentUrl(url);\n    setMediaType(inferMediaType(url));\n  }, [url]);\n\n  if (!currentUrl) return null;\n\n  const handleVideoError = () => {\n    const failingUrl = currentUrl ?? url ?? '';\n    // Special handling for Imgur URLs\n    let isImgur = false;\n    try {\n      const parsed = new URL(failingUrl);\n      isImgur = parsed.host === 'imgur.com' || parsed.host === 'i.imgur.com';\n    } catch {\n      // If URL parsing fails, skip Imgur-specific logic for security\n      isImgur = false;\n    }\n\n    if (isImgur) {\n      const imgurId = failingUrl.match(/(?:i\\.)?imgur\\.com\\/([a-zA-Z0-9]+)(?:\\.[a-z]+)?/)?.[1];\n      if (imgurId) {\n        const imageUrl = `https://i.imgur.com/${imgurId}.jpg`;\n        setCurrentUrl(imageUrl);\n        setMediaType('image');\n        return;\n      }\n    }\n\n    // For other URLs, try changing extension from .mp4 to common image formats\n    const baseUrl = failingUrl.replace(/\\.(mp4|webm|ogg|mov)(\\?.*)?$/i, '');\n    const imageUrl = `${baseUrl}.jpg`;\n    setCurrentUrl(imageUrl);\n    setMediaType('image');\n  };\n\n  const handleImageError = () => {\n    const failingUrl = currentUrl ?? url ?? '';\n    let isImgur = false;\n    try {\n      const parsed = new URL(failingUrl);\n      isImgur = parsed.host === 'imgur.com' || parsed.host === 'i.imgur.com';\n    } catch {\n      // If URL parsing fails, skip Imgur-specific logic for security\n      isImgur = false;\n    }\n\n    if (isImgur) {\n      // Imgur-specific format trying\n      const imgurId = failingUrl.match(/(?:i\\.)?imgur\\.com\\/([a-zA-Z0-9]+)(?:\\.[a-z]+)?/)?.[1];\n      if (imgurId) {\n        const formats = ['jpg', 'png', 'gif', 'jpeg', 'webp'];\n        const currentFormat = currentUrl?.split('.').pop();\n        const currentIndex = formats.indexOf(currentFormat || '');\n        const nextIndex = currentIndex + 1;\n\n        if (nextIndex < formats.length) {\n          const nextFormat = formats[nextIndex];\n          const nextUrl = `https://i.imgur.com/${imgurId}.${nextFormat}`;\n          setCurrentUrl(nextUrl);\n        }\n      }\n    } else {\n      // For other URLs, try different image extensions\n      const formats = ['jpg', 'png', 'gif', 'jpeg', 'webp'];\n      const currentFormat = currentUrl?.split('.').pop();\n      const currentIndex = formats.indexOf(currentFormat || '');\n      const nextIndex = currentIndex + 1;\n\n      if (nextIndex < formats.length && currentUrl) {\n        const nextFormat = formats[nextIndex];\n        const baseUrl = currentUrl.replace(/\\.[^.]+(\\?.*)?$/, '');\n        const nextUrl = `${baseUrl}.${nextFormat}`;\n        setCurrentUrl(nextUrl);\n      }\n    }\n  };\n\n  if (mediaType === 'video') {\n    return (\n      <video\n        autoPlay={true}\n        loop={true}\n        muted={true}\n        playsInline={true}\n        src={currentUrl || undefined}\n        className=\"video-background\"\n        onError={handleVideoError}\n        // Cast-specific optimizations\n        preload=\"auto\"\n        crossOrigin=\"anonymous\"\n        controls={true}\n      />\n    );\n  }\n\n  // Render as background image - use hidden img for error handling\n  return (\n    <>\n      <div\n        className=\"image-background\"\n        style={{\n          backgroundImage: currentUrl ? cssUrl(currentUrl) : undefined,\n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n          backgroundRepeat: 'no-repeat',\n          width: '100%',\n          height: '100%',\n          position: 'absolute',\n          top: 0,\n          left: 0,\n        }}\n      />\n      <img\n        src={currentUrl || undefined}\n        onError={handleImageError}\n        style={{ display: 'none' }}\n        alt=\"\"\n      />\n    </>\n  );\n}\n\nexport default DirectMediaHandler;\n","import './styles.css';\n\nimport { useEffect, useRef, useState } from 'react';\n\nimport clsx from 'clsx';\nimport { useTranslation } from 'react-i18next';\n\ninterface ImageSlideshowProps {\n  images: string[];\n  className?: string;\n  zoomDuration?: number; // Duration in milliseconds\n  zoomScale?: number; // Scale factor (e.g., 1.4 = 140%)\n}\n\nexport default function ImageSlideshow({\n  images,\n  className,\n  zoomDuration = 3000,\n  zoomScale = 1.4,\n}: ImageSlideshowProps) {\n  const { t } = useTranslation();\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [imageKey, setImageKey] = useState(0);\n  const [preloadedImages, setPreloadedImages] = useState<Set<string>>(new Set());\n  const [imageLoadErrors, setImageLoadErrors] = useState<Set<string>>(new Set());\n  const [hasLoadedFirstImage, setHasLoadedFirstImage] = useState(false);\n\n  const intervalRef = useRef<number | null>(null);\n  const preloadRef = useRef<Map<string, HTMLImageElement>>(new Map());\n\n  // Reset loading state when images change\n  useEffect(() => {\n    setHasLoadedFirstImage(false);\n    setPreloadedImages(new Set());\n    setImageLoadErrors(new Set());\n    preloadRef.current.clear();\n    setCurrentIndex(0);\n    setImageKey(0);\n  }, [images]);\n\n  // Preload images for smooth transitions\n  useEffect(() => {\n    if (images.length === 0) return;\n\n    const preloadImage = (src: string): Promise<void> => {\n      return new Promise((resolve) => {\n        // Skip if already preloaded or failed\n        if (preloadRef.current.has(src) || imageLoadErrors.has(src)) {\n          resolve();\n          return;\n        }\n\n        const img = new Image();\n        img.onload = () => {\n          preloadRef.current.set(src, img);\n          setPreloadedImages((prev) => {\n            const newSet = new Set(prev).add(src);\n            // Mark first image as loaded if this is the first image we've loaded\n            if (!hasLoadedFirstImage && src === images[0]) {\n              setHasLoadedFirstImage(true);\n            }\n            return newSet;\n          });\n          resolve();\n        };\n        img.onerror = () => {\n          setImageLoadErrors((prev) => new Set(prev).add(src));\n          resolve();\n        };\n        img.src = src;\n      });\n    };\n\n    // Preload current and next few images\n    const preloadNext = async () => {\n      const preloadCount = Math.min(5, images.length); // Preload next 5 images\n      const preloadPromises: Promise<void>[] = [];\n\n      for (let i = 0; i < preloadCount; i++) {\n        const index = (currentIndex + i) % images.length;\n        preloadPromises.push(preloadImage(images[index]));\n      }\n\n      await Promise.all(preloadPromises);\n    };\n\n    preloadNext();\n  }, [images, currentIndex, imageLoadErrors, hasLoadedFirstImage]);\n\n  // Start slideshow when images are available\n  useEffect(() => {\n    if (images.length === 0) return;\n    if (images.length === 1) return; // No cycling needed for single image\n\n    const startSlideshow = () => {\n      intervalRef.current = window.setInterval(() => {\n        setCurrentIndex((prev) => (prev + 1) % images.length);\n        setImageKey((prev) => prev + 1);\n      }, zoomDuration);\n    };\n\n    // Start cycling after brief delay to allow for initial preloading\n    const initialDelay = window.setTimeout(startSlideshow, 2000);\n\n    return () => {\n      window.clearTimeout(initialDelay);\n      if (intervalRef.current) {\n        window.clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [images.length, zoomDuration]);\n\n  // Cleanup interval on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        window.clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, []);\n\n  const currentImage = images[currentIndex] || '';\n  const isCurrentImagePreloaded =\n    preloadedImages.has(currentImage) || preloadRef.current.has(currentImage);\n  const hasCurrentImageError = imageLoadErrors.has(currentImage);\n\n  // Skip to next image if current image failed to load\n  useEffect(() => {\n    if (hasCurrentImageError && images.length > 1) {\n      // Check if all images have failed to prevent infinite loop\n      const allImagesFailed = images.every((img) => imageLoadErrors.has(img));\n      if (!allImagesFailed) {\n        const nextIndex = (currentIndex + 1) % images.length;\n        setCurrentIndex(nextIndex);\n        setImageKey((prev) => prev + 1);\n      }\n    }\n  }, [hasCurrentImageError, currentIndex, images.length, images, imageLoadErrors]);\n\n  if (images.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={clsx('image-slideshow-container', className)} aria-hidden>\n      {/* Fallback background during loading */}\n      <div className=\"image-slideshow-fallback\" />\n\n      {/* Show loading message while waiting for first image */}\n      {!hasLoadedFirstImage && images.length > 0 && (\n        <div className=\"loading-message\">{t('loadingImages')}</div>\n      )}\n\n      {/* Only show image if it's preloaded and not errored */}\n      {isCurrentImagePreloaded && !hasCurrentImageError && (\n        <div\n          key={imageKey}\n          className=\"image-slideshow-slide\"\n          style={\n            {\n              backgroundImage: `url(${currentImage})`,\n              animationDuration: `${zoomDuration}ms`,\n              '--zoom-scale': zoomScale,\n            } as React.CSSProperties & { '--zoom-scale': number }\n          }\n        />\n      )}\n    </div>\n  );\n}\n","// Dedicated service for fetching images from Reddit\n\nexport interface RedditFeedConfig {\n  subreddit: string;\n  maxImages?: number;\n}\n\nexport interface RedditFeedResult {\n  images: string[];\n  source: string;\n}\n\n// Basic HTML entity decoding for Reddit preview URLs\nfunction decodeHtmlEntities(str: string): string {\n  return str.replace(/&amp;/g, '&');\n}\n\n// Multiple proxy services for CORS issues as fallbacks\n// cspell:ignore jina allorigins\nconst PROXY_SERVICES = ['r.jina.ai', 'api.allorigins.win/get?url=', 'corsproxy.io/?'];\n\nconst toProxyUrl = (url: string, serviceIndex: number = 0) => {\n  const service = PROXY_SERVICES[serviceIndex];\n  if (service === 'api.allorigins.win/get?url=') {\n    return `https://${service}${encodeURIComponent(url)}`;\n  }\n  if (service === 'corsproxy.io/?') {\n    return `https://${service}${encodeURIComponent(url)}`;\n  }\n  const withoutScheme = url.replace(/^https?:\\/\\//, '');\n  const scheme = url.startsWith('https://') ? 'https' : 'http';\n  return `https://${service}/${scheme}://${withoutScheme}`;\n};\n\n// Reddit-specific fetching logic\nexport async function fetchRedditImages(\n  subreddit: string,\n  maxCount: number,\n  signal: AbortSignal\n): Promise<string[]> {\n  const collected = new Set<string>();\n  let after: string | null = null;\n\n  const endpoints = [\n    // Use Reddit RSS/JSON feeds which are more permissive\n    (a: string | null) =>\n      `https://www.reddit.com/r/${subreddit}/top.json?limit=100&t=year&raw_json=1${a ? `&after=${a}` : ''}`,\n    (a: string | null) =>\n      `https://www.reddit.com/r/${subreddit}/hot.json?limit=100&raw_json=1${a ? `&after=${a}` : ''}`,\n  ];\n\n  const fetchJson = async (url: string): Promise<any | null> => {\n    // Try direct fetch with Reddit-friendly headers\n    try {\n      const resp = await fetch(url, {\n        signal,\n        credentials: 'omit',\n        mode: 'cors',\n        headers: {\n          'User-Agent': 'BlitzedOut/1.0',\n          Accept: 'application/json, text/plain, */*',\n          'Accept-Language': 'en-US,en;q=0.9',\n        },\n      });\n      if (resp.ok) {\n        const text = await resp.text();\n        try {\n          return JSON.parse(text);\n        } catch {\n          // Try to extract JSON from HTML response\n          const start = text.indexOf('{');\n          const end = text.lastIndexOf('}');\n          if (start !== -1 && end !== -1 && end > start) {\n            try {\n              return JSON.parse(text.slice(start, end + 1));\n            } catch {\n              return null;\n            }\n          }\n          return null;\n        }\n      }\n    } catch (error) {\n      if (error instanceof DOMException && error.name === 'AbortError') {\n        throw error;\n      }\n    }\n\n    // Try multiple CORS proxy services\n    for (let i = 0; i < PROXY_SERVICES.length; i++) {\n      try {\n        const proxyResp = await fetch(toProxyUrl(url, i), {\n          signal,\n          credentials: 'omit',\n          mode: 'cors',\n          headers: {\n            'User-Agent': 'BlitzedOut/1.0',\n            Accept: 'application/json, text/plain, */*',\n          },\n        });\n\n        if (!proxyResp.ok) continue;\n\n        const text = await proxyResp.text();\n\n        // Handle different proxy response formats\n        let jsonData;\n        try {\n          const parsed = JSON.parse(text);\n          // AllOrigins wraps response in contents property\n          jsonData = parsed.contents ? JSON.parse(parsed.contents) : parsed;\n        } catch {\n          // Try to extract JSON from HTML response\n          const start = text.indexOf('{');\n          const end = text.lastIndexOf('}');\n          if (start !== -1 && end !== -1 && end > start) {\n            try {\n              jsonData = JSON.parse(text.slice(start, end + 1));\n            } catch {\n              continue;\n            }\n          } else {\n            continue;\n          }\n        }\n\n        if (jsonData) {\n          return jsonData;\n        }\n      } catch (error) {\n        if (error instanceof DOMException && error.name === 'AbortError') {\n          throw error;\n        }\n        continue;\n      }\n    }\n\n    return null;\n  };\n\n  let endpointIndex = 0;\n  while (collected.size < maxCount && endpointIndex < endpoints.length) {\n    after = null;\n    for (let page = 0; page < 5 && collected.size < maxCount; page += 1) {\n      const url = endpoints[endpointIndex](after);\n      const json = await fetchJson(url);\n      if (!json) break;\n\n      const children = json?.data?.children ?? [];\n      after = json?.data?.after ?? null;\n\n      for (const child of children) {\n        const data = child?.data;\n        if (!data) continue;\n\n        const direct = data.url_overridden_by_dest as string | undefined;\n        const postHint = data.post_hint as string | undefined;\n\n        // Gallery support\n        if (data.is_gallery && data.media_metadata && data.gallery_data) {\n          const items = (data.gallery_data.items || []) as Array<{ media_id: string }>;\n          for (const it of items) {\n            const meta = data.media_metadata[it.media_id];\n            const source = meta?.s?.u || meta?.s?.gif || meta?.s?.mp4;\n            if (typeof source === 'string') {\n              const normalized = source.startsWith('http') ? source : `https:${source}`;\n              if (/\\.(jpe?g|png|gif|webp)(\\?.*)?$/i.test(normalized)) {\n                collected.add(decodeHtmlEntities(normalized));\n              }\n            }\n          }\n          continue;\n        }\n\n        if (postHint === 'image' && typeof direct === 'string') {\n          if (/\\.(jpe?g|png|gif|webp)(\\?.*)?$/i.test(direct)) {\n            collected.add(decodeHtmlEntities(direct));\n            continue;\n          }\n        }\n\n        const preview = data.preview?.images?.[0]?.source?.url as string | undefined;\n        if (preview) {\n          const normalized = preview.startsWith('http') ? preview : `https:${preview}`;\n          collected.add(decodeHtmlEntities(normalized));\n        }\n      }\n\n      if (!after) break;\n    }\n    endpointIndex += 1;\n  }\n\n  return Array.from(collected).slice(0, maxCount);\n}\n\n// Main Reddit service function\nexport async function fetchRedditFeed(\n  config: RedditFeedConfig,\n  signal: AbortSignal\n): Promise<RedditFeedResult> {\n  const maxImages = config.maxImages || 150;\n  const images = await fetchRedditImages(config.subreddit, maxImages, signal);\n\n  return {\n    images,\n    source: `r/${config.subreddit}`,\n  };\n}\n\n// Helper functions\nexport function isRedditUrl(url: string): boolean {\n  try {\n    const parsed = new URL(url);\n    return /(^|\\.)reddit\\.com$/i.test(parsed.hostname) && /\\/r\\//i.test(parsed.pathname);\n  } catch {\n    return false;\n  }\n}\n\nexport function extractSubredditFromUrl(url: string): string | null {\n  try {\n    const parsed = new URL(url);\n    const match = parsed.pathname.match(/\\/r\\/([^/]+)/i);\n    return match?.[1] ?? null;\n  } catch {\n    return null;\n  }\n}\n\n// Cache management for Reddit feeds\nconst CACHE_TTL_MS = 300_000; // 300 seconds (5 minutes)\nconst cache = new Map<string, { fetchedAt: number; result: RedditFeedResult }>();\nconst inFlight = new Map<string, Promise<RedditFeedResult>>();\n\nexport async function getCachedRedditFeed(\n  config: RedditFeedConfig,\n  signal: AbortSignal\n): Promise<RedditFeedResult> {\n  const cacheKey = JSON.stringify(config);\n  const now = Date.now();\n\n  const cached = cache.get(cacheKey);\n  if (cached && now - cached.fetchedAt < CACHE_TTL_MS) {\n    return cached.result;\n  }\n\n  const existing = inFlight.get(cacheKey);\n  if (existing) {\n    try {\n      return await existing;\n    } catch {\n      // fall through to fresh fetch\n    }\n  }\n\n  const promise = fetchRedditFeed(config, signal)\n    .then((result) => {\n      cache.set(cacheKey, { fetchedAt: Date.now(), result });\n      return result;\n    })\n    .finally(() => {\n      inFlight.delete(cacheKey);\n    });\n\n  inFlight.set(cacheKey, promise);\n  return promise;\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\n\nimport {\n  type RedditFeedConfig,\n  getCachedRedditFeed,\n  extractSubredditFromUrl,\n  isRedditUrl,\n} from '@/services/redditService';\n\ninterface UseRedditFeedResult {\n  images: string[];\n  isLoading: boolean;\n  error: string | null;\n  source: string | null;\n}\n\nexport function useRedditFeed(url: string | null): UseRedditFeedResult {\n  const { t } = useTranslation();\n  const [images, setImages] = useState<string[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [errorCode, setErrorCode] = useState<string | null>(null);\n  const [source, setSource] = useState<string | null>(null);\n\n  const abortRef = useRef<AbortController | null>(null);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    // Cleanup previous request and timeouts\n    if (abortRef.current) {\n      abortRef.current.abort();\n    }\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n    if (retryTimeoutRef.current) {\n      clearTimeout(retryTimeoutRef.current);\n      retryTimeoutRef.current = null;\n    }\n\n    // Reset state\n    setImages([]);\n    setErrorCode(null);\n    setSource(null);\n\n    // Check if URL is a Reddit URL\n    if (!url || !isRedditUrl(url)) {\n      setIsLoading(false);\n      return;\n    }\n\n    const subreddit = extractSubredditFromUrl(url);\n    if (!subreddit) {\n      setErrorCode('invalidRedditUrl');\n      setIsLoading(false);\n      return;\n    }\n\n    const config: RedditFeedConfig = {\n      subreddit,\n      maxImages: 150,\n    };\n\n    setIsLoading(true);\n    const controller = new AbortController();\n    abortRef.current = controller;\n\n    const loadRedditImages = async (retryCount = 0) => {\n      try {\n        const result = await getCachedRedditFeed(config, controller.signal);\n\n        if (controller.signal.aborted) return;\n\n        setImages(result.images);\n        setSource(result.source);\n        setErrorCode(null);\n        setIsLoading(false);\n      } catch {\n        if (controller.signal.aborted) return;\n\n        // Retry logic for Reddit CORS/network issues\n        const maxRetries = 2;\n        if (retryCount < maxRetries) {\n          const retryDelay = Math.pow(2, retryCount) * 1000; // Exponential backoff\n\n          retryTimeoutRef.current = setTimeout(() => {\n            if (!controller.signal.aborted) {\n              loadRedditImages(retryCount + 1);\n            }\n          }, retryDelay);\n          return;\n        }\n\n        // Final error after all retries\n        setErrorCode('redditBlocked');\n        setImages([]);\n        setSource(null);\n        setIsLoading(false);\n      }\n    };\n\n    // Small delay to avoid rapid API calls during development\n    timeoutRef.current = setTimeout(loadRedditImages, 300);\n\n    return () => {\n      controller.abort();\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n        retryTimeoutRef.current = null;\n      }\n    };\n  }, [url]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortRef.current) {\n        abortRef.current.abort();\n      }\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n        retryTimeoutRef.current = null;\n      }\n    };\n  }, []);\n\n  return {\n    images,\n    isLoading,\n    error: errorCode ? t(errorCode) : null,\n    source,\n  };\n}\n","import { alpha, useTheme } from '@mui/material/styles';\n\nimport ImageSlideshow from '@/components/ImageSlideshow';\nimport { useRedditFeed } from '@/hooks/useRedditFeed';\nimport { useTranslation } from 'react-i18next';\n\ninterface RedditSlideshowProps {\n  url: string;\n}\n\nexport default function RedditSlideshow({ url }: RedditSlideshowProps) {\n  const { t } = useTranslation();\n  const theme = useTheme();\n  const { images, isLoading, error } = useRedditFeed(url);\n\n  if (isLoading) {\n    return (\n      <div className=\"slideshow-container slideshow-loading\" aria-hidden>\n        {/* Show fallback gradient background during loading */}\n        <div className=\"image-slideshow-fallback\" />\n        <div className=\"loading-message\">{t('loadingRedditImages')}</div>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"slideshow-container slideshow-error\" aria-hidden>\n        {/* Show fallback gradient background on error */}\n        <div className=\"image-slideshow-fallback\" />\n        <div\n          className=\"error-message\"\n          style={{\n            position: 'absolute',\n            bottom: '20px',\n            right: '20px',\n            background: alpha(theme.palette.background.paper, 0.7),\n            color: theme.palette.text.primary,\n            padding: '12px 16px',\n            borderRadius: '8px',\n            fontSize: '14px',\n            maxWidth: '300px',\n            zIndex: 1000,\n          }}\n        >\n          <strong>{t('redditBackgroundNote')}</strong>\n          <br />\n          {t('redditBlocked')}\n        </div>\n      </div>\n    );\n  }\n\n  if (images.length === 0) {\n    return (\n      <div className=\"slideshow-container slideshow-empty\" aria-hidden>\n        <div className=\"image-slideshow-fallback\" />\n      </div>\n    );\n  }\n\n  return <ImageSlideshow images={images} />;\n}\n","import './styles.css';\n\nimport { Box } from '@mui/material';\nimport clsx from 'clsx';\n\nimport DirectMediaHandler from '@/components/DirectMediaHandler';\nimport RedditSlideshow from '@/components/RedditSlideshow';\nimport { isRedditUrl } from '@/services/redditService';\n\ninterface RoomBackgroundProps {\n  url?: string | null;\n  isVideo?: boolean | null;\n}\n\nexport default function RoomBackground({ url = null, isVideo = null }: RoomBackgroundProps) {\n  // Check if the URL is a direct video file (MP4, WebM, etc.)\n  const isDirectVideo = url && /\\.(mp4|webm|ogg|mov|gif)(\\?.*)?$/i.test(url);\n\n  // Check if URL is a Reddit URL\n  const isReddit = url ? isRedditUrl(url) : false;\n\n  // Show default background when no custom background is set OR when background is \"color\" or \"gray\"\n  const isNonImageBackground =\n    url === 'color' || url === 'gray' || url?.includes('/color') || url?.includes('/gray');\n  const hasCustomBackground = url && !isNonImageBackground && (isVideo || (!isVideo && url));\n\n  // Special handling for different content types\n  const shouldShowRedditSlideshow = !isVideo && isReddit && url;\n\n  return (\n    <Box\n      className={clsx('main-container', !hasCustomBackground && 'default-background')}\n      role=\"presentation\"\n      sx={{\n        backgroundImage:\n          !isVideo && url && !isNonImageBackground && !isReddit ? `url(${url})` : 'none',\n      }}\n    >\n      {isVideo &&\n        !isReddit &&\n        // Use DirectMediaHandler only for direct video files (e.g., mp4, webm, etc.)\n        (isDirectVideo ? (\n          <DirectMediaHandler url={url} />\n        ) : (\n          <iframe\n            src={url || undefined}\n            title=\"video\"\n            width=\"100%\"\n            height=\"100%\"\n            allow=\"autoplay; fullscreen; encrypted-media; picture-in-picture\"\n            sandbox=\"allow-same-origin allow-scripts allow-presentation\"\n            style={{ border: 'none' }}\n          />\n        ))}\n\n      {/* Reddit slideshow if a Reddit URL is provided */}\n      {shouldShowRedditSlideshow ? <RedditSlideshow url={url} /> : null}\n    </Box>\n  );\n}\n","import { getURLPath } from '@/helpers/urls';\nimport { isPublicRoom } from '@/helpers/strings';\nimport { logger } from '@/utils/logger';\n\nfunction vimeo(url: string): string {\n  const vimeoRegex = /vimeo\\.com\\/(\\d+)/;\n  const match = url.match(vimeoRegex);\n  const videoId = match ? match[1] : '';\n\n  return `https://player.vimeo.com/video/${videoId}?autoplay=1&loop=1&autostart=true`;\n}\n\nfunction youtube(url: string): string {\n  const youtubeRegex =\n    /(?:youtube\\.com\\/(?:[^/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|[^#]*[?&]v=|youtu\\.be\\/)([^\"&?/ ]{11})|^(?:[^\"&?/ ]{11})$)/;\n  const match = url.match(youtubeRegex);\n  const videoId = match ? match[1] : '';\n\n  return `https://www.youtube.com/embed/${videoId}?autoplay=1&loop=1&autostart=true&mute=1&playsinline=1&controls=0&disablekb=1&fs=0&modestbranding=1&rel=0&iv_load_policy=3`;\n}\n\nfunction googleDrive(url: string): string {\n  const driveRegex = /drive\\.google\\.com\\/file\\/d\\/([^/]+)/;\n  const match = url.match(driveRegex);\n  const fileId = match ? match[1] : '';\n\n  return `https://drive.google.com/file/d/${fileId}/preview?loop=1`;\n}\n\nfunction dropBox(url: string): string {\n  const dropBoxRegex = /dropbox\\.com\\/s\\/([^/]+)/;\n  const match = url.match(dropBoxRegex);\n  const fileId = match ? match[1] : '';\n\n  return `https://www.dropbox.com/s/${fileId}?raw=1`;\n}\n\nfunction pornhub(url: string): string {\n  const params = new URL(url);\n  const viewKey = params.searchParams.get('viewkey') || '';\n\n  return `https://pornhub.com/embed/${viewKey}?autoplay=1&loop=1&autostart=true&playsinline=1`;\n}\n\nfunction xhamster(url: string): string {\n  const urlParts = url.split('-');\n  const key = urlParts[urlParts.length - 1];\n\n  return `https://xhamster.com/xembed.php?video=${key}?autoplay=1&loop=1&autostart=true&playsinline=1`;\n}\n\nfunction tenor(url: string): { url: string; isVideo: boolean } {\n  // Handle direct media URLs: https://media.tenor.com/{id}/filename.{ext} or https://media1.tenor.com/m/{id}/filename.{ext}\n  const directMediaRegex =\n    /media1?\\.tenor\\.com\\/(?:m\\/)?([a-zA-Z0-9_-]+)\\/[^/]*\\.(mp4|gif|webp|webm)/;\n  const directMatch = url.match(directMediaRegex);\n\n  if (directMatch) {\n    const extension = directMatch[2].toLowerCase();\n    // Return the direct media URL as-is for direct playback\n    return {\n      url,\n      isVideo: ['mp4', 'webm'].includes(extension),\n    };\n  }\n\n  // Handle view URLs: https://tenor.com/view/{title}-{id}\n  const viewRegex = /tenor\\.com\\/view\\/[^/]*-(\\d+)/;\n  const viewMatch = url.match(viewRegex);\n\n  if (viewMatch) {\n    const numericId = viewMatch[1];\n    // Use Tenor's embed endpoint which will be handled by iframe\n    return {\n      url: `https://tenor.com/embed/${numericId}`,\n      isVideo: true,\n    };\n  }\n\n  // If we can't match any pattern, return the original URL\n  return {\n    url,\n    isVideo: false,\n  };\n}\n\nfunction giphy(url: string): string {\n  const giphyRegex = /giphy\\.com\\/gifs\\/[^/]*-([a-zA-Z0-9]+)/;\n  const match = url.match(giphyRegex);\n  const gifId = match ? match[1] : '';\n\n  // For Cast compatibility, try direct media URL first, fallback to embed\n  // Giphy direct media format: https://media.giphy.com/media/{id}/giphy.gif\n  return `https://media.giphy.com/media/${gifId}/giphy.gif`;\n}\n\nfunction tumblr(url: string): string {\n  // Handle direct Tumblr media URLs: https://64.media.tumblr.com/...\n  // These are already direct media URLs, so return as-is for GIF playback\n  const directMediaRegex = /\\d+\\.media\\.tumblr\\.com\\/.*\\.(gif|mp4|webm)(\\?.*)?$/i;\n  if (directMediaRegex.test(url)) {\n    return url;\n  }\n\n  // Handle other Tumblr URL patterns if needed in the future\n  // For now, just return the URL as-is since most Tumblr media URLs are direct\n  return url;\n}\n\nfunction gfycat(url: string): string {\n  // Handle both gfycat.com and redgifs.com\n  const gfycatRegex = /(?:gfycat\\.com|redgifs\\.com)\\/(?:watch\\/)?([a-zA-Z0-9]+)/;\n  const match = url.match(gfycatRegex);\n  const gifId = match ? match[1] : '';\n\n  // For Cast compatibility, try direct video URLs\n  if (isValidHost(url, ['redgifs.com'])) {\n    // RedGifs direct video format\n    return `https://files.redgifs.com/${gifId}.mp4`;\n  }\n  // Gfycat direct video format\n  return `https://giant.gfycat.com/${gifId}.mp4`;\n}\n\nfunction redtube(url: string): string {\n  const redtubeRegex = /redtube\\.com\\/(\\d+)/;\n  const match = url.match(redtubeRegex);\n  const videoId = match ? match[1] : '';\n  return `https://embed.redtube.com/?id=${videoId}&autoplay=true&auto_play=1&playsinline=1&controls=1`;\n}\n\nfunction youporn(url: string): string {\n  const youpornRegex = /youporn\\.com\\/watch\\/(\\d+)/;\n  const match = url.match(youpornRegex);\n  const videoId = match ? match[1] : '';\n\n  return `https://www.youporn.com/embed/${videoId}?autoplay=1&playsinline=1`;\n}\n\nfunction tube8(url: string): string {\n  const tube8Regex = /tube8\\.com\\/[^/]+\\/[^/]+\\/(\\d+)/;\n  const match = url.match(tube8Regex);\n  const videoId = match ? match[1] : '';\n\n  return `https://www.tube8.com/embed/${videoId}?autoplay=1&playsinline=1`;\n}\n\nfunction twitter(url: string): string {\n  // Twitter/X embed: use twitframe.com to generate an embeddable URL for the tweet\n  // This works for most public tweets and does not require API keys\n  return `https://twitframe.com/show?url=${encodeURIComponent(url)}`;\n}\n\nfunction thisvid(url: string): string {\n  // Thisvid URLs don't have extractable IDs in a predictable format\n  // Return the original URL as-is since the site handles its own embedding\n  return url;\n}\n\nfunction boyfriendtv(url: string): string {\n  // BoyfriendTV URLs don't have extractable IDs in a predictable format\n  // Return the original URL as-is since the site handles its own embedding\n  return url;\n}\n\nfunction imgur(url: string): string {\n  // For Discord proxy URLs that contain Imgur links, just return the URL directly\n  try {\n    const parsed = new URL(url);\n    // Check if this is a legitimate Discord external proxy URL for Imgur\n    // Discord external URLs follow the pattern: /external/{hash}/https/i.imgur.com/{id}.{ext}\n    if (\n      (parsed.host === 'discordapp.net' || parsed.host.endsWith('.discordapp.net')) &&\n      parsed.pathname.startsWith('/external/') &&\n      (parsed.pathname.includes('/https/i.imgur.com/') ||\n        parsed.pathname.includes('/https/imgur.com/'))\n    ) {\n      return url;\n    }\n  } catch (error) {\n    // If URL parsing fails, skip Discord proxy check for security\n    logger.debug('URL parsing failed for Discord proxy check:', error);\n  }\n\n  // Check if URL is already a direct i.imgur.com link with parameters or extension and return unchanged\n  try {\n    const parsed = new URL(url);\n    if (parsed.host === 'i.imgur.com') {\n      // Only return unchanged if it has parameters or a file extension\n      if (parsed.search || parsed.pathname.match(/\\.[a-zA-Z0-9]+$/)) {\n        return url;\n      }\n      // If it's a bare i.imgur.com URL without extension or parameters, continue processing\n    }\n  } catch (error) {\n    logger.debug('URL parsing failed for direct link check:', error);\n  }\n\n  // Extract the Imgur ID from different possible URL formats\n  let imgurId = '';\n\n  // Validate that this is actually an Imgur URL for security\n  let isImgur = false;\n  try {\n    const parsed = new URL(url);\n    isImgur = parsed.host === 'imgur.com' || parsed.host === 'i.imgur.com';\n  } catch (error) {\n    // If URL parsing fails, skip processing for security\n    logger.debug('URL parsing failed for Imgur processing:', error);\n    return '';\n  }\n\n  if (!isImgur) {\n    // Not a valid Imgur URL, return empty string\n    return '';\n  }\n\n  // Handle gallery URLs like:\n  // https://imgur.com/gallery/title-3YkU9Yc#6fDSu6z (with fragment)\n  // https://imgur.com/gallery/fusion-friday-wIJ8AJs (without fragment)\n  if (url.includes('/gallery/')) {\n    const galleryMatch = url.match(/imgur\\.com\\/gallery\\/[^#]*#([a-zA-Z0-9]+)/);\n    if (galleryMatch) {\n      // Gallery URL with fragment - use the fragment ID (this is usually a direct image ID)\n      imgurId = galleryMatch[1];\n    } else {\n      // Gallery URL without fragment - these are tricky because the ID in the path\n      // is often a gallery ID, not a direct image ID. For galleries, we should\n      // return the original URL and let the browser handle it, or try common formats\n      const pathMatch = url.match(/imgur\\.com\\/gallery\\/.*-([a-zA-Z0-9]+)/);\n      if (pathMatch) {\n        // Try the extracted ID but note this might not work for all galleries\n        imgurId = pathMatch[1];\n      } else {\n        // If we can't extract an ID, return the original URL for graceful handling\n        logger.debug('Could not extract image ID from gallery URL, returning original:', url);\n        return url;\n      }\n    }\n  } else {\n    // Handle regular URLs - enhanced regex to be more inclusive\n    const imgurRegex =\n      /imgur\\.com\\/([a-zA-Z0-9]+)(?:\\.(mp4|mov|avi|webm|mkv|flv|wmv|jpg|jpeg|png|gif|gifv|webp|bmp|tiff|svg))?|images-ext-\\d+\\.discordapp\\.net\\/external\\/[^/]+\\/https\\/i\\.imgur\\.com\\/([a-zA-Z0-9]+)\\.(mp4|mov|avi|webm|mkv|flv|wmv|jpg|jpeg|png|gif|gifv|webp|bmp|tiff|svg)/;\n    const match = url.match(imgurRegex);\n    imgurId = match ? match[1] || match[3] : '';\n  }\n\n  if (!imgurId) {\n    return '';\n  }\n\n  // Enhanced extension detection with more inclusive regex\n  const extensionMatch = url.match(/\\.([a-zA-Z0-9]+)(?:\\?.*)?$/);\n  let extension = 'jpg'; // Use .jpg as default instead of .gif for better compatibility\n\n  if (extensionMatch && extensionMatch[1]) {\n    // Preserve the original extension if it exists\n    let originalExtension = extensionMatch[1].toLowerCase();\n\n    // Extension mapping for compatibility - convert .gifv to .mp4\n    const extensionMap: { [key: string]: string } = {\n      gifv: 'mp4',\n    };\n\n    if (extensionMap[originalExtension]) {\n      originalExtension = extensionMap[originalExtension];\n    }\n\n    // Only use common image/video extensions for security\n    if (\n      [\n        'jpg',\n        'jpeg',\n        'png',\n        'gif',\n        'webp',\n        'mp4',\n        'mov',\n        'avi',\n        'webm',\n        'mkv',\n        'flv',\n        'wmv',\n        'bmp',\n        'tiff',\n        'svg',\n      ].includes(originalExtension)\n    ) {\n      extension = originalExtension;\n    }\n  }\n\n  const finalUrl = `https://i.imgur.com/${imgurId}.${extension}`;\n\n  // Return direct link with preserved or converted extension\n  return finalUrl;\n}\n\nfunction isDirectVideoUrl(url: string): boolean {\n  return /\\.(mp4|webm|ogg|mov)(\\?.*)?$/.test(url);\n}\n\nfunction isDiscordMediaUrl(url: string): boolean {\n  return isValidHost(url, ['media.discordapp.net', 'cdn.discordapp.com']) && !isDirectVideoUrl(url);\n}\n\nfunction isValidHost(url: string, allowedHosts: string[]): boolean {\n  try {\n    const parsed = new URL(url);\n    return allowedHosts.some((host) => parsed.host === host || parsed.host.endsWith('.' + host));\n  } catch (error) {\n    // If URL parsing fails, reject for security\n    logger.debug('URL parsing failed in isValidHost, rejecting for security:', error);\n    return false;\n  }\n}\n\ninterface BackgroundResult {\n  url: string | null;\n  isVideo: boolean;\n}\n\nexport function processBackground(url: string | null | undefined): BackgroundResult {\n  let embedUrl: string | null = null;\n  let isVideo = true;\n\n  if (!url) {\n    return { url: '', isVideo: false };\n  }\n\n  switch (true) {\n    case isValidHost(url, ['vimeo.com']):\n      embedUrl = vimeo(url);\n      break;\n    case isValidHost(url, ['youtube.com', 'youtu.be']):\n      embedUrl = youtube(url);\n      break;\n    case isValidHost(url, ['drive.google.com']):\n      embedUrl = googleDrive(url);\n      break;\n    case isValidHost(url, ['pornhub.com']):\n      embedUrl = pornhub(url);\n      break;\n    case isValidHost(url, ['xhamster.com']):\n      embedUrl = xhamster(url);\n      break;\n    case isValidHost(url, ['dropbox.com']):\n      embedUrl = dropBox(url);\n      break;\n    case isValidHost(url, ['imgur.com', 'i.imgur.com']):\n      embedUrl = imgur(url);\n      break;\n    case isValidHost(url, ['tenor.com']): {\n      const tenorResult = tenor(url);\n      embedUrl = tenorResult.url;\n      isVideo = tenorResult.isVideo;\n      break;\n    }\n    case isValidHost(url, ['giphy.com']):\n      embedUrl = giphy(url);\n      isVideo = true;\n      break;\n    case isValidHost(url, ['tumblr.com', 'media.tumblr.com']) ||\n      /\\d+\\.media\\.tumblr\\.com/.test(url):\n      embedUrl = tumblr(url);\n      isVideo = embedUrl ? isDirectVideoUrl(embedUrl) : false;\n      break;\n    case isValidHost(url, ['gfycat.com', 'redgifs.com']):\n      embedUrl = gfycat(url);\n      isVideo = true;\n      break;\n    case isValidHost(url, ['redtube.com']):\n      embedUrl = redtube(url);\n      break;\n    case isValidHost(url, ['youporn.com']):\n      embedUrl = youporn(url);\n      break;\n    case isValidHost(url, ['tube8.com']):\n      embedUrl = tube8(url);\n      break;\n    case isValidHost(url, ['twitter.com', 'x.com']):\n      embedUrl = twitter(url);\n      isVideo = false;\n      break;\n    case isValidHost(url, ['thisvid.com']):\n      embedUrl = thisvid(url);\n      break;\n    case isValidHost(url, ['boyfriendtv.com']):\n      embedUrl = boyfriendtv(url);\n      break;\n    case isDiscordMediaUrl(url):\n      embedUrl = url;\n      isVideo = false;\n      break;\n    case isDirectVideoUrl(url):\n      embedUrl = url;\n      break;\n    default:\n      embedUrl = getURLPath(url);\n      isVideo = false;\n      break;\n  }\n  return {\n    url: embedUrl,\n    isVideo,\n  };\n}\n\ninterface BackgroundSettings {\n  background?: string;\n  backgroundURL?: string;\n  roomBackground?: string;\n  roomBackgroundURL?: string;\n}\n\nexport default function getBackgroundSource(\n  settings: BackgroundSettings,\n  room: string\n): BackgroundResult {\n  const { background, backgroundURL, roomBackgroundURL } = settings;\n\n  // New simplified background resolution logic:\n  // 1. User-set app background (always wins if set)\n  // 2. Private room with \"Use Room Background\" + room has URL → use room URL\n  // 3. Private room with \"Use Room Background\" + no room URL → \"color\"\n  // 4. Public room → \"color\" (no \"Use Room Background\" option)\n  // 5. No app background set → \"color\"\n\n  let finalBackground: string | null = null;\n\n  // Priority 1: Check if user has set an app background preference\n  if (background) {\n    if (background === 'custom') {\n      // User wants custom app background\n      finalBackground = backgroundURL || null;\n    } else if (background === 'useRoomBackground') {\n      // User wants to use room background (only valid in private rooms)\n      if (!isPublicRoom(room) && roomBackgroundURL) {\n        // Private room with room background URL set\n        finalBackground = roomBackgroundURL;\n      } else {\n        // Public room or private room without room background URL\n        finalBackground = 'color';\n      }\n    } else {\n      // Built-in app background (color, gray, metronome.gif, etc.)\n      finalBackground = background;\n    }\n  } else {\n    // No app background preference set - default to color tiles\n    finalBackground = 'color';\n  }\n\n  if (!finalBackground) {\n    finalBackground = 'color';\n  }\n\n  // Handle built-in background types without processing\n  if (finalBackground === 'color' || finalBackground === 'gray') {\n    const result = { url: finalBackground, isVideo: false };\n    return result;\n  }\n\n  const result = processBackground(finalBackground);\n\n  return result;\n}\n","import { useEffect, useState, useMemo } from 'react';\nimport useHybridPlayerList, { type HybridPlayer } from './useHybridPlayerList';\nimport { Player } from '@/types/player';\n\ninterface Message {\n  uid: string;\n  [key: string]: any;\n}\n\nfunction convertHybridPlayerToPlayer(hybridPlayer: HybridPlayer): Player {\n  return {\n    uid: hybridPlayer.uid,\n    displayName: hybridPlayer.displayName,\n    isSelf: hybridPlayer.isSelf,\n    isFinished: hybridPlayer.isFinished,\n  };\n}\n\nexport default function useTurnIndicator(message?: Message): Player | null {\n  const [turnIndicator, setTurnIndicator] = useState<Player | null>(null);\n  const hybridPlayers = useHybridPlayerList();\n\n  // Create a stable representation of players to prevent infinite loops\n  const playersHash = useMemo(() => {\n    return hybridPlayers\n      .map((p) => `${p.uid}-${p.displayName}-${p.isFinished}-${p.isSelf}`)\n      .join('|');\n  }, [hybridPlayers]);\n\n  // Create a stable representation of the message to prevent infinite loops\n  const messageHash = useMemo(() => {\n    return message ? `${message.uid}-${message.displayName || ''}` : null;\n  }, [message]);\n\n  useEffect(() => {\n    if (!message) {\n      setTurnIndicator(null);\n      return;\n    }\n\n    // Single player or not enough players for turns\n    if (hybridPlayers.length <= 1) {\n      setTurnIndicator(null);\n      return;\n    }\n\n    // Filter out finished players\n    const stillPlaying = hybridPlayers.filter((player) => !player.isFinished);\n\n    if (stillPlaying.length <= 1) {\n      setTurnIndicator(null);\n      return;\n    }\n\n    // For local players, we need to find by displayName since message.uid might not match\n    // For remote players, we find by uid\n    let currentPlayerIndex = -1;\n\n    // First try to find by uid (works for remote players)\n    currentPlayerIndex = stillPlaying.findIndex((player) => player.uid === message.uid);\n\n    // If not found and we have local players, try finding by displayName\n    if (currentPlayerIndex === -1) {\n      currentPlayerIndex = stillPlaying.findIndex(\n        (player) => player.displayName === message.displayName\n      );\n    }\n\n    // If we still can't find the player, use the first player as fallback\n    if (currentPlayerIndex === -1) {\n      currentPlayerIndex = 0;\n    }\n\n    // Get the next player in turn order\n    const nextIndex = (currentPlayerIndex + 1) % stillPlaying.length;\n    const nextHybridPlayer = stillPlaying[nextIndex];\n\n    // Convert to Player format for the indicator\n    const nextPlayer = convertHybridPlayerToPlayer(nextHybridPlayer);\n    setTurnIndicator(nextPlayer);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [messageHash, playersHash]);\n\n  return turnIndicator;\n}\n"],"names":["cssUrl","url","cleanedUrl","char","codePoint","inferMediaType","u","DirectMediaHandler","mediaType","setMediaType","useState","currentUrl","setCurrentUrl","useEffect","handleVideoError","failingUrl","isImgur","parsed","imgurId","imageUrl","handleImageError","formats","currentFormat","nextIndex","nextFormat","nextUrl","jsx","jsxs","Fragment","ImageSlideshow","images","className","zoomDuration","zoomScale","t","useTranslation","currentIndex","setCurrentIndex","imageKey","setImageKey","preloadedImages","setPreloadedImages","imageLoadErrors","setImageLoadErrors","hasLoadedFirstImage","setHasLoadedFirstImage","intervalRef","useRef","preloadRef","preloadImage","src","resolve","img","prev","newSet","preloadCount","preloadPromises","i","index","startSlideshow","initialDelay","currentImage","isCurrentImagePreloaded","hasCurrentImageError","clsx","decodeHtmlEntities","str","PROXY_SERVICES","toProxyUrl","serviceIndex","service","withoutScheme","scheme","fetchRedditImages","subreddit","maxCount","signal","collected","after","endpoints","a","fetchJson","resp","text","start","end","error","proxyResp","jsonData","endpointIndex","page","json","children","child","data","direct","postHint","items","it","meta","source","normalized","preview","fetchRedditFeed","config","maxImages","isRedditUrl","extractSubredditFromUrl","CACHE_TTL_MS","cache","inFlight","getCachedRedditFeed","cacheKey","now","cached","existing","promise","result","useRedditFeed","setImages","isLoading","setIsLoading","errorCode","setErrorCode","setSource","abortRef","timeoutRef","retryTimeoutRef","controller","loadRedditImages","retryCount","retryDelay","RedditSlideshow","theme","useTheme","alpha","RoomBackground","isVideo","isDirectVideo","isReddit","isNonImageBackground","hasCustomBackground","shouldShowRedditSlideshow","Box","vimeo","vimeoRegex","match","youtube","youtubeRegex","googleDrive","driveRegex","dropBox","dropBoxRegex","pornhub","xhamster","urlParts","tenor","directMediaRegex","directMatch","extension","viewRegex","viewMatch","giphy","giphyRegex","tumblr","gfycat","gfycatRegex","gifId","isValidHost","redtube","redtubeRegex","youporn","youpornRegex","tube8","tube8Regex","twitter","imgur","logger","galleryMatch","pathMatch","imgurRegex","extensionMatch","originalExtension","extensionMap","isDirectVideoUrl","isDiscordMediaUrl","allowedHosts","host","processBackground","embedUrl","tenorResult","getURLPath","getBackgroundSource","settings","room","background","backgroundURL","roomBackgroundURL","finalBackground","isPublicRoom","convertHybridPlayerToPlayer","hybridPlayer","useTurnIndicator","message","turnIndicator","setTurnIndicator","hybridPlayers","useHybridPlayerList","playersHash","useMemo","p","messageHash","stillPlaying","player","currentPlayerIndex","nextHybridPlayer","nextPlayer"],"mappings":"gzBAKO,SAASA,EAAOC,EAAqB,CAE1C,IAAIC,EAAa,GACjB,UAAWC,KAAQ,OAAOF,CAAG,EAAG,CAC9B,MAAMG,EAAYD,EAAK,YAAY,CAAC,EAU/BC,GAAa,GAAQA,GAAa,IACnCA,IAAc,KACbA,GAAa,KAAQA,GAAa,KACnCA,IAAc,MACdA,IAAc,OAGhBF,GAAcC,EAElB,CAKA,MAAO,QAFYD,EAAW,QAAQ,MAAO,MAAM,EAAE,QAAQ,KAAM,KAAK,CAE/C,IAC3B,CC1BA,MAAMG,EAAkBC,GACjBA,GAED,oEAAoE,KAAKA,CAAC,EAAU,QAFzE,QAOjB,SAASC,EAAmB,CAAE,IAAAN,GAAgC,CAC5D,KAAM,CAACO,EAAWC,CAAY,EAAIC,EAAAA,SAA4BL,EAAeJ,CAAG,CAAC,EAC3E,CAACU,EAAYC,CAAa,EAAIF,EAAAA,SAAST,CAAG,EAQhD,GALAY,EAAAA,UAAU,IAAM,CACdD,EAAcX,CAAG,EACjBQ,EAAaJ,EAAeJ,CAAG,CAAC,CAClC,EAAG,CAACA,CAAG,CAAC,EAEJ,CAACU,EAAY,OAAO,KAExB,MAAMG,EAAmB,IAAM,CAC7B,MAAMC,EAAaJ,GAAcV,GAAO,GAExC,IAAIe,EAAU,GACd,GAAI,CACF,MAAMC,EAAS,IAAI,IAAIF,CAAU,EACjCC,EAAUC,EAAO,OAAS,aAAeA,EAAO,OAAS,aAC3D,MAAQ,CAEND,EAAU,EACZ,CAEA,GAAIA,EAAS,CACX,MAAME,EAAUH,EAAW,MAAM,iDAAiD,IAAI,CAAC,EACvF,GAAIG,EAAS,CACX,MAAMC,EAAW,uBAAuBD,CAAO,OAC/CN,EAAcO,CAAQ,EACtBV,EAAa,OAAO,EACpB,MACF,CACF,CAIA,MAAMU,EAAW,GADDJ,EAAW,QAAQ,gCAAiC,EAAE,CAC3C,OAC3BH,EAAcO,CAAQ,EACtBV,EAAa,OAAO,CACtB,EAEMW,EAAmB,IAAM,CAC7B,MAAML,EAAaJ,GAAcV,GAAO,GACxC,IAAIe,EAAU,GACd,GAAI,CACF,MAAMC,EAAS,IAAI,IAAIF,CAAU,EACjCC,EAAUC,EAAO,OAAS,aAAeA,EAAO,OAAS,aAC3D,MAAQ,CAEND,EAAU,EACZ,CAEA,GAAIA,EAAS,CAEX,MAAME,EAAUH,EAAW,MAAM,iDAAiD,IAAI,CAAC,EACvF,GAAIG,EAAS,CACX,MAAMG,EAAU,CAAC,MAAO,MAAO,MAAO,OAAQ,MAAM,EAC9CC,EAAgBX,GAAY,MAAM,GAAG,EAAE,IAAA,EAEvCY,EADeF,EAAQ,QAAQC,GAAiB,EAAE,EACvB,EAEjC,GAAIC,EAAYF,EAAQ,OAAQ,CAC9B,MAAMG,EAAaH,EAAQE,CAAS,EAC9BE,EAAU,uBAAuBP,CAAO,IAAIM,CAAU,GAC5DZ,EAAca,CAAO,CACvB,CACF,CACF,KAAO,CAEL,MAAMJ,EAAU,CAAC,MAAO,MAAO,MAAO,OAAQ,MAAM,EAC9CC,EAAgBX,GAAY,MAAM,GAAG,EAAE,IAAA,EAEvCY,EADeF,EAAQ,QAAQC,GAAiB,EAAE,EACvB,EAEjC,GAAIC,EAAYF,EAAQ,QAAUV,EAAY,CAC5C,MAAMa,EAAaH,EAAQE,CAAS,EAE9BE,EAAU,GADAd,EAAW,QAAQ,kBAAmB,EAAE,CAC9B,IAAIa,CAAU,GACxCZ,EAAca,CAAO,CACvB,CACF,CACF,EAEA,OAAIjB,IAAc,QAEdkB,EAAAA,IAAC,QAAA,CACC,SAAU,GACV,KAAM,GACN,MAAO,GACP,YAAa,GACb,IAAKf,GAAc,OACnB,UAAU,mBACV,QAASG,EAET,QAAQ,OACR,YAAY,YACZ,SAAU,EAAA,CAAA,EAOda,EAAAA,KAAAC,WAAA,CACE,SAAA,CAAAF,EAAAA,IAAC,MAAA,CACC,UAAU,mBACV,MAAO,CACL,gBAAiBf,EAAaX,EAAOW,CAAU,EAAI,OACnD,eAAgB,QAChB,mBAAoB,SACpB,iBAAkB,YAClB,MAAO,OACP,OAAQ,OACR,SAAU,WACV,IAAK,EACL,KAAM,CAAA,CACR,CAAA,EAEFe,EAAAA,IAAC,MAAA,CACC,IAAKf,GAAc,OACnB,QAASS,EACT,MAAO,CAAE,QAAS,MAAA,EAClB,IAAI,EAAA,CAAA,CACN,EACF,CAEJ,CChIA,SAAwBS,EAAe,CACrC,OAAAC,EACA,UAAAC,EACA,aAAAC,EAAe,IACf,UAAAC,EAAY,GACd,EAAwB,CACtB,KAAM,CAAE,EAAAC,CAAA,EAAMC,EAAA,EACR,CAACC,EAAcC,CAAe,EAAI3B,EAAAA,SAAS,CAAC,EAC5C,CAAC4B,EAAUC,CAAW,EAAI7B,EAAAA,SAAS,CAAC,EACpC,CAAC8B,EAAiBC,CAAkB,EAAI/B,EAAAA,SAAsB,IAAI,GAAK,EACvE,CAACgC,EAAiBC,CAAkB,EAAIjC,EAAAA,SAAsB,IAAI,GAAK,EACvE,CAACkC,EAAqBC,CAAsB,EAAInC,EAAAA,SAAS,EAAK,EAE9DoC,EAAcC,EAAAA,OAAsB,IAAI,EACxCC,EAAaD,EAAAA,OAAsC,IAAI,GAAK,EAGlElC,EAAAA,UAAU,IAAM,CACdgC,EAAuB,EAAK,EAC5BJ,EAAmB,IAAI,GAAK,EAC5BE,EAAmB,IAAI,GAAK,EAC5BK,EAAW,QAAQ,MAAA,EACnBX,EAAgB,CAAC,EACjBE,EAAY,CAAC,CACf,EAAG,CAACT,CAAM,CAAC,EAGXjB,EAAAA,UAAU,IAAM,CACd,GAAIiB,EAAO,SAAW,EAAG,OAEzB,MAAMmB,EAAgBC,GACb,IAAI,QAASC,GAAY,CAE9B,GAAIH,EAAW,QAAQ,IAAIE,CAAG,GAAKR,EAAgB,IAAIQ,CAAG,EAAG,CAC3DC,EAAA,EACA,MACF,CAEA,MAAMC,EAAM,IAAI,MAChBA,EAAI,OAAS,IAAM,CACjBJ,EAAW,QAAQ,IAAIE,EAAKE,CAAG,EAC/BX,EAAoBY,GAAS,CAC3B,MAAMC,EAAS,IAAI,IAAID,CAAI,EAAE,IAAIH,CAAG,EAEpC,MAAI,CAACN,GAAuBM,IAAQpB,EAAO,CAAC,GAC1Ce,EAAuB,EAAI,EAEtBS,CACT,CAAC,EACDH,EAAA,CACF,EACAC,EAAI,QAAU,IAAM,CAClBT,EAAoBU,GAAS,IAAI,IAAIA,CAAI,EAAE,IAAIH,CAAG,CAAC,EACnDC,EAAA,CACF,EACAC,EAAI,IAAMF,CACZ,CAAC,GAIiB,SAAY,CAC9B,MAAMK,EAAe,KAAK,IAAI,EAAGzB,EAAO,MAAM,EACxC0B,EAAmC,CAAA,EAEzC,QAASC,EAAI,EAAGA,EAAIF,EAAcE,IAAK,CACrC,MAAMC,GAAStB,EAAeqB,GAAK3B,EAAO,OAC1C0B,EAAgB,KAAKP,EAAanB,EAAO4B,CAAK,CAAC,CAAC,CAClD,CAEA,MAAM,QAAQ,IAAIF,CAAe,CACnC,GAEA,CACF,EAAG,CAAC1B,EAAQM,EAAcM,EAAiBE,CAAmB,CAAC,EAG/D/B,EAAAA,UAAU,IAAM,CAEd,GADIiB,EAAO,SAAW,GAClBA,EAAO,SAAW,EAAG,OAEzB,MAAM6B,EAAiB,IAAM,CAC3Bb,EAAY,QAAU,OAAO,YAAY,IAAM,CAC7CT,EAAiBgB,IAAUA,EAAO,GAAKvB,EAAO,MAAM,EACpDS,EAAac,GAASA,EAAO,CAAC,CAChC,EAAGrB,CAAY,CACjB,EAGM4B,EAAe,OAAO,WAAWD,EAAgB,GAAI,EAE3D,MAAO,IAAM,CACX,OAAO,aAAaC,CAAY,EAC5Bd,EAAY,UACd,OAAO,cAAcA,EAAY,OAAO,EACxCA,EAAY,QAAU,KAE1B,CACF,EAAG,CAAChB,EAAO,OAAQE,CAAY,CAAC,EAGhCnB,EAAAA,UAAU,IACD,IAAM,CACPiC,EAAY,UACd,OAAO,cAAcA,EAAY,OAAO,EACxCA,EAAY,QAAU,KAE1B,EACC,CAAA,CAAE,EAEL,MAAMe,EAAe/B,EAAOM,CAAY,GAAK,GACvC0B,EACJtB,EAAgB,IAAIqB,CAAY,GAAKb,EAAW,QAAQ,IAAIa,CAAY,EACpEE,EAAuBrB,EAAgB,IAAImB,CAAY,EAe7D,OAZAhD,EAAAA,UAAU,IAAM,CACd,GAAIkD,GAAwBjC,EAAO,OAAS,GAGtC,CADoBA,EAAO,MAAOsB,GAAQV,EAAgB,IAAIU,CAAG,CAAC,EAChD,CACpB,MAAM7B,GAAaa,EAAe,GAAKN,EAAO,OAC9CO,EAAgBd,CAAS,EACzBgB,EAAac,GAASA,EAAO,CAAC,CAChC,CAEJ,EAAG,CAACU,EAAsB3B,EAAcN,EAAO,OAAQA,EAAQY,CAAe,CAAC,EAE3EZ,EAAO,SAAW,EACb,KAIPH,OAAC,OAAI,UAAWqC,EAAK,4BAA6BjC,CAAS,EAAG,cAAW,GAEvE,SAAA,CAAAL,EAAAA,IAAC,MAAA,CAAI,UAAU,0BAAA,CAA2B,EAGzC,CAACkB,GAAuBd,EAAO,OAAS,GACvCJ,EAAAA,IAAC,MAAA,CAAI,UAAU,kBAAmB,SAAAQ,EAAE,eAAe,CAAA,CAAE,EAItD4B,GAA2B,CAACC,GAC3BrC,EAAAA,IAAC,MAAA,CAEC,UAAU,wBACV,MACE,CACE,gBAAiB,OAAOmC,CAAY,IACpC,kBAAmB,GAAG7B,CAAY,KAClC,eAAgBC,CAAA,CAClB,EAPGK,CAAA,CASP,EAEJ,CAEJ,CC9JA,SAAS2B,EAAmBC,EAAqB,CAC/C,OAAOA,EAAI,QAAQ,SAAU,GAAG,CAClC,CAIA,MAAMC,EAAiB,CAAC,YAAa,8BAA+B,gBAAgB,EAE9EC,EAAa,CAACnE,EAAaoE,EAAuB,IAAM,CAC5D,MAAMC,EAAUH,EAAeE,CAAY,EAC3C,GAAIC,IAAY,8BACd,MAAO,WAAWA,CAAO,GAAG,mBAAmBrE,CAAG,CAAC,GAErD,GAAIqE,IAAY,iBACd,MAAO,WAAWA,CAAO,GAAG,mBAAmBrE,CAAG,CAAC,GAErD,MAAMsE,EAAgBtE,EAAI,QAAQ,eAAgB,EAAE,EAC9CuE,EAASvE,EAAI,WAAW,UAAU,EAAI,QAAU,OACtD,MAAO,WAAWqE,CAAO,IAAIE,CAAM,MAAMD,CAAa,EACxD,EAGA,eAAsBE,EACpBC,EACAC,EACAC,EACmB,CACnB,MAAMC,MAAgB,IACtB,IAAIC,EAAuB,KAE3B,MAAMC,EAAY,CAEfC,GACC,4BAA4BN,CAAS,wCAAwCM,EAAI,UAAUA,CAAC,GAAK,EAAE,GACpGA,GACC,4BAA4BN,CAAS,iCAAiCM,EAAI,UAAUA,CAAC,GAAK,EAAE,EAAA,EAG1FC,EAAY,MAAOhF,GAAqC,CAE5D,GAAI,CACF,MAAMiF,EAAO,MAAM,MAAMjF,EAAK,CAC5B,OAAA2E,EACA,YAAa,OACb,KAAM,OACN,QAAS,CACP,aAAc,iBACd,OAAQ,oCACR,kBAAmB,gBAAA,CACrB,CACD,EACD,GAAIM,EAAK,GAAI,CACX,MAAMC,EAAO,MAAMD,EAAK,KAAA,EACxB,GAAI,CACF,OAAO,KAAK,MAAMC,CAAI,CACxB,MAAQ,CAEN,MAAMC,EAAQD,EAAK,QAAQ,GAAG,EACxBE,EAAMF,EAAK,YAAY,GAAG,EAChC,GAAIC,IAAU,IAAMC,IAAQ,IAAMA,EAAMD,EACtC,GAAI,CACF,OAAO,KAAK,MAAMD,EAAK,MAAMC,EAAOC,EAAM,CAAC,CAAC,CAC9C,MAAQ,CACN,OAAO,IACT,CAEF,OAAO,IACT,CACF,CACF,OAASC,EAAO,CACd,GAAIA,aAAiB,cAAgBA,EAAM,OAAS,aAClD,MAAMA,CAEV,CAGA,QAAS7B,EAAI,EAAGA,EAAIU,EAAe,OAAQV,IACzC,GAAI,CACF,MAAM8B,EAAY,MAAM,MAAMnB,EAAWnE,EAAKwD,CAAC,EAAG,CAChD,OAAAmB,EACA,YAAa,OACb,KAAM,OACN,QAAS,CACP,aAAc,iBACd,OAAQ,mCAAA,CACV,CACD,EAED,GAAI,CAACW,EAAU,GAAI,SAEnB,MAAMJ,EAAO,MAAMI,EAAU,KAAA,EAG7B,IAAIC,EACJ,GAAI,CACF,MAAMvE,EAAS,KAAK,MAAMkE,CAAI,EAE9BK,EAAWvE,EAAO,SAAW,KAAK,MAAMA,EAAO,QAAQ,EAAIA,CAC7D,MAAQ,CAEN,MAAMmE,EAAQD,EAAK,QAAQ,GAAG,EACxBE,EAAMF,EAAK,YAAY,GAAG,EAChC,GAAIC,IAAU,IAAMC,IAAQ,IAAMA,EAAMD,EACtC,GAAI,CACFI,EAAW,KAAK,MAAML,EAAK,MAAMC,EAAOC,EAAM,CAAC,CAAC,CAClD,MAAQ,CACN,QACF,KAEA,SAEJ,CAEA,GAAIG,EACF,OAAOA,CAEX,OAASF,EAAO,CACd,GAAIA,aAAiB,cAAgBA,EAAM,OAAS,aAClD,MAAMA,EAER,QACF,CAGF,OAAO,IACT,EAEA,IAAIG,EAAgB,EACpB,KAAOZ,EAAU,KAAOF,GAAYc,EAAgBV,EAAU,QAAQ,CACpED,EAAQ,KACR,QAASY,EAAO,EAAGA,EAAO,GAAKb,EAAU,KAAOF,EAAUe,GAAQ,EAAG,CACnE,MAAMzF,EAAM8E,EAAUU,CAAa,EAAEX,CAAK,EACpCa,EAAO,MAAMV,EAAUhF,CAAG,EAChC,GAAI,CAAC0F,EAAM,MAEX,MAAMC,EAAWD,GAAM,MAAM,UAAY,CAAA,EACzCb,EAAQa,GAAM,MAAM,OAAS,KAE7B,UAAWE,KAASD,EAAU,CAC5B,MAAME,EAAOD,GAAO,KACpB,GAAI,CAACC,EAAM,SAEX,MAAMC,EAASD,EAAK,uBACdE,EAAWF,EAAK,UAGtB,GAAIA,EAAK,YAAcA,EAAK,gBAAkBA,EAAK,aAAc,CAC/D,MAAMG,EAASH,EAAK,aAAa,OAAS,CAAA,EAC1C,UAAWI,KAAMD,EAAO,CACtB,MAAME,EAAOL,EAAK,eAAeI,EAAG,QAAQ,EACtCE,EAASD,GAAM,GAAG,GAAKA,GAAM,GAAG,KAAOA,GAAM,GAAG,IACtD,GAAI,OAAOC,GAAW,SAAU,CAC9B,MAAMC,EAAaD,EAAO,WAAW,MAAM,EAAIA,EAAS,SAASA,CAAM,GACnE,kCAAkC,KAAKC,CAAU,GACnDxB,EAAU,IAAIZ,EAAmBoC,CAAU,CAAC,CAEhD,CACF,CACA,QACF,CAEA,GAAIL,IAAa,SAAW,OAAOD,GAAW,UACxC,kCAAkC,KAAKA,CAAM,EAAG,CAClDlB,EAAU,IAAIZ,EAAmB8B,CAAM,CAAC,EACxC,QACF,CAGF,MAAMO,EAAUR,EAAK,SAAS,SAAS,CAAC,GAAG,QAAQ,IACnD,GAAIQ,EAAS,CACX,MAAMD,EAAaC,EAAQ,WAAW,MAAM,EAAIA,EAAU,SAASA,CAAO,GAC1EzB,EAAU,IAAIZ,EAAmBoC,CAAU,CAAC,CAC9C,CACF,CAEA,GAAI,CAACvB,EAAO,KACd,CACAW,GAAiB,CACnB,CAEA,OAAO,MAAM,KAAKZ,CAAS,EAAE,MAAM,EAAGF,CAAQ,CAChD,CAGA,eAAsB4B,EACpBC,EACA5B,EAC2B,CAC3B,MAAM6B,EAAYD,EAAO,WAAa,IAGtC,MAAO,CACL,OAHa,MAAM/B,EAAkB+B,EAAO,UAAWC,EAAW7B,CAAM,EAIxE,OAAQ,KAAK4B,EAAO,SAAS,EAAA,CAEjC,CAGO,SAASE,EAAYzG,EAAsB,CAChD,GAAI,CACF,MAAMgB,EAAS,IAAI,IAAIhB,CAAG,EAC1B,MAAO,sBAAsB,KAAKgB,EAAO,QAAQ,GAAK,SAAS,KAAKA,EAAO,QAAQ,CACrF,MAAQ,CACN,MAAO,EACT,CACF,CAEO,SAAS0F,EAAwB1G,EAA4B,CAClE,GAAI,CAGF,OAFe,IAAI,IAAIA,CAAG,EACL,SAAS,MAAM,eAAe,IACpC,CAAC,GAAK,IACvB,MAAQ,CACN,OAAO,IACT,CACF,CAGA,MAAM2G,EAAe,IACfC,MAAY,IACZC,MAAe,IAErB,eAAsBC,GACpBP,EACA5B,EAC2B,CAC3B,MAAMoC,EAAW,KAAK,UAAUR,CAAM,EAChCS,EAAM,KAAK,IAAA,EAEXC,EAASL,EAAM,IAAIG,CAAQ,EACjC,GAAIE,GAAUD,EAAMC,EAAO,UAAYN,EACrC,OAAOM,EAAO,OAGhB,MAAMC,EAAWL,EAAS,IAAIE,CAAQ,EACtC,GAAIG,EACF,GAAI,CACF,OAAO,MAAMA,CACf,MAAQ,CAER,CAGF,MAAMC,EAAUb,EAAgBC,EAAQ5B,CAAM,EAC3C,KAAMyC,IACLR,EAAM,IAAIG,EAAU,CAAE,UAAW,KAAK,IAAA,EAAO,OAAAK,EAAQ,EAC9CA,EACR,EACA,QAAQ,IAAM,CACbP,EAAS,OAAOE,CAAQ,CAC1B,CAAC,EAEH,OAAAF,EAAS,IAAIE,EAAUI,CAAO,EACvBA,CACT,CC1PO,SAASE,GAAcrH,EAAyC,CACrE,KAAM,CAAE,CAAA,EAAMkC,EAAA,EACR,CAACL,EAAQyF,CAAS,EAAI7G,EAAAA,SAAmB,CAAA,CAAE,EAC3C,CAAC8G,EAAWC,CAAY,EAAI/G,EAAAA,SAAS,EAAK,EAC1C,CAACgH,EAAWC,CAAY,EAAIjH,EAAAA,SAAwB,IAAI,EACxD,CAAC0F,EAAQwB,CAAS,EAAIlH,EAAAA,SAAwB,IAAI,EAElDmH,EAAW9E,EAAAA,OAA+B,IAAI,EAC9C+E,EAAa/E,EAAAA,OAA8B,IAAI,EAC/CgF,EAAkBhF,EAAAA,OAA8B,IAAI,EAE1DlC,OAAAA,EAAAA,UAAU,IAAM,CAoBd,GAlBIgH,EAAS,SACXA,EAAS,QAAQ,MAAA,EAEfC,EAAW,UACb,aAAaA,EAAW,OAAO,EAC/BA,EAAW,QAAU,MAEnBC,EAAgB,UAClB,aAAaA,EAAgB,OAAO,EACpCA,EAAgB,QAAU,MAI5BR,EAAU,CAAA,CAAE,EACZI,EAAa,IAAI,EACjBC,EAAU,IAAI,EAGV,CAAC3H,GAAO,CAACyG,EAAYzG,CAAG,EAAG,CAC7BwH,EAAa,EAAK,EAClB,MACF,CAEA,MAAM/C,EAAYiC,EAAwB1G,CAAG,EAC7C,GAAI,CAACyE,EAAW,CACdiD,EAAa,kBAAkB,EAC/BF,EAAa,EAAK,EAClB,MACF,CAEA,MAAMjB,EAA2B,CAC/B,UAAA9B,EACA,UAAW,GAAA,EAGb+C,EAAa,EAAI,EACjB,MAAMO,EAAa,IAAI,gBACvBH,EAAS,QAAUG,EAEnB,MAAMC,EAAmB,MAAOC,EAAa,IAAM,CACjD,GAAI,CACF,MAAMb,EAAS,MAAMN,GAAoBP,EAAQwB,EAAW,MAAM,EAElE,GAAIA,EAAW,OAAO,QAAS,OAE/BT,EAAUF,EAAO,MAAM,EACvBO,EAAUP,EAAO,MAAM,EACvBM,EAAa,IAAI,EACjBF,EAAa,EAAK,CACpB,MAAQ,CACN,GAAIO,EAAW,OAAO,QAAS,OAI/B,GAAIE,EADe,EACU,CAC3B,MAAMC,EAAa,KAAK,IAAI,EAAGD,CAAU,EAAI,IAE7CH,EAAgB,QAAU,WAAW,IAAM,CACpCC,EAAW,OAAO,SACrBC,EAAiBC,EAAa,CAAC,CAEnC,EAAGC,CAAU,EACb,MACF,CAGAR,EAAa,eAAe,EAC5BJ,EAAU,CAAA,CAAE,EACZK,EAAU,IAAI,EACdH,EAAa,EAAK,CACpB,CACF,EAGA,OAAAK,EAAW,QAAU,WAAWG,EAAkB,GAAG,EAE9C,IAAM,CACXD,EAAW,MAAA,EACPF,EAAW,UACb,aAAaA,EAAW,OAAO,EAC/BA,EAAW,QAAU,MAEnBC,EAAgB,UAClB,aAAaA,EAAgB,OAAO,EACpCA,EAAgB,QAAU,KAE9B,CACF,EAAG,CAAC9H,CAAG,CAAC,EAGRY,EAAAA,UAAU,IACD,IAAM,CACPgH,EAAS,SACXA,EAAS,QAAQ,MAAA,EAEfC,EAAW,UACb,aAAaA,EAAW,OAAO,EAC/BA,EAAW,QAAU,MAEnBC,EAAgB,UAClB,aAAaA,EAAgB,OAAO,EACpCA,EAAgB,QAAU,KAE9B,EACC,CAAA,CAAE,EAEE,CACL,OAAAjG,EACA,UAAA0F,EACA,MAAOE,EAAY,EAAEA,CAAS,EAAI,KAClC,OAAAtB,CAAA,CAEJ,CCpIA,SAAwBgC,GAAgB,CAAE,IAAAnI,GAA6B,CACrE,KAAM,CAAE,CAAA,EAAMkC,EAAA,EACRkG,EAAQC,EAAA,EACR,CAAE,OAAAxG,EAAQ,UAAA0F,EAAW,MAAAlC,CAAA,EAAUgC,GAAcrH,CAAG,EAEtD,OAAIuH,EAEA7F,EAAAA,KAAC,MAAA,CAAI,UAAU,wCAAwC,cAAW,GAEhE,SAAA,CAAAD,EAAAA,IAAC,MAAA,CAAI,UAAU,0BAAA,CAA2B,QACzC,MAAA,CAAI,UAAU,kBAAmB,SAAA,EAAE,qBAAqB,CAAA,CAAE,CAAA,EAC7D,EAIA4D,EAEA3D,EAAAA,KAAC,MAAA,CAAI,UAAU,sCAAsC,cAAW,GAE9D,SAAA,CAAAD,EAAAA,IAAC,MAAA,CAAI,UAAU,0BAAA,CAA2B,EAC1CC,EAAAA,KAAC,MAAA,CACC,UAAU,gBACV,MAAO,CACL,SAAU,WACV,OAAQ,OACR,MAAO,OACP,WAAY4G,EAAMF,EAAM,QAAQ,WAAW,MAAO,EAAG,EACrD,MAAOA,EAAM,QAAQ,KAAK,QAC1B,QAAS,YACT,aAAc,MACd,SAAU,OACV,SAAU,QACV,OAAQ,GAAA,EAGV,SAAA,CAAA3G,EAAAA,IAAC,SAAA,CAAQ,SAAA,EAAE,sBAAsB,CAAA,CAAE,QAClC,KAAA,EAAG,EACH,EAAE,eAAe,CAAA,CAAA,CAAA,CACpB,EACF,EAIAI,EAAO,SAAW,EAElBJ,EAAAA,IAAC,MAAA,CAAI,UAAU,sCAAsC,cAAW,GAC9D,SAAAA,EAAAA,IAAC,MAAA,CAAI,UAAU,0BAAA,CAA2B,CAAA,CAC5C,EAIGA,MAACG,GAAe,OAAAC,EAAgB,CACzC,CChDA,SAAwB0G,GAAe,CAAE,IAAAvI,EAAM,KAAM,QAAAwI,EAAU,MAA6B,CAE1F,MAAMC,EAAgBzI,GAAO,oCAAoC,KAAKA,CAAG,EAGnE0I,EAAW1I,EAAMyG,EAAYzG,CAAG,EAAI,GAGpC2I,EACJ3I,IAAQ,SAAWA,IAAQ,QAAUA,GAAK,SAAS,QAAQ,GAAKA,GAAK,SAAS,OAAO,EACjF4I,EAAsB5I,GAAO,CAAC2I,IAAyBH,GAAY,CAACA,GAAWxI,GAG/E6I,EAA4B,CAACL,GAAWE,GAAY1I,EAE1D,OACE0B,EAAAA,KAACoH,EAAA,CACC,UAAW/E,EAAK,iBAAkB,CAAC6E,GAAuB,oBAAoB,EAC9E,KAAK,eACL,GAAI,CACF,gBACE,CAACJ,GAAWxI,GAAO,CAAC2I,GAAwB,CAACD,EAAW,OAAO1I,CAAG,IAAM,MAAA,EAG3E,SAAA,CAAAwI,GACC,CAACE,IAEAD,EACChH,EAAAA,IAACnB,EAAA,CAAmB,IAAAN,CAAA,CAAU,EAE9ByB,EAAAA,IAAC,SAAA,CACC,IAAKzB,GAAO,OACZ,MAAM,QACN,MAAM,OACN,OAAO,OACP,MAAM,4DACN,QAAQ,qDACR,MAAO,CAAE,OAAQ,MAAA,CAAO,CAAA,GAK7B6I,EAA4BpH,EAAAA,IAAC0G,GAAA,CAAgB,IAAAnI,CAAA,CAAU,EAAK,IAAA,CAAA,CAAA,CAGnE,CCvDA,SAAS+I,GAAM/I,EAAqB,CAClC,MAAMgJ,EAAa,oBACbC,EAAQjJ,EAAI,MAAMgJ,CAAU,EAGlC,MAAO,kCAFSC,EAAQA,EAAM,CAAC,EAAI,EAEa,mCAClD,CAEA,SAASC,GAAQlJ,EAAqB,CACpC,MAAMmJ,EACJ,gHACIF,EAAQjJ,EAAI,MAAMmJ,CAAY,EAGpC,MAAO,iCAFSF,EAAQA,EAAM,CAAC,EAAI,EAEY,4HACjD,CAEA,SAASG,GAAYpJ,EAAqB,CACxC,MAAMqJ,EAAa,uCACbJ,EAAQjJ,EAAI,MAAMqJ,CAAU,EAGlC,MAAO,mCAFQJ,EAAQA,EAAM,CAAC,EAAI,EAEc,iBAClD,CAEA,SAASK,GAAQtJ,EAAqB,CACpC,MAAMuJ,EAAe,2BACfN,EAAQjJ,EAAI,MAAMuJ,CAAY,EAGpC,MAAO,6BAFQN,EAAQA,EAAM,CAAC,EAAI,EAEQ,QAC5C,CAEA,SAASO,GAAQxJ,EAAqB,CAIpC,MAAO,6BAHQ,IAAI,IAAIA,CAAG,EACH,aAAa,IAAI,SAAS,GAAK,EAEX,iDAC7C,CAEA,SAASyJ,GAASzJ,EAAqB,CACrC,MAAM0J,EAAW1J,EAAI,MAAM,GAAG,EAG9B,MAAO,yCAFK0J,EAASA,EAAS,OAAS,CAAC,CAEW,iDACrD,CAEA,SAASC,GAAM3J,EAAgD,CAE7D,MAAM4J,EACJ,4EACIC,EAAc7J,EAAI,MAAM4J,CAAgB,EAE9C,GAAIC,EAAa,CACf,MAAMC,EAAYD,EAAY,CAAC,EAAE,YAAA,EAEjC,MAAO,CACL,IAAA7J,EACA,QAAS,CAAC,MAAO,MAAM,EAAE,SAAS8J,CAAS,CAAA,CAE/C,CAGA,MAAMC,EAAY,gCACZC,EAAYhK,EAAI,MAAM+J,CAAS,EAErC,OAAIC,EAGK,CACL,IAAK,2BAHWA,EAAU,CAAC,CAGc,GACzC,QAAS,EAAA,EAKN,CACL,IAAAhK,EACA,QAAS,EAAA,CAEb,CAEA,SAASiK,GAAMjK,EAAqB,CAClC,MAAMkK,EAAa,yCACbjB,EAAQjJ,EAAI,MAAMkK,CAAU,EAKlC,MAAO,iCAJOjB,EAAQA,EAAM,CAAC,EAAI,EAIY,YAC/C,CAEA,SAASkB,GAAOnK,EAAqB,CAInC,MADyB,uDACJ,KAAKA,CAAG,EACpBA,CAMX,CAEA,SAASoK,GAAOpK,EAAqB,CAEnC,MAAMqK,EAAc,2DACdpB,EAAQjJ,EAAI,MAAMqK,CAAW,EAC7BC,EAAQrB,EAAQA,EAAM,CAAC,EAAI,GAGjC,OAAIsB,EAAYvK,EAAK,CAAC,aAAa,CAAC,EAE3B,6BAA6BsK,CAAK,OAGpC,4BAA4BA,CAAK,MAC1C,CAEA,SAASE,GAAQxK,EAAqB,CACpC,MAAMyK,EAAe,sBACfxB,EAAQjJ,EAAI,MAAMyK,CAAY,EAEpC,MAAO,iCADSxB,EAAQA,EAAM,CAAC,EAAI,EACY,qDACjD,CAEA,SAASyB,GAAQ1K,EAAqB,CACpC,MAAM2K,EAAe,6BACf1B,EAAQjJ,EAAI,MAAM2K,CAAY,EAGpC,MAAO,iCAFS1B,EAAQA,EAAM,CAAC,EAAI,EAEY,2BACjD,CAEA,SAAS2B,GAAM5K,EAAqB,CAClC,MAAM6K,EAAa,kCACb5B,EAAQjJ,EAAI,MAAM6K,CAAU,EAGlC,MAAO,+BAFS5B,EAAQA,EAAM,CAAC,EAAI,EAEU,2BAC/C,CAEA,SAAS6B,GAAQ9K,EAAqB,CAGpC,MAAO,kCAAkC,mBAAmBA,CAAG,CAAC,EAClE,CAcA,SAAS+K,GAAM/K,EAAqB,CAElC,GAAI,CACF,MAAMgB,EAAS,IAAI,IAAIhB,CAAG,EAG1B,IACGgB,EAAO,OAAS,kBAAoBA,EAAO,KAAK,SAAS,iBAAiB,IAC3EA,EAAO,SAAS,WAAW,YAAY,IACtCA,EAAO,SAAS,SAAS,qBAAqB,GAC7CA,EAAO,SAAS,SAAS,mBAAmB,GAE9C,OAAOhB,CAEX,OAASqF,EAAO,CAEd2F,EAAO,MAAM,8CAA+C3F,CAAK,CACnE,CAGA,GAAI,CACF,MAAMrE,EAAS,IAAI,IAAIhB,CAAG,EAC1B,GAAIgB,EAAO,OAAS,gBAEdA,EAAO,QAAUA,EAAO,SAAS,MAAM,iBAAiB,GAC1D,OAAOhB,CAIb,OAASqF,EAAO,CACd2F,EAAO,MAAM,4CAA6C3F,CAAK,CACjE,CAGA,IAAIpE,EAAU,GAGVF,EAAU,GACd,GAAI,CACF,MAAMC,EAAS,IAAI,IAAIhB,CAAG,EAC1Be,EAAUC,EAAO,OAAS,aAAeA,EAAO,OAAS,aAC3D,OAASqE,EAAO,CAEd,OAAA2F,EAAO,MAAM,2CAA4C3F,CAAK,EACvD,EACT,CAEA,GAAI,CAACtE,EAEH,MAAO,GAMT,GAAIf,EAAI,SAAS,WAAW,EAAG,CAC7B,MAAMiL,EAAejL,EAAI,MAAM,2CAA2C,EAC1E,GAAIiL,EAEFhK,EAAUgK,EAAa,CAAC,MACnB,CAIL,MAAMC,EAAYlL,EAAI,MAAM,wCAAwC,EACpE,GAAIkL,EAEFjK,EAAUiK,EAAU,CAAC,MAGrB,QAAAF,EAAO,MAAM,mEAAoEhL,CAAG,EAC7EA,CAEX,CACF,KAAO,CAEL,MAAMmL,EACJ,yQACIlC,EAAQjJ,EAAI,MAAMmL,CAAU,EAClClK,EAAUgI,EAAQA,EAAM,CAAC,GAAKA,EAAM,CAAC,EAAI,EAC3C,CAEA,GAAI,CAAChI,EACH,MAAO,GAIT,MAAMmK,EAAiBpL,EAAI,MAAM,4BAA4B,EAC7D,IAAI8J,EAAY,MAEhB,GAAIsB,GAAkBA,EAAe,CAAC,EAAG,CAEvC,IAAIC,EAAoBD,EAAe,CAAC,EAAE,YAAA,EAG1C,MAAME,EAA0C,CAC9C,KAAM,KAAA,EAGJA,EAAaD,CAAiB,IAChCA,EAAoBC,EAAaD,CAAiB,GAKlD,CACE,MACA,OACA,MACA,MACA,OACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,OACA,KAAA,EACA,SAASA,CAAiB,IAE5BvB,EAAYuB,EAEhB,CAKA,MAHiB,uBAAuBpK,CAAO,IAAI6I,CAAS,EAI9D,CAEA,SAASyB,EAAiBvL,EAAsB,CAC9C,MAAO,+BAA+B,KAAKA,CAAG,CAChD,CAEA,SAASwL,GAAkBxL,EAAsB,CAC/C,OAAOuK,EAAYvK,EAAK,CAAC,uBAAwB,oBAAoB,CAAC,GAAK,CAACuL,EAAiBvL,CAAG,CAClG,CAEA,SAASuK,EAAYvK,EAAayL,EAAiC,CACjE,GAAI,CACF,MAAMzK,EAAS,IAAI,IAAIhB,CAAG,EAC1B,OAAOyL,EAAa,KAAMC,GAAS1K,EAAO,OAAS0K,GAAQ1K,EAAO,KAAK,SAAS,IAAM0K,CAAI,CAAC,CAC7F,OAASrG,EAAO,CAEd,OAAA2F,EAAO,MAAM,6DAA8D3F,CAAK,EACzE,EACT,CACF,CAOO,SAASsG,GAAkB3L,EAAkD,CAClF,IAAI4L,EAA0B,KAC1BpD,EAAU,GAEd,GAAI,CAACxI,EACH,MAAO,CAAE,IAAK,GAAI,QAAS,EAAA,EAG7B,OAAQ,GAAA,CACN,KAAKuK,EAAYvK,EAAK,CAAC,WAAW,CAAC,EACjC4L,EAAW7C,GAAM/I,CAAG,EACpB,MACF,KAAKuK,EAAYvK,EAAK,CAAC,cAAe,UAAU,CAAC,EAC/C4L,EAAW1C,GAAQlJ,CAAG,EACtB,MACF,KAAKuK,EAAYvK,EAAK,CAAC,kBAAkB,CAAC,EACxC4L,EAAWxC,GAAYpJ,CAAG,EAC1B,MACF,KAAKuK,EAAYvK,EAAK,CAAC,aAAa,CAAC,EACnC4L,EAAWpC,GAAQxJ,CAAG,EACtB,MACF,KAAKuK,EAAYvK,EAAK,CAAC,cAAc,CAAC,EACpC4L,EAAWnC,GAASzJ,CAAG,EACvB,MACF,KAAKuK,EAAYvK,EAAK,CAAC,aAAa,CAAC,EACnC4L,EAAWtC,GAAQtJ,CAAG,EACtB,MACF,KAAKuK,EAAYvK,EAAK,CAAC,YAAa,aAAa,CAAC,EAChD4L,EAAWb,GAAM/K,CAAG,EACpB,MACF,KAAKuK,EAAYvK,EAAK,CAAC,WAAW,CAAC,EAAG,CACpC,MAAM6L,EAAclC,GAAM3J,CAAG,EAC7B4L,EAAWC,EAAY,IACvBrD,EAAUqD,EAAY,QACtB,KACF,CACA,KAAKtB,EAAYvK,EAAK,CAAC,WAAW,CAAC,EACjC4L,EAAW3B,GAAMjK,CAAG,EACpBwI,EAAU,GACV,MACF,KAAK+B,EAAYvK,EAAK,CAAC,aAAc,kBAAkB,CAAC,GACtD,0BAA0B,KAAKA,CAAG,GAClC4L,EAAWzB,GAAOnK,CAAG,EACrBwI,EAAUoD,EAAWL,EAAiBK,CAAQ,EAAI,GAClD,MACF,KAAKrB,EAAYvK,EAAK,CAAC,aAAc,aAAa,CAAC,EACjD4L,EAAWxB,GAAOpK,CAAG,EACrBwI,EAAU,GACV,MACF,KAAK+B,EAAYvK,EAAK,CAAC,aAAa,CAAC,EACnC4L,EAAWpB,GAAQxK,CAAG,EACtB,MACF,KAAKuK,EAAYvK,EAAK,CAAC,aAAa,CAAC,EACnC4L,EAAWlB,GAAQ1K,CAAG,EACtB,MACF,KAAKuK,EAAYvK,EAAK,CAAC,WAAW,CAAC,EACjC4L,EAAWhB,GAAM5K,CAAG,EACpB,MACF,KAAKuK,EAAYvK,EAAK,CAAC,cAAe,OAAO,CAAC,EAC5C4L,EAAWd,GAAQ9K,CAAG,EACtBwI,EAAU,GACV,MACF,KAAK+B,EAAYvK,EAAK,CAAC,aAAa,CAAC,EACnC4L,EAAmB5L,EACnB,MACF,KAAKuK,EAAYvK,EAAK,CAAC,iBAAiB,CAAC,EACvC4L,EAAuB5L,EACvB,MACF,KAAKwL,GAAkBxL,CAAG,EACxB4L,EAAW5L,EACXwI,EAAU,GACV,MACF,KAAK+C,EAAiBvL,CAAG,EACvB4L,EAAW5L,EACX,MACF,QACE4L,EAAWE,EAAW9L,CAAG,EACzBwI,EAAU,GACV,KAAA,CAEJ,MAAO,CACL,IAAKoD,EACL,QAAApD,CAAA,CAEJ,CASA,SAAwBuD,GACtBC,EACAC,EACkB,CAClB,KAAM,CAAE,WAAAC,EAAY,cAAAC,EAAe,kBAAAC,CAAA,EAAsBJ,EASzD,IAAIK,EAAiC,KA8BrC,OA3BIH,EACEA,IAAe,SAEjBG,EAAkBF,GAAiB,KAC1BD,IAAe,oBAEpB,CAACI,EAAaL,CAAI,GAAKG,EAEzBC,EAAkBD,EAGlBC,EAAkB,QAIpBA,EAAkBH,EAIpBG,EAAkB,QAGfA,IACHA,EAAkB,SAIhBA,IAAoB,SAAWA,IAAoB,OACtC,CAAE,IAAKA,EAAiB,QAAS,EAAA,EAInCV,GAAkBU,CAAe,CAGlD,CCzcA,SAASE,GAA4BC,EAAoC,CACvE,MAAO,CACL,IAAKA,EAAa,IAClB,YAAaA,EAAa,YAC1B,OAAQA,EAAa,OACrB,WAAYA,EAAa,UAAA,CAE7B,CAEA,SAAwBC,GAAiBC,EAAkC,CACzE,KAAM,CAACC,EAAeC,CAAgB,EAAInM,EAAAA,SAAwB,IAAI,EAChEoM,EAAgBC,EAAA,EAGhBC,EAAcC,EAAAA,QAAQ,IACnBH,EACJ,IAAKI,GAAM,GAAGA,EAAE,GAAG,IAAIA,EAAE,WAAW,IAAIA,EAAE,UAAU,IAAIA,EAAE,MAAM,EAAE,EAClE,KAAK,GAAG,EACV,CAACJ,CAAa,CAAC,EAGZK,EAAcF,EAAAA,QAAQ,IACnBN,EAAU,GAAGA,EAAQ,GAAG,IAAIA,EAAQ,aAAe,EAAE,GAAK,KAChE,CAACA,CAAO,CAAC,EAEZ9L,OAAAA,EAAAA,UAAU,IAAM,CACd,GAAI,CAAC8L,EAAS,CACZE,EAAiB,IAAI,EACrB,MACF,CAGA,GAAIC,EAAc,QAAU,EAAG,CAC7BD,EAAiB,IAAI,EACrB,MACF,CAGA,MAAMO,EAAeN,EAAc,OAAQO,GAAW,CAACA,EAAO,UAAU,EAExE,GAAID,EAAa,QAAU,EAAG,CAC5BP,EAAiB,IAAI,EACrB,MACF,CAIA,IAAIS,EAAqB,GAGzBA,EAAqBF,EAAa,UAAWC,GAAWA,EAAO,MAAQV,EAAQ,GAAG,EAG9EW,IAAuB,KACzBA,EAAqBF,EAAa,UAC/BC,GAAWA,EAAO,cAAgBV,EAAQ,WAAA,GAK3CW,IAAuB,KACzBA,EAAqB,GAIvB,MAAM/L,GAAa+L,EAAqB,GAAKF,EAAa,OACpDG,EAAmBH,EAAa7L,CAAS,EAGzCiM,EAAahB,GAA4Be,CAAgB,EAC/DV,EAAiBW,CAAU,CAE7B,EAAG,CAACL,EAAaH,CAAW,CAAC,EAEtBJ,CACT"}