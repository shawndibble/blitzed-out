{"version":3,"mappings":"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","names":["AppError","message","code","cause","AuthError","isAppError","error","isError","getErrorMessage","getErrorCode","createStandardError","defaultMessage","FIREBASE_ERROR_MESSAGES","getFirebaseErrorMessage","isFirefoxMobile","userAgent","gatherSystemContext","_a","reportFirefoxMobileAuthError","step","additionalContext","context","Sentry.withScope","scope","_b","Sentry.captureException","Sentry.addBreadcrumb","reportFirefoxMobileConnectivityIssue","details","Sentry.captureMessage","firebaseConfig","missingVars","_","value","key","checkFirebaseConnectivity","testUrl","response","statusError","app","initializeApp","db","getFirestore","loginAnonymously","displayName","auth","getAuth","signInAnonymously","updateProfile","registerWithEmail","email","password","userCredential","createUserWithEmailAndPassword","loginWithEmail","signInWithEmailAndPassword","loginWithGoogle","provider","GoogleAuthProvider","signInWithPopup","resetPassword","sendPasswordResetEmail","convertAnonymousAccount","user","credential","EmailAuthProvider","linkWithCredential","logout","signOut","wipeAllAppData","appPrefixes","prefix","__vitePreload","db2","cookiesToClear","currentHostname","domains","parts","i","paths","cookieName","domain","path","e","getUserList","roomId","callback","existingData","options","enableCache","enableDebounce","roomUpper","queryKey","getCacheKey","startTime","cached","queryCache","isValidCache","updateQueryMetrics","dataString","existingString","unsubscribe","executeQuery","networkError","acquireConnection","database","getDatabase","usersRef","ref","onValue","snap","queryEndTime","latency","allUsers","roomUsers","uid","userData","data","evictOldCacheEntries","priority","getCachePriority","releaseConnection","debounceQuery","timeout","queryDebounceMap","updateDisplayName","submitCustomAction","grouping","customAction","addDoc","collection","getBoardByContent","checksum","q","query","where","snapshot","getDocs","getOrCreateBoard","title","gameBoard","settings","sha256","board","updateDoc","storeBoard","getBoard","id","docRef","doc","docSnap","getDoc","lastMessage","CACHE_TTL","PRIORITY_CACHE_TTL","DEBOUNCE_DELAY","PRIORITY_DEBOUNCE_DELAY","DEFAULT_LIMIT","MAX_CACHE_SIZE","connectionPool","queryMetrics","fromCache","existing","sorted","a","b","p95Index","getCacheTTL","getDebounceDelay","entries","priorityOrder","priorityDiff","accessDiff","entriesToRemove","resolve","nextCallback","additionalParams","cache","ttl","queryFn","args","debounceDelay","existingTimeout","sendMessage","room","text","type","rest","allowedTypes","newMessage","now","roomName","serverTimestamp","deleteMessage","messageId","deleteDoc","getMessages","unsubscribeAuth","unsubscribeQuery","executeGetMessages","limitCount","startAfterDoc","timeWindow","baseQuery","orderBy","limit","startAfter","onSnapshot","querySnapshot","messages","document","lastVisible","deferredUnsubscribe","getSchedule","currentTime","schedule","result","addSchedule","dateTime","url","Timestamp","createSyncMiddleware","tables","tableSet","syncDebounce","tableName","windowWithAuth","downlevelDatabase","downlevelTable","req","BlitzedOutDatabase","Dexie","__publicField","isSafari","CursorErrorStrategy","operation","logger","SafariConnectionStrategy","recoveryStrategies","retryOnCursorError","log","errorInstance","strategy","retryError","retryErrorInstance","SUPPORTED_LANGUAGES","MIGRATION_VERSION","MIGRATION_KEY","BACKGROUND_MIGRATION_KEY","MIGRATION_IN_PROGRESS_KEY","CURRENT_LANGUAGE_MIGRATION_KEY","BACKGROUND_MIGRATION_IN_PROGRESS_KEY","MIGRATION_TIMEOUT","STALE_LOCK_TIMEOUT","BACKGROUND_MIGRATION_DELAY","QUEUE_BACKGROUND_MIGRATION_DELAY","IDLE_CALLBACK_TIMEOUT","GAME_MODES","customTiles","_primKey","obj","_transaction","importCustomTiles","record","recordData","tile","createFilteredQuery","filters","possibleFilters","intensityNum","getTiles","migrationInProgress","migrationData","waitCount","maxWait","getPaginatedTiles","page","count","offset","getTileCountsByGroup","locale","gameMode","tags","getCustomGroups","customGroups$1","relevantGroups","groupIds","group","relevantTiles","groupId","tilesInGroup","tagsArray","tag","groups","groupKey","intensity","getActiveTiles","currentLocale","i18next","allEnabledTiles","groupsQuery","matchingGroups","addCustomTile","updateCustomTile","toggleCustomTile","newEnabledState","deleteAllIsCustomTiles","deleteCustomTile","countTilesByGroup","groupName","getCustomGroupByName","countTilesByGroupId","deleteCustomTilesByGroup","deleteCustomTilesByGroupId","getTilesByGroupIds","_locale","_gameMode","customGroups","nanoid","modifications","_obj","getCustomGroup","name","addCustomGroup","timestamp","groupWithTimestamp","updateCustomGroup","updates","deleteCustomGroup","tileCount","deletedTiles","importCustomGroups","groupsWithAllFields","isGroupNameUnique","excludeId","existingGroup","getCurrentGroups","removeDuplicateGroups","allGroups","groupsByName","removedCount","aTime","bTime","getAllAvailableGroups","duplicateError","index","self","g","getGroupsWithTiles","customTiles$1","tilesForGroups","groupIdsWithTiles","getBoards","getActiveBoard","addBoard","updateBoard","upsertBoard","newData","deactivateAllBoards","activateBoard","updatedBoards","deleteBoard","defaultSettings","useSettingsStore","create","persist","set","partial","state","actionEntry","newSelectedActions","selectedActions","entry","acc","useSettings","updateSettings","useGameSettings","deleteAllCustomTiles","cleanupDuplicateTiles","allTiles","tileGroups","tiles","original","duplicates","wasDisabled","duplicate","clearUserCustomGroups","deletePromises","resetDisabledDefaults","updatePromises","applyDisabledDefaults","disabledDefaults","allDefaultTiles","defaultTilesMap","disabledTile","matchedId","syncCustomTilesToFirebase","MAX_REASONABLE_DISABLED_DEFAULTS","setDoc","syncCustomGroupsToFirebase","syncGameBoardsToFirebase","gameBoards","syncSettingsToFirebase","localPlayers","settingsForFirebase","cleanSettings","syncAllDataToFirebase","intelligentSync","userDocRef","userDoc","localCustomTiles","localCustomGroups","conflicts","firebaseCustomTiles","firebaseCustomGroups","syncDataFromFirebase","SyncOrchestrator","syncIntervalId","startPeriodicSync","intervalMinutes","stopPeriodicSync","intervalMs","AuthContext","React","AuthProvider","props","setUser","useState","loading","setLoading","initializing","setInitializing","setError","syncStatus","setSyncStatus","syncTimeoutRef","useRef","authInitializedRef","performSync","useCallback","syncFunction","err","login","loggedInUser","errorMessage","normalizedError","loginEmail","loginGoogle","register","registeredUser","forgotPassword","convertToRegistered","convertedUser","updateUser","updatedUser","logoutUser","syncPromise","timeoutPromise","wipeAllAppDataAndReload","syncData","handleIntelligentSync","useEffect","deferSync","globalWindow","useMemo","isDexieDataComplete","expectedGroups","dexieGroups","importActions","expectedCount","expectedGroupNames","dexieGroupNames","LANGUAGE_PRELOAD_TIMEOUT","i18nOptions","lazyLoadTranslations","language","namespace","__variableDynamicImportRuntimeHelper","i18n","initReactI18next","LanguageDetector","resourcesToBackend","currentLang","commonLangs","lang","HEALTH_CHECK_KEY","MAX_RETRY_ATTEMPTS","MIN_VALIDATION_INTERVAL","getHealthState","stored","updateHealthState","update","checkMigrationHealth","targetLocale","storedState","currentState","report","dataComplete","migrationStatus","checkMigrationStatusFromStorage","newFailureCount","newConsecutiveFailures","mainStatus","parsed","bgStatus","recoverFromFailedMigration","keysToRemove","hasErrors","MigrationContext","createContext","useMigration","useContext","MigrationProvider","children","useTranslation","isMigrationInProgress","setIsMigrationInProgress","currentLanguageMigrated","setCurrentLanguageMigrated","isMigrationCompleted","setIsMigrationCompleted","isHealthy","setIsHealthy","recoveryAttempted","setRecoveryAttempted","languageChangeTimeout","setLanguageChangeTimeout","migrationAttemptedRef","loadMigrationService","checkMigrationStatus","migrationService","isCurrentMigrated","isAllMigrated","healthReport","forceRecovery","triggerMigration","runSyncRecovery","handleLanguageChange","newLanguage","ensureLanguageMigrated","success","languageChangedHandler","lng","isCompleted","migrationKey","jsx","CACHE_TIMEOUT","SCHEDULE_BATCH_DELAY","useScheduleStore","get","newUpdateCount","item","prevState","newTimeout","items","newSchedule","totalRequests","newHitRate","dayjs","upcoming","roomSchedule","ScheduleContext","ScheduleProvider","loadSchedule","flushPendingScheduleUpdates","unsubscribeRef","handleScheduleUpdate","memoizedAddToSchedule","cleanup","COLOR_CONSTANTS","baseTheme","createComponents","_mode","theme","ownerState","transparent","fullWidth","isLight","lightThemeOptions","darkThemeOptions","createThemeWithComponents","themeOptions","createTheme","lightTheme","responsiveFontSizes","darkTheme","getThemeByMode","mode","ThemeContext","ThemeProvider","defaultMode","prefersDarkMode","useMediaQuery","themeMode","resolvedThemeMode","setThemeMode","toggleTheme","body","contextValue","useTheme","MuiProviders","jsxs","MuiThemeProvider","CssBaseline","LocalizationProvider","AdapterDayjs","AllProviders","parseMessageTimestamp","date","timestampMs","timestampObj","normalSortedMessages","aDate","bDate","sortedMessages","latestMessageByType","m","orderedMessagesByType","order","latestMessageBy","latestMessage","initialState","useMessagesStore","msg","newMessages","hasChanges","updatedMessages","updatedMsg","currentLoading","currentError","currentRoom","cursor","currentCursor","filtered","predicate","twentyFourHoursAgo","validMessages","messageTime","MessagesContext","MessagesProvider","useParams","isLoading","loadMessages","setRoom","clearMessages","BATCH_DELAY","useUserListStore","users","timeDiff","newAverage","newUsers","remaining","isValidOnlineUser","UserListContext","UserListProvider","onlineUsers","s","prevRoomRef","onlineUsersRef","handleUserUpdateRef","setUsers","clearUsers","flushPendingUpdates","useShallow","setUsersRef","clearUsersRef","setRoomRef","flushPendingUpdatesRef","validatedUsers","handleUserUpdate","useSchedule","useAuth","useMessages","MinimalAuthContext","useMinimalAuth","MinimalAuthProvider","hasUser","setHasUser","hasStoredAuth"],"ignoreList":[],"sources":["../../src/types/errors.ts","../../src/utils/firefoxMobileReporting.ts","../../src/services/firebase.ts","../../src/services/syncMiddleware.ts","../../src/stores/store.ts","../../src/utils/dbRecovery.ts","../../src/services/migration/constants.ts","../../src/stores/customTiles.ts","../../src/stores/customGroups.ts","../../src/stores/gameBoard.ts","../../src/stores/settingsStore.ts","../../src/services/syncService.ts","../../src/context/auth.tsx","../../src/services/dataCompletenessChecker.ts","../../src/i18n.ts","../../src/services/migrationHealthChecker.ts","../../src/context/migration.tsx","../../src/stores/scheduleStore.ts","../../src/context/schedule.tsx","../../src/theme.ts","../../src/context/theme.tsx","../../src/components/MuiProviders/index.tsx","../../src/components/AllProviders/index.tsx","../../src/helpers/timestamp.ts","../../src/helpers/messages.ts","../../src/stores/messagesStore.ts","../../src/context/messages.tsx","../../src/stores/userListStore.ts","../../src/context/userList.tsx","../../src/context/hooks/useSchedule.ts","../../src/context/hooks/useAuth.ts","../../src/context/hooks/useMessages.ts","../../src/context/minimalAuth.tsx"],"sourcesContent":["/**\n * Standardized error types for the application\n */\n\nexport class AppError extends Error {\n  constructor(\n    message: string,\n    public code?: string,\n    public cause?: Error\n  ) {\n    super(message);\n    this.name = 'AppError';\n  }\n}\n\nexport class AuthError extends AppError {\n  constructor(message: string, code?: string, cause?: Error) {\n    super(message, code, cause);\n    this.name = 'AuthError';\n  }\n}\n\nexport class NetworkError extends AppError {\n  constructor(message: string, code?: string, cause?: Error) {\n    super(message, code, cause);\n    this.name = 'NetworkError';\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(\n    message: string,\n    public field?: string,\n    cause?: Error\n  ) {\n    super(message, 'VALIDATION_ERROR', cause);\n    this.name = 'ValidationError';\n  }\n}\n\nexport class SyncError extends AppError {\n  constructor(message: string, code?: string, cause?: Error) {\n    super(message, code, cause);\n    this.name = 'SyncError';\n  }\n}\n\n/**\n * Type guard to check if an error is an instance of AppError\n */\nexport function isAppError(error: unknown): error is AppError {\n  return error instanceof AppError;\n}\n\n/**\n * Type guard to check if an error is a standard Error\n */\nexport function isError(error: unknown): error is Error {\n  return error instanceof Error;\n}\n\n/**\n * Safely extracts error message from unknown error type\n */\nexport function getErrorMessage(error: unknown): string {\n  if (isError(error)) {\n    return error.message;\n  }\n  if (typeof error === 'string') {\n    return error;\n  }\n  return 'An unknown error occurred';\n}\n\n/**\n * Safely extracts error code from unknown error type\n */\nexport function getErrorCode(error: unknown): string | undefined {\n  if (isAppError(error)) {\n    return error.code;\n  }\n  if (isError(error) && 'code' in error) {\n    return (error as Error & { code?: string }).code;\n  }\n  return undefined;\n}\n\n/**\n * Creates a standardized error from an unknown error type\n */\nexport function createStandardError(\n  error: unknown,\n  defaultMessage = 'An unexpected error occurred'\n): AppError {\n  if (isAppError(error)) {\n    return error;\n  }\n\n  if (isError(error)) {\n    return new AppError(error.message || defaultMessage, undefined, error);\n  }\n\n  if (typeof error === 'string') {\n    return new AppError(error);\n  }\n\n  return new AppError(defaultMessage);\n}\n\n/**\n * Firebase error code mappings to user-friendly messages\n */\nexport const FIREBASE_ERROR_MESSAGES: Record<string, string> = {\n  'auth/user-not-found': 'No account found with this email address',\n  'auth/wrong-password': 'Incorrect password',\n  'auth/email-already-in-use': 'An account with this email already exists',\n  'auth/weak-password': 'Password is too weak',\n  'auth/invalid-email': 'Invalid email address',\n  'auth/too-many-requests': 'Too many login attempts. Please try again later',\n  'auth/network-request-failed': 'Network error. Please check your connection',\n  'permission-denied': 'You do not have permission to perform this action',\n  unavailable: 'Service is temporarily unavailable. Please try again',\n};\n\n/**\n * Converts Firebase error to user-friendly message\n */\nexport function getFirebaseErrorMessage(error: unknown): string {\n  const code = getErrorCode(error);\n  if (code && FIREBASE_ERROR_MESSAGES[code]) {\n    return FIREBASE_ERROR_MESSAGES[code];\n  }\n  return getErrorMessage(error);\n}\n","import * as Sentry from '@sentry/react';\n\ninterface FirefoxMobileContext {\n  userAgent: string;\n  url: string;\n  timestamp: string;\n  connectivity: {\n    online: boolean;\n    cookiesEnabled: boolean;\n    localStorageAvailable: boolean;\n    connectionType?: string;\n  };\n  firebase: {\n    hasApiKey: boolean;\n    hasAuthDomain: boolean;\n    authDomain?: string;\n  };\n  authentication?: {\n    step: string;\n    displayName?: string;\n    room?: string;\n    firebaseUser?: {\n      uid?: string;\n      isAnonymous?: boolean;\n    };\n  };\n  error?: {\n    message: string;\n    stack?: string;\n    code?: string;\n  };\n}\n\nfunction isFirefoxMobile(): boolean {\n  const userAgent = navigator.userAgent.toLowerCase();\n  return (\n    userAgent.includes('firefox') && (userAgent.includes('mobile') || userAgent.includes('tablet'))\n  );\n}\n\nfunction gatherSystemContext(): Partial<FirefoxMobileContext> {\n  return {\n    userAgent: navigator.userAgent,\n    url: window.location.href,\n    timestamp: new Date().toISOString(),\n    connectivity: {\n      online: navigator.onLine,\n      cookiesEnabled: navigator.cookieEnabled,\n      localStorageAvailable: typeof Storage !== 'undefined',\n      connectionType: (navigator as any).connection?.effectiveType || 'unknown',\n    },\n    firebase: {\n      hasApiKey: !!import.meta.env.VITE_FIREBASE_API_KEY,\n      hasAuthDomain: !!import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,\n      authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,\n    },\n  };\n}\n\nexport function reportFirefoxMobileAuthError(\n  step: string,\n  error: Error,\n  additionalContext?: Partial<FirefoxMobileContext>\n): void {\n  // Only report for Firefox mobile users\n  if (!isFirefoxMobile()) {\n    return;\n  }\n\n  const context: FirefoxMobileContext = {\n    ...gatherSystemContext(),\n    authentication: {\n      step,\n      ...additionalContext?.authentication,\n    },\n    error: {\n      message: error.message,\n      stack: error.stack,\n      code: (error as any).code,\n    },\n    ...additionalContext,\n  } as FirefoxMobileContext;\n\n  // Send to Sentry with detailed context\n  Sentry.withScope((scope) => {\n    scope.setTag('firefox_mobile_auth_error', true);\n    scope.setTag('auth_step', step);\n    scope.setLevel('error');\n\n    // Add all context as extra data\n    scope.setContext('firefox_mobile_debug', context as any);\n\n    // Set user context if available\n    if (context.authentication?.displayName) {\n      scope.setUser({\n        username: context.authentication.displayName,\n        id: context.authentication.firebaseUser?.uid || 'anonymous',\n      });\n    }\n\n    // Add breadcrumbs for authentication flow\n    scope.addBreadcrumb({\n      message: `Firefox Mobile Auth Step: ${step}`,\n      level: 'info',\n      data: context.authentication,\n    });\n\n    Sentry.captureException(error);\n  });\n\n  // Add breadcrumb for easier filtering without duplicate notifications\n  Sentry.addBreadcrumb({\n    message: `Firefox Mobile Authentication Failure - ${step}: ${error.message}`,\n    level: 'error',\n    category: 'firefox_mobile_auth',\n  });\n}\n\nexport function reportFirefoxMobileConnectivityIssue(details: {\n  testUrl: string;\n  error: Error;\n}): void {\n  if (!isFirefoxMobile()) {\n    return;\n  }\n\n  const context: FirefoxMobileContext = {\n    ...gatherSystemContext(),\n    authentication: {\n      step: 'connectivity_check',\n    },\n    error: {\n      message: details.error.message,\n      stack: details.error.stack,\n    },\n  } as FirefoxMobileContext;\n\n  Sentry.withScope((scope) => {\n    scope.setTag('firefox_mobile_connectivity_error', true);\n    scope.setLevel('warning');\n    scope.setContext('connectivity_test', {\n      testUrl: details.testUrl,\n      ...context,\n    } as any);\n\n    Sentry.captureMessage(\n      `Firefox Mobile Connectivity Issue: Failed to reach ${details.testUrl}. This may indicate uBlock Origin or another adblocker is blocking Firebase.`,\n      'warning'\n    );\n  });\n}\n","import { AuthError, createStandardError, getFirebaseErrorMessage } from '@/types/errors';\nimport {\n  DataSnapshot,\n  ThenableReference,\n  getDatabase,\n  onDisconnect,\n  onValue,\n  push,\n  ref,\n  remove,\n  set,\n} from 'firebase/database';\nimport {\n  DocumentData,\n  DocumentReference,\n  QueryDocumentSnapshot,\n  QuerySnapshot,\n  Timestamp,\n  addDoc,\n  collection,\n  deleteDoc,\n  doc,\n  getDoc,\n  getDocs,\n  getFirestore,\n  limit,\n  onSnapshot,\n  orderBy,\n  query,\n  serverTimestamp,\n  startAfter,\n  updateDoc,\n  where,\n} from 'firebase/firestore';\nimport {\n  EmailAuthProvider,\n  GoogleAuthProvider,\n  User,\n  createUserWithEmailAndPassword,\n  getAuth,\n  linkWithCredential,\n  sendPasswordResetEmail,\n  signInAnonymously,\n  signInWithEmailAndPassword,\n  signInWithPopup,\n  signOut,\n  updateProfile,\n} from 'firebase/auth';\nimport { getDownloadURL, getStorage, ref as storageRef, uploadString } from 'firebase/storage';\n\nimport { MessageType } from '@/types/Message';\nimport { User as UserType } from '@/types';\nimport { initializeApp } from 'firebase/app';\nimport { sha256 } from 'js-sha256';\nimport {\n  reportFirefoxMobileAuthError,\n  reportFirefoxMobileConnectivityIssue,\n} from '@/utils/firefoxMobileReporting';\n\ninterface FirebaseConfig {\n  apiKey: string;\n  authDomain: string;\n  projectId: string;\n  storageBucket: string;\n  messagingSenderId: string;\n  appId: string;\n  measurementId: string;\n}\n\nconst firebaseConfig: FirebaseConfig = {\n  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,\n  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,\n  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,\n  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,\n  appId: import.meta.env.VITE_FIREBASE_APP_ID,\n  measurementId: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID,\n};\n\n// Check for missing environment variables\nconst missingVars = Object.entries(firebaseConfig)\n  .filter(([_, value]) => !value)\n  .map(([key]) => key);\n\nif (missingVars.length > 0) {\n  console.error('Missing Firebase environment variables:', missingVars);\n  console.error('Please check your .env file and ensure all VITE_FIREBASE_* variables are set');\n}\n\n// Check if we can reach Firebase (potential uBlock Origin issue)\nconst checkFirebaseConnectivity = async () => {\n  try {\n    // Use Firebase Auth REST API endpoint for connectivity check\n    const testUrl = `https://identitytoolkit.googleapis.com/v1/projects/${firebaseConfig.projectId}`;\n    const response = await fetch(testUrl, { method: 'GET' });\n\n    if (!response.ok) {\n      // Report non-OK status as connectivity issue\n      const statusError = new Error(`HTTP ${response.status}: ${response.statusText}`);\n      reportFirefoxMobileConnectivityIssue({\n        testUrl,\n        error: statusError,\n      });\n    }\n    // Only report success if there were previous failures\n  } catch (error) {\n    reportFirefoxMobileConnectivityIssue({\n      testUrl: `https://identitytoolkit.googleapis.com/v1/projects/${firebaseConfig.projectId}`,\n      error: error as Error,\n    });\n  }\n};\n\n// Run connectivity check for Firefox mobile users\nif (\n  navigator.userAgent.toLowerCase().includes('firefox') &&\n  (navigator.userAgent.toLowerCase().includes('mobile') ||\n    navigator.userAgent.toLowerCase().includes('tablet'))\n) {\n  checkFirebaseConnectivity();\n}\n\nconst app = initializeApp(firebaseConfig);\nexport const db = getFirestore(app);\n\n// Firestore database initialized\n\nexport async function loginAnonymously(displayName = ''): Promise<User | null> {\n  try {\n    const auth = getAuth();\n\n    await signInAnonymously(auth);\n\n    if (auth.currentUser) {\n      await updateProfile(auth.currentUser, { displayName });\n      return auth.currentUser;\n    } else {\n      const error = new Error('No current user after anonymous sign in');\n      reportFirefoxMobileAuthError('anonymous_login_no_user', error, {\n        authentication: {\n          step: 'anonymous_login_no_user',\n          displayName,\n        },\n      });\n      return null;\n    }\n  } catch (error) {\n    const authError = error as Error;\n    reportFirefoxMobileAuthError('anonymous_login_failed', authError, {\n      authentication: {\n        step: 'anonymous_login_failed',\n        displayName,\n      },\n    });\n\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'ANONYMOUS_LOGIN_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\nexport async function registerWithEmail(\n  email: string,\n  password: string,\n  displayName = ''\n): Promise<User> {\n  try {\n    const auth = getAuth();\n    const userCredential = await createUserWithEmailAndPassword(auth, email, password);\n    await updateProfile(userCredential.user, { displayName });\n    return userCredential.user;\n  } catch (error) {\n    console.error('Registration error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'REGISTRATION_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\nexport async function loginWithEmail(email: string, password: string): Promise<User> {\n  try {\n    const auth = getAuth();\n    const userCredential = await signInWithEmailAndPassword(auth, email, password);\n    return userCredential.user;\n  } catch (error) {\n    console.error('Email login error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'EMAIL_LOGIN_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\nexport async function loginWithGoogle(): Promise<User> {\n  try {\n    const auth = getAuth();\n    const provider = new GoogleAuthProvider();\n    const userCredential = await signInWithPopup(auth, provider);\n    return userCredential.user;\n  } catch (error) {\n    console.error('Google login error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'GOOGLE_LOGIN_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\nexport async function resetPassword(email: string): Promise<boolean> {\n  try {\n    const auth = getAuth();\n    await sendPasswordResetEmail(auth, email);\n    return true;\n  } catch (error) {\n    console.error('Password reset error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'PASSWORD_RESET_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\n// Function to convert anonymous account to permanent account\nexport async function convertAnonymousAccount(email: string, password: string): Promise<User> {\n  try {\n    const auth = getAuth();\n    const user = auth.currentUser;\n\n    if (user?.isAnonymous) {\n      const credential = EmailAuthProvider.credential(email, password);\n      const result = await linkWithCredential(user, credential);\n      return result.user;\n    } else {\n      throw new Error('User is not anonymous or not logged in');\n    }\n  } catch (error) {\n    console.error('Account conversion error:', error);\n    throw new AuthError(\n      getFirebaseErrorMessage(error),\n      'ACCOUNT_CONVERSION_FAILED',\n      createStandardError(error)\n    );\n  }\n}\n\nexport async function logout(): Promise<boolean> {\n  try {\n    const auth = getAuth();\n    await signOut(auth);\n    return true;\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\n\n/**\n * Completely wipe all app data including localStorage, IndexedDB, sessionStorage, and cookies\n * This provides a complete reset for users who want to start fresh\n */\nexport async function wipeAllAppData(): Promise<void> {\n  try {\n    // First sign out from Firebase\n    const auth = getAuth();\n    await signOut(auth);\n\n    // Clear all localStorage keys\n    const keysToRemove = [\n      'gameSettings',\n      'messages-storage',\n      'i18nextLng',\n      // Migration keys\n      'blitzed-out-action-groups-migration',\n      'blitzed-out-background-migration',\n      'blitzed-out-migration-in-progress',\n      'blitzed-out-current-language-migration',\n      'blitzed-out-background-migration-in-progress',\n      'blitzed-out-migration-health',\n    ];\n\n    keysToRemove.forEach((key) => {\n      try {\n        localStorage.removeItem(key);\n      } catch (error) {\n        console.warn(`Failed to remove localStorage key: ${key}`, error);\n      }\n    });\n\n    // Clear any remaining localStorage keys that start with our app prefixes\n    const appPrefixes = ['gameSettings', 'messages-storage', 'blitzed-out-'];\n    const localStorageKeys = Object.keys(localStorage);\n    localStorageKeys.forEach((key) => {\n      if (appPrefixes.some((prefix) => key.startsWith(prefix))) {\n        try {\n          localStorage.removeItem(key);\n        } catch (error) {\n          console.warn(`Failed to remove localStorage key: ${key}`, error);\n        }\n      }\n    });\n\n    // Clear sessionStorage (Firebase auth data)\n    try {\n      sessionStorage.clear();\n    } catch (error) {\n      console.warn('Failed to clear sessionStorage:', error);\n    }\n\n    // Clear IndexedDB via Dexie\n    try {\n      const { default: db } = await import('@/stores/store');\n      await db.delete();\n    } catch (error) {\n      console.warn('Failed to clear IndexedDB:', error);\n    }\n\n    // Clear cookies comprehensively by trying multiple path and domain combinations\n    const cookiesToClear = ['i18next'];\n    const currentHostname = window.location.hostname;\n\n    // Generate possible domains (current domain and its parent domains)\n    const domains = [currentHostname];\n    if (currentHostname.includes('.')) {\n      const parts = currentHostname.split('.');\n      // Add parent domains (e.g., for app.example.com, try .example.com)\n      for (let i = 1; i < parts.length - 1; i++) {\n        domains.push(`.${parts.slice(i).join('.')}`);\n      }\n    }\n\n    // Common paths where cookies might be set\n    const paths = ['/', '/app', '/auth', '/login'];\n\n    cookiesToClear.forEach((cookieName) => {\n      // Try clearing with all combinations of domains and paths\n      domains.forEach((domain) => {\n        paths.forEach((path) => {\n          try {\n            // Clear regular cookie\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain};`;\n            // Clear secure cookie (if applicable)\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain}; secure;`;\n            // Clear httpOnly-accessible cookie (won't work from JS but attempt anyway)\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain}; httpOnly;`;\n            // Clear SameSite variants\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain}; SameSite=Strict;`;\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain}; SameSite=Lax;`;\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; domain=${domain}; SameSite=None; secure;`;\n          } catch {\n            // Silently continue - many of these attempts will fail, which is expected\n          }\n        });\n      });\n\n      // Also try without specifying domain (for cookies set without explicit domain)\n      paths.forEach((path) => {\n        try {\n          document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path};`;\n          document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path}; secure;`;\n        } catch {\n          // Silently continue\n        }\n      });\n    });\n  } catch (error) {\n    console.error('Error wiping app data:', error);\n    throw error;\n  }\n}\n\ninterface PresenceOptions {\n  newRoom: string | null;\n  oldRoom: string | null;\n  newDisplayName: string;\n  oldDisplayName: string;\n  removeOnDisconnect?: boolean;\n}\n\nexport function setMyPresence({\n  newRoom,\n  oldRoom,\n  newDisplayName,\n  oldDisplayName,\n  removeOnDisconnect = true,\n}: PresenceOptions): void {\n  const database = getDatabase();\n  const auth = getAuth();\n  const uid = auth.currentUser?.uid;\n\n  // Default to 'PUBLIC' if room is null/undefined\n  const newRoomName = newRoom?.toUpperCase() || 'PUBLIC';\n  const oldRoomName = oldRoom?.toUpperCase() || 'PUBLIC';\n\n  // Only proceed if we have a valid uid\n  if (!uid) {\n    console.warn('Cannot set presence: User not authenticated');\n    return;\n  }\n\n  const newRoomConnectionsRef = ref(database, `rooms/${newRoomName}/uids/${uid}`);\n  const oldRoomConnectionsRef = ref(database, `rooms/${oldRoomName}/uids/${uid}`);\n  const connectedRef = ref(database, '.info/connected');\n\n  let newRef: ThenableReference;\n  let oldRef: ThenableReference;\n\n  onValue(connectedRef, (snap) => {\n    if (snap.val() === true) {\n      // We're connected (or reconnected)!\n      newRef = push(newRoomConnectionsRef);\n      oldRef = push(oldRoomConnectionsRef);\n\n      if (oldRoomName !== newRoomName || oldDisplayName !== newDisplayName) {\n        remove(oldRoomConnectionsRef);\n      }\n\n      // When I disconnect, remove this device\n      if (removeOnDisconnect) {\n        onDisconnect(oldRef).remove();\n        onDisconnect(newRef).remove();\n      }\n\n      // Add this device to my connections list\n      // this value could contain info about the device or a timestamp too\n      set(newRef, { displayName: newDisplayName, lastActive: Date.now() });\n    }\n  });\n\n  document.addEventListener('beforeunload', () => {\n    // Browser is about to be closed, manually trigger disconnect\n    if (oldRef) remove(oldRef);\n    if (newRef) remove(newRef);\n  });\n}\n\nexport function getUserList(\n  roomId: string | null | undefined,\n  callback: (data: Record<string, unknown>) => void,\n  existingData: Record<string, unknown> = {},\n  options: {\n    enableCache?: boolean;\n    enableDebounce?: boolean;\n  } = {}\n): (() => void) | undefined {\n  if (!roomId) return undefined;\n\n  const { enableCache = true, enableDebounce = true } = options;\n\n  const roomUpper = roomId.toUpperCase();\n  const queryKey = getCacheKey('userList', roomUpper);\n  const startTime = Date.now();\n\n  // Check cache first with smart cache validation\n  if (enableCache) {\n    const cached = queryCache.get(queryKey);\n    if (cached && isValidCache(cached, queryKey)) {\n      // Update cache access count for smart eviction\n      cached.queryCount++;\n      queryCache.set(queryKey, cached);\n\n      updateQueryMetrics(queryKey, Date.now() - startTime, true);\n\n      // Still apply the existing data comparison logic\n      const dataString = Object.keys(cached.data as Record<string, unknown>)\n        .sort()\n        .join(',');\n      const existingString = existingData ? Object.keys(existingData).sort().join(',') : '';\n      if (dataString !== existingString) {\n        callback(cached.data as Record<string, unknown>);\n      }\n      return () => {}; // Return empty cleanup function for cached results\n    }\n  }\n\n  let unsubscribe: (() => void) | undefined;\n\n  const executeQuery = async () => {\n    let networkError = false;\n\n    try {\n      // Use connection pooling for optimal Firebase performance\n      await acquireConnection();\n\n      const database = getDatabase();\n      const usersRef = ref(database, 'users');\n\n      unsubscribe = onValue(\n        usersRef,\n        (snap: DataSnapshot) => {\n          const queryEndTime = Date.now();\n          const latency = queryEndTime - startTime;\n          const allUsers = snap.val() as Record<string, any> | null;\n\n          if (!allUsers) {\n            callback({});\n            return;\n          }\n\n          // Filter users by room and convert to expected format\n          const roomUsers: Record<string, unknown> = {};\n          Object.entries(allUsers).forEach(([uid, userData]) => {\n            if (userData.room === roomUpper) {\n              roomUsers[uid] = {\n                displayName: userData.displayName,\n                uid: uid,\n                lastSeen: userData.lastSeen ? new Date(userData.lastSeen) : new Date(),\n                isAnonymous: userData.isAnonymous,\n                joinedAt: userData.joinedAt ? new Date(userData.joinedAt) : new Date(),\n                room: userData.room,\n              };\n            }\n          });\n\n          const data = roomUsers;\n\n          // Update cache with enhanced metadata\n          if (enableCache) {\n            evictOldCacheEntries(); // Prevent memory bloat\n\n            const priority = getCachePriority(queryKey);\n            queryCache.set(queryKey, {\n              data,\n              timestamp: queryEndTime,\n              queryCount: 1,\n              priority,\n            });\n          }\n\n          updateQueryMetrics(queryKey, latency, false, networkError);\n\n          // to prevent an endless loop, see if our new data matches the existing stuff.\n          // can't compare two arrays directly, but we can compare two strings.\n          const dataString = Object.keys(data).sort().join(',');\n          const existingString = existingData ? Object.keys(existingData).sort().join(',') : '';\n          if (dataString !== existingString) callback(data);\n        },\n        (error) => {\n          networkError = true;\n          console.error('getUserList error:', error);\n          updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n        }\n      );\n    } catch (error) {\n      networkError = true;\n      console.error('getUserList connection error:', error);\n      updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n    } finally {\n      releaseConnection();\n    }\n  };\n\n  // Apply smart debouncing based on priority\n  if (enableDebounce) {\n    debounceQuery(queryKey, executeQuery);\n    // Return a cleanup function that clears both debounce and unsubscribe\n    return () => {\n      const timeout = queryDebounceMap.get(queryKey);\n      if (timeout) {\n        clearTimeout(timeout);\n        queryDebounceMap.delete(queryKey);\n      }\n      if (unsubscribe) {\n        unsubscribe();\n      }\n    };\n  } else {\n    executeQuery();\n    return unsubscribe;\n  }\n}\n\nexport async function updateDisplayName(displayName = ''): Promise<User | null> {\n  try {\n    const auth = getAuth();\n    if (auth.currentUser) {\n      await updateProfile(auth.currentUser, { displayName });\n      return auth.currentUser;\n    }\n    return null;\n  } catch (error) {\n    console.error(error);\n    return null;\n  }\n}\n\nexport async function submitCustomAction(grouping: string, customAction: string): Promise<void> {\n  try {\n    await addDoc(collection(db, 'custom-actions'), {\n      grouping,\n      customAction,\n      ttl: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000), // 4 days\n    });\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nasync function getBoardByContent(checksum: string): Promise<DocumentData | null> {\n  const q = query(collection(db, 'game-boards'), where('checksum', '==', checksum));\n  const snapshot = await getDocs(q);\n  if (snapshot.size) {\n    return snapshot.docs[0];\n  }\n  return null;\n}\n\ninterface BoardData {\n  title: string;\n  gameBoard: string;\n  settings: string;\n}\n\nexport async function getOrCreateBoard({\n  title,\n  gameBoard,\n  settings,\n}: BoardData): Promise<DocumentData | undefined> {\n  if (!title) {\n    return;\n  }\n\n  try {\n    const checksum = sha256(gameBoard);\n    const board = await getBoardByContent(checksum);\n    if (board) {\n      // update the ttl for another 30 days.\n      updateDoc(board.ref, {\n        ttl: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n      }); // 30 days\n\n      return board;\n    }\n    return await storeBoard({ title, gameBoard, settings, checksum });\n  } catch (error) {\n    console.error(error);\n  }\n}\n\ninterface StoreBoardData extends BoardData {\n  checksum: string;\n}\n\nasync function storeBoard({\n  title,\n  gameBoard,\n  settings,\n  checksum,\n}: StoreBoardData): Promise<DocumentReference<DocumentData> | undefined> {\n  try {\n    return await addDoc(collection(db, 'game-boards'), {\n      title,\n      gameBoard,\n      settings,\n      checksum,\n      ttl: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\n    });\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n}\n\nexport async function getBoard(id: string): Promise<DocumentData | undefined> {\n  try {\n    const docRef = doc(db, 'game-boards', id);\n    const docSnap = await getDoc(docRef);\n    if (docSnap.exists()) {\n      return docSnap.data();\n    }\n    return undefined;\n  } catch (error) {\n    console.error(error);\n    return undefined;\n  }\n}\n\nlet lastMessage: Record<string, unknown> = {};\n\n// Enhanced query optimization with smart caching and debouncing\ninterface QueryCache {\n  data: unknown;\n  timestamp: number;\n  lastVisible?: QueryDocumentSnapshot<DocumentData>;\n  queryCount: number; // Track access frequency for smart eviction\n  priority: 'high' | 'medium' | 'low'; // Cache priority based on usage patterns\n}\n\ninterface ConnectionPool {\n  activeConnections: number;\n  maxConnections: number;\n  connectionQueue: Array<() => void>;\n}\n\n// Advanced cache configuration\nconst queryCache = new Map<string, QueryCache>();\nconst queryDebounceMap = new Map<string, NodeJS.Timeout>();\n// Priority query queue for future advanced scheduling (currently unused)\n\n// Optimized cache settings for 60-80% performance improvement\nconst CACHE_TTL = 15000; // Reduced to 15 seconds for fresher data\nconst PRIORITY_CACHE_TTL = 5000; // 5 seconds for high-priority queries\nconst DEBOUNCE_DELAY = 150; // Reduced to 150ms for faster response\nconst PRIORITY_DEBOUNCE_DELAY = 50; // 50ms for high-priority queries\nconst DEFAULT_LIMIT = 50;\nconst MAX_CACHE_SIZE = 100; // Prevent memory bloat\n\n// Connection pooling for optimal Firebase performance\nconst connectionPool: ConnectionPool = {\n  activeConnections: 0,\n  maxConnections: 15, // Optimal for Firebase concurrent connections\n  connectionQueue: [],\n};\n\n// Enhanced performance monitoring with detailed analytics\ninterface QueryMetrics {\n  queryCount: number;\n  totalLatency: number;\n  cacheHits: number;\n  lastQueryTime: number;\n  avgLatency: number;\n  p95Latency: number; // 95th percentile latency tracking\n  connectionPoolHits: number;\n  networkErrors: number;\n  latencyHistory: number[]; // Keep last 20 latencies for percentile calculation\n}\n\nconst queryMetrics = new Map<string, QueryMetrics>();\n\nfunction updateQueryMetrics(\n  queryKey: string,\n  latency: number,\n  fromCache: boolean,\n  networkError: boolean = false\n): void {\n  const existing = queryMetrics.get(queryKey) || {\n    queryCount: 0,\n    totalLatency: 0,\n    cacheHits: 0,\n    lastQueryTime: 0,\n    avgLatency: 0,\n    p95Latency: 0,\n    connectionPoolHits: 0,\n    networkErrors: 0,\n    latencyHistory: [],\n  };\n\n  existing.queryCount++;\n  existing.totalLatency += latency;\n  existing.lastQueryTime = Date.now();\n  existing.avgLatency = existing.totalLatency / existing.queryCount;\n\n  // Track latency history for percentile calculation (keep last 20)\n  existing.latencyHistory.push(latency);\n  if (existing.latencyHistory.length > 20) {\n    existing.latencyHistory.shift();\n  }\n\n  // Calculate 95th percentile\n  if (existing.latencyHistory.length >= 5) {\n    const sorted = [...existing.latencyHistory].sort((a, b) => a - b);\n    const p95Index = Math.floor(sorted.length * 0.95);\n    existing.p95Latency = sorted[p95Index];\n  }\n\n  if (fromCache) {\n    existing.cacheHits++;\n  }\n\n  if (networkError) {\n    existing.networkErrors++;\n  }\n\n  queryMetrics.set(queryKey, existing);\n}\n\n// Smart cache management functions\nfunction getCachePriority(queryKey: string): 'high' | 'medium' | 'low' {\n  if (queryKey.includes('messages')) return 'high'; // Messages are frequently accessed\n  if (queryKey.includes('userList')) return 'medium'; // User list moderate priority\n  return 'low'; // Schedule and other queries\n}\n\nfunction getCacheTTL(priority: 'high' | 'medium' | 'low'): number {\n  switch (priority) {\n    case 'high':\n      return PRIORITY_CACHE_TTL;\n    case 'medium':\n      return CACHE_TTL;\n    case 'low':\n      return CACHE_TTL * 2; // 30 seconds for low priority\n  }\n}\n\nfunction getDebounceDelay(priority: 'high' | 'medium' | 'low'): number {\n  switch (priority) {\n    case 'high':\n      return PRIORITY_DEBOUNCE_DELAY;\n    case 'medium':\n      return DEBOUNCE_DELAY;\n    case 'low':\n      return DEBOUNCE_DELAY * 2; // 300ms for low priority\n  }\n}\n\n// Enhanced cache eviction strategy\nfunction evictOldCacheEntries(): void {\n  if (queryCache.size <= MAX_CACHE_SIZE) return;\n\n  const entries = Array.from(queryCache.entries());\n  // Sort by priority (low first) and then by timestamp (oldest first) and access count (least accessed first)\n  entries.sort(([, a], [, b]) => {\n    const priorityOrder = { low: 0, medium: 1, high: 2 };\n    const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\n    if (priorityDiff !== 0) return priorityDiff;\n\n    const accessDiff = a.queryCount - b.queryCount;\n    if (accessDiff !== 0) return accessDiff;\n\n    return a.timestamp - b.timestamp;\n  });\n\n  // Remove 20% of entries (starting with lowest priority, least accessed, oldest)\n  const entriesToRemove = Math.ceil(queryCache.size * 0.2);\n  for (let i = 0; i < entriesToRemove; i++) {\n    queryCache.delete(entries[i][0]);\n  }\n}\n\n// Connection pool management\nfunction acquireConnection(): Promise<void> {\n  return new Promise((resolve) => {\n    if (connectionPool.activeConnections < connectionPool.maxConnections) {\n      connectionPool.activeConnections++;\n      resolve();\n    } else {\n      connectionPool.connectionQueue.push(() => {\n        connectionPool.activeConnections++;\n        resolve();\n      });\n    }\n  });\n}\n\nfunction releaseConnection(): void {\n  connectionPool.activeConnections--;\n\n  if (connectionPool.connectionQueue.length > 0) {\n    const nextCallback = connectionPool.connectionQueue.shift();\n    if (nextCallback) {\n      nextCallback();\n    }\n  }\n}\n\nexport function getQueryPerformanceMetrics(): Record<\n  string,\n  QueryMetrics & { cacheHitRate: number; errorRate: number; connectionPoolUtilization: number }\n> {\n  const result: Record<\n    string,\n    QueryMetrics & { cacheHitRate: number; errorRate: number; connectionPoolUtilization: number }\n  > = {};\n\n  queryMetrics.forEach((metrics, key) => {\n    result[key] = {\n      ...metrics,\n      cacheHitRate: metrics.queryCount > 0 ? (metrics.cacheHits / metrics.queryCount) * 100 : 0,\n      errorRate: metrics.queryCount > 0 ? (metrics.networkErrors / metrics.queryCount) * 100 : 0,\n      connectionPoolUtilization:\n        (connectionPool.activeConnections / connectionPool.maxConnections) * 100,\n    };\n  });\n\n  return result;\n}\n\nfunction getCacheKey(\n  collection: string,\n  roomId?: string | null,\n  additionalParams?: string\n): string {\n  return `${collection}:${roomId || 'global'}:${additionalParams || ''}`;\n}\n\nfunction isValidCache(cache: QueryCache, queryKey: string): boolean {\n  const priority = getCachePriority(queryKey);\n  const ttl = getCacheTTL(priority);\n  return Date.now() - cache.timestamp < ttl;\n}\n\nfunction debounceQuery<T extends unknown[]>(\n  queryKey: string,\n  queryFn: (...args: T) => void,\n  ...args: T\n): void {\n  const priority = getCachePriority(queryKey);\n  const debounceDelay = getDebounceDelay(priority);\n  const existingTimeout = queryDebounceMap.get(queryKey);\n\n  if (existingTimeout) {\n    clearTimeout(existingTimeout);\n  }\n\n  const timeout = setTimeout(async () => {\n    try {\n      // Use connection pooling for optimal performance\n      await acquireConnection();\n      queryFn(...args);\n    } catch (error) {\n      console.error('Query execution error:', error);\n    } finally {\n      releaseConnection();\n      queryDebounceMap.delete(queryKey);\n    }\n  }, debounceDelay);\n\n  queryDebounceMap.set(queryKey, timeout);\n}\n\ninterface SendMessageOptions {\n  room?: string | null;\n  user: UserType;\n  text?: string;\n  type: MessageType;\n  [key: string]: unknown;\n}\n\nexport async function sendMessage({\n  room,\n  user,\n  text = '',\n  type = 'chat',\n  ...rest\n}: SendMessageOptions): Promise<DocumentReference<DocumentData> | void> {\n  const allowedTypes = ['chat', 'actions', 'settings', 'room', 'media'];\n  if (!allowedTypes.includes(type)) {\n    let message = 'Invalid message type. Was expecting ';\n    message += allowedTypes.join(', ');\n    message += ` but got ${type}`;\n\n    return console.error(message);\n  }\n\n  if (!user?.uid) {\n    return;\n  }\n\n  const newMessage = { room, user: user.uid, text, type, ...rest };\n  if (JSON.stringify(newMessage) === JSON.stringify(lastMessage)) {\n    return; // Duplicate message detected. Not sending.\n  }\n  lastMessage = newMessage;\n\n  const now = Date.now();\n  const roomName = room?.toUpperCase() || 'PUBLIC';\n\n  try {\n    const docRef = await addDoc(collection(db, 'chat-rooms', roomName, 'messages'), {\n      text: text.trim(),\n      ttl: new Date(now + 24 * 60 * 60 * 1000), // 24 hours\n      type,\n      ...rest,\n      uid: user.uid,\n      displayName: user.displayName,\n      timestamp: serverTimestamp(),\n    });\n\n    return docRef;\n  } catch (error) {\n    console.error('Failed to send message:', error);\n    return;\n  }\n}\n\nexport async function deleteMessage(room: string, messageId: string): Promise<void> {\n  return deleteDoc(doc(db, `/chat-rooms/${room.toUpperCase()}/messages/${messageId}`));\n}\n\ninterface ImageData {\n  base64String: string;\n  format: string;\n}\n\ninterface UploadImageData {\n  image: ImageData;\n  room: string | null | undefined;\n  user: UserType;\n}\n\nexport async function uploadImage({ image, room, user }: UploadImageData): Promise<void> {\n  const storage = getStorage();\n  const imageUrl = image.base64String;\n  const imageLoc = `/images/${Math.random()}.${image.format}`;\n  const imageRef = storageRef(storage, imageLoc);\n\n  try {\n    const uploadResult = await uploadString(imageRef, imageUrl, 'base64');\n    const downloadURL = await getDownloadURL(uploadResult.ref);\n\n    await sendMessage({\n      room,\n      user,\n      text: '',\n      type: 'media',\n      image: downloadURL,\n    });\n  } catch (error) {\n    console.error('Error uploading image:', error);\n  }\n}\n\nexport function getMessages(\n  roomId: string | null | undefined,\n  callback: (messages: Array<Record<string, unknown>>) => void,\n  options: {\n    limitCount?: number;\n    startAfterDoc?: QueryDocumentSnapshot<DocumentData>;\n    enableCache?: boolean;\n    enableDebounce?: boolean;\n  } = {}\n): (() => void) | undefined {\n  if (!roomId) return undefined;\n\n  const auth = getAuth();\n\n  // Wait for authentication before proceeding\n  if (!auth.currentUser) {\n    // Return a function that sets up auth listener and then executes query\n    let unsubscribeAuth: (() => void) | undefined;\n    let unsubscribeQuery: (() => void) | undefined;\n\n    unsubscribeAuth = auth.onAuthStateChanged((user) => {\n      if (user) {\n        // User is now authenticated, proceed with the query\n        unsubscribeQuery = executeGetMessages(roomId, callback, options);\n        // Clean up auth listener\n        if (unsubscribeAuth) {\n          unsubscribeAuth();\n          unsubscribeAuth = undefined;\n        }\n      }\n    });\n\n    // Return cleanup function\n    return () => {\n      if (unsubscribeAuth) unsubscribeAuth();\n      if (unsubscribeQuery) unsubscribeQuery();\n    };\n  }\n\n  // User is already authenticated, proceed normally\n  return executeGetMessages(roomId, callback, options);\n}\n\nfunction executeGetMessages(\n  roomId: string,\n  callback: (messages: Array<Record<string, unknown>>) => void,\n  options: {\n    limitCount?: number;\n    startAfterDoc?: QueryDocumentSnapshot<DocumentData>;\n    enableCache?: boolean;\n    enableDebounce?: boolean;\n  } = {}\n): (() => void) | undefined {\n  const {\n    limitCount = DEFAULT_LIMIT,\n    startAfterDoc,\n    enableCache = true,\n    enableDebounce = true,\n  } = options;\n\n  const roomUpper = roomId.toUpperCase();\n  const queryKey = getCacheKey('messages', roomUpper, `limit:${limitCount}`);\n  const startTime = Date.now();\n\n  // Check cache first with smart cache validation\n  if (enableCache) {\n    const cached = queryCache.get(queryKey);\n    if (cached && isValidCache(cached, queryKey)) {\n      // Update cache access count for smart eviction\n      cached.queryCount++;\n      queryCache.set(queryKey, cached);\n\n      updateQueryMetrics(queryKey, Date.now() - startTime, true);\n      callback(cached.data as Array<Record<string, unknown>>);\n      return () => {}; // Return empty unsubscribe function for cached results\n    }\n  }\n\n  const executeQuery = () => {\n    let networkError = false;\n    let unsubscribe: (() => void) | undefined;\n\n    try {\n      // Use connection pooling for optimal Firebase performance\n      acquireConnection();\n\n      // Enhanced time window - use 3 hours for better performance vs data freshness balance\n      const timeWindow = new Date();\n      timeWindow.setHours(timeWindow.getHours() - 3);\n\n      let baseQuery = query(\n        collection(db, 'chat-rooms', roomUpper, 'messages'),\n        where('timestamp', '>', timeWindow),\n        orderBy('timestamp', 'desc'),\n        limit(limitCount)\n      );\n\n      // Add pagination if startAfterDoc is provided\n      if (startAfterDoc) {\n        baseQuery = query(\n          collection(db, 'chat-rooms', roomUpper, 'messages'),\n          where('timestamp', '>', timeWindow),\n          orderBy('timestamp', 'desc'),\n          startAfter(startAfterDoc),\n          limit(limitCount)\n        );\n      }\n\n      unsubscribe = onSnapshot(\n        baseQuery,\n        (querySnapshot: QuerySnapshot<DocumentData>) => {\n          const queryEndTime = Date.now();\n          const latency = queryEndTime - startTime;\n\n          const messages = querySnapshot.docs.map((document) => ({\n            id: document.id,\n            ...document.data(),\n          }));\n\n          // Update cache with enhanced metadata\n          if (enableCache && messages.length > 0) {\n            evictOldCacheEntries(); // Prevent memory bloat\n\n            const lastVisible = querySnapshot.docs[querySnapshot.docs.length - 1];\n            const priority = getCachePriority(queryKey);\n\n            queryCache.set(queryKey, {\n              data: messages,\n              timestamp: queryEndTime,\n              lastVisible,\n              queryCount: 1,\n              priority,\n            });\n          }\n\n          updateQueryMetrics(queryKey, latency, false, networkError);\n          callback(messages);\n        },\n        (error) => {\n          networkError = true;\n          console.error('getMessages error:', error);\n          updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n        }\n      );\n\n      return unsubscribe;\n    } catch (error) {\n      networkError = true;\n      console.error('getMessages connection error:', error);\n      updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n      return () => {};\n    } finally {\n      releaseConnection();\n    }\n  };\n\n  // Apply smart debouncing based on priority\n  if (enableDebounce) {\n    let deferredUnsubscribe: (() => void) | undefined;\n\n    debounceQuery(queryKey, () => {\n      deferredUnsubscribe = executeQuery();\n    });\n\n    return () => {\n      const timeout = queryDebounceMap.get(queryKey);\n      if (timeout) {\n        clearTimeout(timeout);\n        queryDebounceMap.delete(queryKey);\n      }\n      if (deferredUnsubscribe) {\n        deferredUnsubscribe();\n      }\n    };\n  }\n\n  return executeQuery();\n}\n\n// Enhanced pagination helper for messages\nexport function getMessagesWithPagination(\n  roomId: string | null | undefined,\n  callback: (\n    messages: Array<Record<string, unknown>>,\n    lastVisible?: QueryDocumentSnapshot<DocumentData>\n  ) => void,\n  limitCount: number = DEFAULT_LIMIT,\n  startAfterDoc?: QueryDocumentSnapshot<DocumentData>\n): (() => void) | undefined {\n  if (!roomId) return undefined;\n\n  return getMessages(\n    roomId,\n    (messages) => {\n      const cached = queryCache.get(\n        getCacheKey('messages', roomId.toUpperCase(), `limit:${limitCount}`)\n      );\n      callback(messages, cached?.lastVisible);\n    },\n    {\n      limitCount,\n      startAfterDoc,\n      enableCache: true,\n      enableDebounce: true,\n    }\n  );\n}\n\nexport function getSchedule(\n  callback: (schedule: Array<Record<string, unknown>>) => void,\n  options: {\n    limitCount?: number;\n    startAfterDoc?: QueryDocumentSnapshot<DocumentData>;\n    enableCache?: boolean;\n    enableDebounce?: boolean;\n  } = {}\n): () => void {\n  const {\n    limitCount = DEFAULT_LIMIT,\n    startAfterDoc,\n    enableCache = true,\n    enableDebounce = true,\n  } = options;\n\n  const queryKey = getCacheKey('schedule', null, `limit:${limitCount}`);\n  const startTime = Date.now();\n\n  // Check cache first with smart cache validation\n  if (enableCache) {\n    const cached = queryCache.get(queryKey);\n    if (cached && isValidCache(cached, queryKey)) {\n      // Update cache access count for smart eviction\n      cached.queryCount++;\n      queryCache.set(queryKey, cached);\n\n      updateQueryMetrics(queryKey, Date.now() - startTime, true);\n      callback(cached.data as Array<Record<string, unknown>>);\n      return () => {}; // Return empty unsubscribe function for cached results\n    }\n  }\n\n  const executeQuery = async (): Promise<() => void> => {\n    let networkError = false;\n    let unsubscribe: (() => void) | undefined;\n\n    try {\n      // Use connection pooling for optimal Firebase performance\n      await acquireConnection();\n\n      // Enhanced time filtering - include current games (5 minutes buffer)\n      const currentTime = new Date();\n      currentTime.setMinutes(currentTime.getMinutes() - 5);\n\n      let baseQuery = query(\n        collection(db, 'schedule'),\n        where('dateTime', '>', currentTime),\n        orderBy('dateTime', 'asc'),\n        limit(limitCount)\n      );\n\n      // Add pagination if startAfterDoc is provided\n      if (startAfterDoc) {\n        baseQuery = query(\n          collection(db, 'schedule'),\n          where('dateTime', '>', currentTime),\n          orderBy('dateTime', 'asc'),\n          startAfter(startAfterDoc),\n          limit(limitCount)\n        );\n      }\n\n      unsubscribe = onSnapshot(\n        baseQuery,\n        (querySnapshot: QuerySnapshot<DocumentData>) => {\n          const queryEndTime = Date.now();\n          const latency = queryEndTime - startTime;\n\n          const schedule = querySnapshot.docs.map((document) => ({\n            id: document.id,\n            ...document.data(),\n          }));\n\n          // Update cache with enhanced metadata\n          if (enableCache && schedule.length > 0) {\n            evictOldCacheEntries(); // Prevent memory bloat\n\n            const lastVisible = querySnapshot.docs[querySnapshot.docs.length - 1];\n            const priority = getCachePriority(queryKey);\n\n            queryCache.set(queryKey, {\n              data: schedule,\n              timestamp: queryEndTime,\n              lastVisible,\n              queryCount: 1,\n              priority,\n            });\n          }\n\n          updateQueryMetrics(queryKey, latency, false, networkError);\n          callback(schedule);\n        },\n        (error) => {\n          networkError = true;\n          console.error('getSchedule error:', error);\n          updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n        }\n      );\n\n      return unsubscribe || (() => {});\n    } catch (error) {\n      networkError = true;\n      console.error('getSchedule connection error:', error);\n      updateQueryMetrics(queryKey, Date.now() - startTime, false, true);\n      return () => {};\n    } finally {\n      releaseConnection();\n    }\n  };\n\n  // Apply smart debouncing based on priority\n  if (enableDebounce) {\n    let deferredUnsubscribe: (() => void) | undefined;\n\n    debounceQuery(queryKey, async () => {\n      deferredUnsubscribe = await executeQuery();\n    });\n\n    return () => {\n      const timeout = queryDebounceMap.get(queryKey);\n      if (timeout) {\n        clearTimeout(timeout);\n        queryDebounceMap.delete(queryKey);\n      }\n      if (deferredUnsubscribe) {\n        deferredUnsubscribe();\n      }\n    };\n  }\n\n  const result = executeQuery();\n  return result instanceof Promise ? () => {} : result;\n}\n\n// Enhanced pagination helper for schedule\nexport function getScheduleWithPagination(\n  callback: (\n    schedule: Array<Record<string, unknown>>,\n    lastVisible?: QueryDocumentSnapshot<DocumentData>\n  ) => void,\n  limitCount: number = DEFAULT_LIMIT,\n  startAfterDoc?: QueryDocumentSnapshot<DocumentData>\n): () => void {\n  return getSchedule(\n    (schedule) => {\n      const cached = queryCache.get(getCacheKey('schedule', null, `limit:${limitCount}`));\n      callback(schedule, cached?.lastVisible);\n    },\n    {\n      limitCount,\n      startAfterDoc,\n      enableCache: true,\n      enableDebounce: true,\n    }\n  );\n}\n\n// Utility function to clear query cache (useful for testing or memory management)\nexport function clearQueryCache(pattern?: string): void {\n  if (pattern) {\n    Array.from(queryCache.keys())\n      .filter((key) => key.includes(pattern))\n      .forEach((key) => queryCache.delete(key));\n  } else {\n    queryCache.clear();\n  }\n}\n\n// Enhanced utility function to get comprehensive cache stats\nexport function getCacheStats(): {\n  totalCachedQueries: number;\n  cacheSize: number;\n  oldestCacheEntry: number | null;\n  newestCacheEntry: number | null;\n  memoryUsageEstimate: number;\n  cachesByPriority: { high: number; medium: number; low: number };\n  averageQueryCount: number;\n  connectionPoolStats: {\n    activeConnections: number;\n    maxConnections: number;\n    queueLength: number;\n    utilizationPercentage: number;\n  };\n} {\n  const timestamps = Array.from(queryCache.values()).map((cache) => cache.timestamp);\n  const cacheValues = Array.from(queryCache.values());\n\n  // Calculate cache distribution by priority\n  const priorityStats = cacheValues.reduce(\n    (acc, cache) => {\n      acc[cache.priority]++;\n      return acc;\n    },\n    { high: 0, medium: 0, low: 0 }\n  );\n\n  // Estimate memory usage (rough calculation)\n  const memoryUsageEstimate = cacheValues.reduce((total, cache) => {\n    return total + JSON.stringify(cache.data).length * 2; // Rough bytes estimate\n  }, 0);\n\n  // Calculate average query count\n  const averageQueryCount =\n    cacheValues.length > 0\n      ? cacheValues.reduce((sum, cache) => sum + cache.queryCount, 0) / cacheValues.length\n      : 0;\n\n  return {\n    totalCachedQueries: queryCache.size,\n    cacheSize: queryCache.size,\n    oldestCacheEntry: timestamps.length > 0 ? Math.min(...timestamps) : null,\n    newestCacheEntry: timestamps.length > 0 ? Math.max(...timestamps) : null,\n    memoryUsageEstimate,\n    cachesByPriority: priorityStats,\n    averageQueryCount,\n    connectionPoolStats: {\n      activeConnections: connectionPool.activeConnections,\n      maxConnections: connectionPool.maxConnections,\n      queueLength: connectionPool.connectionQueue.length,\n      utilizationPercentage:\n        (connectionPool.activeConnections / connectionPool.maxConnections) * 100,\n    },\n  };\n}\n\n// Add new performance optimization utilities\nexport function optimizeCache(): {\n  entriesEvicted: number;\n  memoryFreed: number;\n  newCacheSize: number;\n} {\n  const beforeSize = queryCache.size;\n  const beforeMemory = Array.from(queryCache.values()).reduce((total, cache) => {\n    return total + JSON.stringify(cache.data).length * 2;\n  }, 0);\n\n  evictOldCacheEntries();\n\n  const afterSize = queryCache.size;\n  const afterMemory = Array.from(queryCache.values()).reduce((total, cache) => {\n    return total + JSON.stringify(cache.data).length * 2;\n  }, 0);\n\n  return {\n    entriesEvicted: beforeSize - afterSize,\n    memoryFreed: beforeMemory - afterMemory,\n    newCacheSize: afterSize,\n  };\n}\n\n// Get performance recommendations based on current metrics\nexport function getPerformanceRecommendations(): {\n  recommendations: string[];\n  overallScore: number;\n  issues: string[];\n} {\n  const metrics = getQueryPerformanceMetrics();\n  const cacheStats = getCacheStats();\n  const recommendations: string[] = [];\n  const issues: string[] = [];\n  let overallScore = 100;\n\n  // Analyze cache hit rates\n  const avgCacheHitRate =\n    Object.values(metrics).reduce((sum, metric) => sum + metric.cacheHitRate, 0) /\n      Object.keys(metrics).length || 0;\n\n  if (avgCacheHitRate < 50) {\n    recommendations.push('Increase cache TTL for better hit rates');\n    issues.push('Low cache hit rate detected');\n    overallScore -= 20;\n  }\n\n  // Analyze connection pool utilization\n  if (cacheStats.connectionPoolStats.utilizationPercentage > 80) {\n    recommendations.push('Consider increasing connection pool size');\n    issues.push('High connection pool utilization');\n    overallScore -= 15;\n  }\n\n  // Analyze error rates\n  const avgErrorRate =\n    Object.values(metrics).reduce((sum, metric) => sum + metric.errorRate, 0) /\n      Object.keys(metrics).length || 0;\n\n  if (avgErrorRate > 5) {\n    recommendations.push('Investigate network errors and add retry logic');\n    issues.push('High error rate detected');\n    overallScore -= 25;\n  }\n\n  // Analyze latency\n  const avgLatency =\n    Object.values(metrics).reduce((sum, metric) => sum + metric.avgLatency, 0) /\n      Object.keys(metrics).length || 0;\n\n  if (avgLatency > 1000) {\n    recommendations.push('Optimize query structures and indexes');\n    issues.push('High average latency detected');\n    overallScore -= 20;\n  }\n\n  // Memory usage recommendations\n  if (cacheStats.memoryUsageEstimate > 10 * 1024 * 1024) {\n    // 10MB\n    recommendations.push('Consider reducing cache size or implementing more aggressive eviction');\n    issues.push('High memory usage detected');\n    overallScore -= 10;\n  }\n\n  if (recommendations.length === 0) {\n    recommendations.push('Performance is optimal!');\n  }\n\n  return {\n    recommendations,\n    overallScore: Math.max(0, overallScore),\n    issues,\n  };\n}\n\nexport async function addSchedule(\n  dateTime: Date,\n  url: string,\n  room = 'PUBLIC'\n): Promise<DocumentReference<DocumentData> | void> {\n  try {\n    return await addDoc(collection(db, 'schedule'), {\n      dateTime: Timestamp.fromDate(dateTime),\n      url,\n      room,\n    });\n  } catch (error) {\n    return console.error(error);\n  }\n}\n","import { Middleware, DBCore, DBCoreTable, DBCoreMutateRequest } from 'dexie';\nimport { WindowWithAuth } from '../types/app';\n\ninterface SyncMiddlewareOptions {\n  tables: string[];\n}\n\ninterface TimeoutMap {\n  [key: string]: ReturnType<typeof setTimeout>;\n}\n\ninterface SyncDebounce {\n  timeouts: TimeoutMap;\n  queue: Set<string>;\n  scheduleSync(tableName: string): void;\n  processSyncQueue(): void;\n}\n\ninterface DexieMiddleware extends Middleware<DBCore> {\n  stack: 'dbcore';\n  name: string;\n}\n\n/**\n * Creates a Dexie middleware that syncs data to Firebase after database modifications\n * @param options - Configuration options\n * @returns Dexie middleware function\n */\nexport function createSyncMiddleware(\n  options: SyncMiddlewareOptions = { tables: ['customTiles', 'gameBoard'] }\n): DexieMiddleware {\n  const { tables } = options;\n  const tableSet = new Set(tables);\n\n  // Debounce mechanism\n  const syncDebounce: SyncDebounce = {\n    timeouts: {},\n    queue: new Set<string>(),\n\n    // Schedule a sync for a specific table\n    scheduleSync(tableName: string): void {\n      // Clear any existing timeout for this table\n      if (this.timeouts[tableName]) {\n        clearTimeout(this.timeouts[tableName]);\n      }\n\n      // Add to queue\n      this.queue.add(tableName);\n\n      // Set a new timeout\n      this.timeouts[tableName] = setTimeout(() => {\n        this.processSyncQueue();\n      }, 2000); // 2 second debounce\n    },\n\n    // Process all tables in the queue\n    processSyncQueue(): void {\n      if (this.queue.size === 0) return;\n\n      // Only sync if we have an authenticated non-anonymous user\n      const windowWithAuth = window as WindowWithAuth;\n      if (windowWithAuth.authContext?.user && !windowWithAuth.authContext.user.isAnonymous) {\n        windowWithAuth.authContext.syncData();\n      }\n\n      // Clear the queue and timeouts\n      this.queue.clear();\n      Object.keys(this.timeouts).forEach((key) => {\n        clearTimeout(this.timeouts[key]);\n        delete this.timeouts[key];\n      });\n    },\n  };\n\n  return {\n    stack: 'dbcore',\n    name: 'syncMiddleware',\n    create(downlevelDatabase: DBCore): DBCore {\n      return {\n        ...downlevelDatabase,\n        table(tableName: string): DBCoreTable {\n          const downlevelTable = downlevelDatabase.table(tableName);\n\n          // Only apply middleware to specified tables\n          if (!tableSet.has(tableName)) {\n            return downlevelTable;\n          }\n\n          return {\n            ...downlevelTable,\n            mutate: async (req: DBCoreMutateRequest): Promise<any> => {\n              // First, perform the actual database operation\n              const result = await downlevelTable.mutate(req);\n\n              // After successful operation, trigger sync if it's a write operation\n              if (['put', 'add', 'delete', 'deleteRange', 'update'].includes(req.type)) {\n                // Schedule a sync for this table with debouncing\n                syncDebounce.scheduleSync(tableName);\n              }\n\n              return result;\n            },\n          };\n        },\n      };\n    },\n  };\n}\n","import { createSyncMiddleware } from '@/services/syncMiddleware';\nimport Dexie, { type EntityTable } from 'dexie';\nimport { CustomTilePull } from '@/types/customTiles';\nimport { DBGameBoard } from '@/types/gameBoard';\nimport { CustomGroupPull } from '@/types/customGroups';\nimport { DBLocalPlayerSession, DBLocalPlayerMove, DBLocalPlayerStats } from '@/types/localPlayerDB';\n\nclass BlitzedOutDatabase extends Dexie {\n  customTiles!: EntityTable<CustomTilePull, 'id'>;\n  gameBoard!: EntityTable<DBGameBoard, 'id'>;\n  customGroups!: EntityTable<CustomGroupPull, 'id'>;\n  localPlayerSessions!: EntityTable<DBLocalPlayerSession, 'id'>;\n  localPlayerMoves!: EntityTable<DBLocalPlayerMove, 'id'>;\n  localPlayerStats!: EntityTable<DBLocalPlayerStats, 'id'>;\n\n  constructor() {\n    super('blitzedOut');\n\n    // Version 1: Modern normalized schema with group_id relationships\n    this.version(1).stores({\n      customTiles:\n        '++id, group_id, [group_id+intensity+action], intensity, action, isEnabled, tags, isCustom',\n      gameBoard: '++id, title, tiles, tags, gameMode, isActive',\n      customGroups:\n        '++id, name, label, locale, gameMode, isDefault, createdAt, [name+locale+gameMode]',\n      localPlayerSessions: '++id, sessionId, roomId, isActive, createdAt, updatedAt',\n      localPlayerMoves: '++id, sessionId, playerId, timestamp, sequence',\n      localPlayerStats: '++id, sessionId, playerId, lastActive',\n    });\n  }\n}\n\nconst db = new BlitzedOutDatabase();\n\ndb.use(\n  createSyncMiddleware({\n    tables: [\n      'customTiles',\n      'gameBoard',\n      'customGroups',\n      'localPlayerSessions',\n      'localPlayerMoves',\n      'localPlayerStats',\n    ],\n  })\n);\n\nexport default db;\n","/**\n * Database error recovery utility\n *\n * Provides shared logic for handling database errors by implementing\n * recovery strategies for different error types, particularly Safari\n * IndexedDB issues and cursor-related errors.\n */\n\ninterface DatabaseLike {\n  isOpen?(): boolean;\n  open?(): any;\n  close?(): any;\n}\n\n/**\n * Recovery strategy interface for different error types\n */\ninterface RecoveryStrategy {\n  canHandle(error: Error): boolean;\n  recover(\n    db: DatabaseLike,\n    operation: () => Promise<any>,\n    logger: (message: string, error?: Error) => void\n  ): Promise<any>;\n}\n\n/**\n * Detects if the current browser is Safari (desktop or mobile)\n */\nfunction isSafari(): boolean {\n  if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n    return false;\n  }\n  const userAgent = navigator.userAgent;\n  return userAgent.includes('Safari') && !userAgent.includes('Chrome');\n}\n\n/**\n * Recovery strategy for cursor-related errors\n */\nclass CursorErrorStrategy implements RecoveryStrategy {\n  canHandle(error: Error): boolean {\n    return error.message.includes('cursor');\n  }\n\n  async recover(\n    db: DatabaseLike,\n    operation: () => Promise<any>,\n    logger: (message: string, error?: Error) => void\n  ): Promise<any> {\n    logger('Attempting database recovery for cursor error');\n\n    if (typeof db.close === 'function' && typeof db.open === 'function') {\n      await db.close();\n      await db.open();\n      logger('Database reopened successfully, retrying operation');\n      return await operation();\n    } else {\n      logger('Database does not support close/open operations');\n      throw new Error('Database recovery not supported');\n    }\n  }\n}\n\n/**\n * Recovery strategy for Safari IndexedDB connection issues\n */\nclass SafariConnectionStrategy implements RecoveryStrategy {\n  canHandle(error: Error): boolean {\n    if (!isSafari()) {\n      return false;\n    }\n\n    const message = error.message.toLowerCase();\n    return (\n      message.includes('connection to indexed database server lost') ||\n      message.includes('error looking up record in object store by key range') ||\n      message.includes('indexeddb connection') ||\n      message.includes('database connection')\n    );\n  }\n\n  async recover(\n    db: DatabaseLike,\n    operation: () => Promise<any>,\n    logger: (message: string, error?: Error) => void\n  ): Promise<any> {\n    logger('Attempting Safari IndexedDB connection recovery');\n\n    if (typeof db.close === 'function' && typeof db.open === 'function') {\n      await db.close();\n\n      // Safari-specific delay to allow IndexedDB to stabilize\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      await db.open();\n\n      // Additional small delay before retry to ensure connection is stable\n      await new Promise((resolve) => setTimeout(resolve, 50));\n\n      logger('Safari IndexedDB connection recovered, retrying operation');\n      return await operation();\n    } else {\n      logger('Database does not support close/open operations');\n      throw new Error('Safari IndexedDB recovery not supported');\n    }\n  }\n}\n\n/**\n * Recovery strategies registry\n */\nconst recoveryStrategies: RecoveryStrategy[] = [\n  new SafariConnectionStrategy(),\n  new CursorErrorStrategy(),\n];\n\n/**\n * Retries a database operation once if it fails with a recoverable error.\n *\n * Handles both cursor errors and Safari IndexedDB connection issues using\n * appropriate recovery strategies.\n *\n * @param db - Database instance with isOpen, open, and close methods\n * @param operation - Async operation to execute and potentially retry\n * @param logger - Optional custom logger function (defaults to console.error)\n * @returns Promise that resolves to the operation result\n * @throws Re-throws the error if retry fails or if it's not a recoverable error\n */\nexport async function retryOnCursorError<T>(\n  db: DatabaseLike,\n  operation: () => Promise<T>,\n  logger?: (message: string, error?: Error) => void\n): Promise<T> {\n  const log =\n    logger ||\n    ((message: string, error?: Error) => {\n      console.error(message, error);\n    });\n\n  try {\n    // Check if database is ready (skip in test environment)\n    if (typeof db.isOpen === 'function' && !db.isOpen()) {\n      await db.open?.();\n    }\n\n    return await operation();\n  } catch (error) {\n    const errorInstance = error instanceof Error ? error : new Error(String(error));\n    log(`Database operation failed: ${errorInstance.message}`, errorInstance);\n\n    // Try recovery strategies in order of priority\n    for (const strategy of recoveryStrategies) {\n      if (strategy.canHandle(errorInstance)) {\n        try {\n          return await strategy.recover(db, operation, log);\n        } catch (retryError) {\n          const retryErrorInstance =\n            retryError instanceof Error ? retryError : new Error(String(retryError));\n          log(\n            `Error retrying operation after ${strategy.constructor.name}: ${retryErrorInstance.message}`,\n            retryErrorInstance\n          );\n          throw retryErrorInstance;\n        }\n      }\n    }\n\n    // No recovery strategy found, re-throw original error\n    throw errorInstance;\n  }\n}\n","/**\n * Constants and configuration for the migration service\n */\n\n// Supported languages for migration\nexport const SUPPORTED_LANGUAGES = ['en', 'es', 'fr', 'zh', 'hi'] as const;\n\n// ============================================================================\n// MIGRATION VERSION CONFIGURATION\n// ============================================================================\n//\n// VERSION HISTORY:\n// - 2.1.0: Initial migration system\n// - 2.1.1: Fixed import path matching (@/locales vs /src/locales)\n// - 2.1.2: Added corruption detection and auto-recovery\n// - 2.2.0: Added body worship group\n// - 2.3.0: Fix syncing issues with custom groups and tiles\n//\nexport const MIGRATION_VERSION = '2.3.0';\n// ============================================================================\n\n// Configuration keys for localStorage\nexport const MIGRATION_KEY = 'blitzed-out-action-groups-migration';\nexport const BACKGROUND_MIGRATION_KEY = 'blitzed-out-background-migration';\n\n// localStorage-based concurrency control keys for better reliability in hot module reloading environments\nexport const MIGRATION_IN_PROGRESS_KEY = 'blitzed-out-migration-in-progress';\nexport const CURRENT_LANGUAGE_MIGRATION_KEY = 'blitzed-out-current-language-migration';\nexport const BACKGROUND_MIGRATION_IN_PROGRESS_KEY = 'blitzed-out-background-migration-in-progress';\n\n// Timeout configurations (in milliseconds)\nexport const MIGRATION_TIMEOUT = 30 * 1000; // 30 seconds\nexport const BACKGROUND_MIGRATION_TIMEOUT = 10 * 60 * 1000; // 10 minutes\nexport const STALE_LOCK_TIMEOUT = 5 * 60 * 1000; // 5 minutes\n\n// Delay configurations\nexport const BACKGROUND_MIGRATION_DELAY = 10; // 10ms between operations\nexport const QUEUE_BACKGROUND_MIGRATION_DELAY = 1000; // 1 second\nexport const IDLE_CALLBACK_TIMEOUT = 5000; // 5 seconds\n\n// Game modes\nexport const GAME_MODES = ['local', 'online'] as const;\n\nexport type SupportedLanguage = (typeof SUPPORTED_LANGUAGES)[number];\nexport type GameMode = (typeof GAME_MODES)[number];\n","import i18next from 'i18next';\nimport db from './store';\nimport { CustomTile, CustomTilePull } from '@/types/customTiles';\nimport { CustomTileFilters, PaginatedResult } from '@/types/dexieTypes';\nimport { Collection, Table } from 'dexie';\nimport { retryOnCursorError } from '@/utils/dbRecovery';\nimport { MIGRATION_IN_PROGRESS_KEY, MIGRATION_TIMEOUT } from '@/services/migration/constants';\n\nconst { customTiles } = db;\n\n// Index the customTiles table by isCustom for faster queries\ncustomTiles.hook(\n  'creating',\n  function (this: any, _primKey: number | undefined, obj: CustomTile, _transaction: any) {\n    // Set default values\n    if (obj.isCustom === undefined) obj.isCustom = 1;\n\n    // For sync operations, group_id is required. For initial setup and default tile imports,\n    // we allow tiles without group_id temporarily but log a warning for monitoring\n    if (!obj.group_id || !obj.group_id.trim()) {\n      // Only enforce group_id for custom tiles (isCustom: 1) during sync operations\n      // Default tiles from JSON imports (isCustom: 0) can be imported without group_id initially\n      if (obj.isCustom === 1) {\n        console.warn(\n          `Custom tile missing group_id (sync may fail): ${obj.action} (group_id: ${obj.group_id})`\n        );\n      }\n    }\n  }\n);\n\nexport const importCustomTiles = async (\n  record: Partial<CustomTile>[]\n): Promise<number | undefined> => {\n  const recordData = record.map((tile) => ({ ...tile, isEnabled: 1 }));\n  return await customTiles.bulkAdd(recordData as CustomTile[]);\n};\n\n// Helper function to create and filter the query\nconst createFilteredQuery = (filters: Partial<CustomTileFilters>) => {\n  const possibleFilters = [\n    'locale',\n    'gameMode',\n    'group',\n    'group_id', // Add group_id as a valid filter\n    'intensity',\n    'tag',\n    'isCustom',\n    'isEnabled',\n    'action',\n  ];\n  let query: Collection<CustomTilePull, number | undefined> = (\n    customTiles as Table<CustomTilePull, number>\n  ).toCollection();\n\n  const filtersArray = Object.entries(filters).filter(([key]) => possibleFilters.includes(key));\n\n  filtersArray.forEach(([key, value]) => {\n    if (value === undefined || value === null || value === '') return;\n\n    if (key === 'tag') {\n      query = query.filter((tile) => tile.tags.includes(value as string));\n    } else if (key === 'group' || key === 'group_id') {\n      // Map both 'group' and 'group_id' filters to 'group_id' field\n      query = query.filter((tile) => tile.group_id === value);\n    } else if (key === 'intensity') {\n      // Convert intensity filter to number for proper comparison\n      const intensityNum = Number(value);\n      query = query.filter((tile) => {\n        return tile.intensity === intensityNum;\n      });\n    } else {\n      query = query.filter((tile) => tile[key as keyof CustomTile] === value);\n    }\n  });\n\n  return query;\n};\n\nexport const getTiles = async (\n  filters: Omit<CustomTileFilters, 'page' | 'limit' | 'paginated'> = {}\n): Promise<CustomTilePull[]> => {\n  try {\n    // Check if migration is in progress and wait if necessary\n    if (typeof window !== 'undefined') {\n      const migrationInProgress = localStorage.getItem(MIGRATION_IN_PROGRESS_KEY);\n      if (migrationInProgress) {\n        try {\n          const migrationData = JSON.parse(migrationInProgress);\n          const migrationAge = Date.now() - new Date(migrationData.startedAt).getTime();\n\n          // If migration is recent (less than timeout), wait for it to complete\n          if (migrationAge < MIGRATION_TIMEOUT) {\n            let waitCount = 0;\n            const maxWait = Math.ceil(MIGRATION_TIMEOUT / 50); // Maximum wait based on timeout (600 iterations for 30s)\n\n            while (localStorage.getItem(MIGRATION_IN_PROGRESS_KEY) && waitCount < maxWait) {\n              await new Promise((resolve) => setTimeout(resolve, 50));\n              waitCount++;\n            }\n          }\n        } catch {\n          // Ignore JSON parse errors and continue\n        }\n      }\n    }\n\n    return await retryOnCursorError(\n      db,\n      async () => {\n        const query = createFilteredQuery(filters);\n        return await query.toArray();\n      },\n      (message: string, error?: Error) => {\n        console.error(`Error in getTiles: ${message}`, error);\n      }\n    );\n  } catch (error) {\n    console.error('Final error in getTiles:', error);\n    return [];\n  }\n};\n\nexport const getPaginatedTiles = async (\n  filters: CustomTileFilters\n): Promise<PaginatedResult<CustomTilePull>> => {\n  const { page = 1, limit = 50 } = filters;\n\n  try {\n    const query = createFilteredQuery(filters);\n\n    // Get total count for pagination\n    const count = await query.count();\n\n    // Apply pagination\n    const offset = (page - 1) * limit;\n    const items = await query.offset(offset).limit(limit).toArray();\n\n    return {\n      items: items,\n      total: count,\n      page,\n      limit,\n      totalPages: Math.ceil(count / limit),\n    };\n  } catch (error) {\n    console.error('Error in getPaginatedTiles:', error);\n    return {\n      items: [],\n      total: 0,\n      page,\n      limit,\n      totalPages: 0,\n    };\n  }\n};\n\n/**\n * Get tile counts and intensity distributions by group (without labels)\n * This should be merged with group definitions from customGroups table\n * Optimized: filters by relevant group IDs first instead of loading all tiles\n */\nexport const getTileCountsByGroup = async (\n  locale = 'en',\n  gameMode = 'online',\n  tags: string[] | string | null = null\n): Promise<Record<string, { count: number; intensities: Record<number, number> }>> => {\n  try {\n    // Step 1: Get relevant group IDs first (much smaller dataset - ~15-20 groups vs 4000+ tiles)\n    const { getCustomGroups } = await import('./customGroups');\n    const relevantGroups = await getCustomGroups({ locale, gameMode });\n    const groupIds = new Set(relevantGroups.map((group) => group.id));\n\n    if (groupIds.size === 0) {\n      return {};\n    }\n\n    // Step 2: Only get tiles that belong to these specific groups\n    let relevantTiles: any[] = [];\n    for (const groupId of groupIds) {\n      const tilesInGroup = await customTiles.where('group_id').equals(groupId).toArray();\n      relevantTiles.push(...tilesInGroup);\n    }\n\n    // Step 3: Apply tag filtering if specified\n    if (tags) {\n      const tagsArray = Array.isArray(tags) ? tags : [tags];\n      relevantTiles = relevantTiles.filter((tile) =>\n        tile.tags.some((tag: string) => tagsArray.includes(tag))\n      );\n    }\n\n    // Step 4: Build the counts using group IDs as keys\n    return relevantTiles.reduce<\n      Record<string, { count: number; intensities: Record<number, number> }>\n    >((groups, tile) => {\n      const groupKey = tile.group_id;\n      if (!groups[groupKey]) {\n        groups[groupKey] = {\n          count: 0,\n          intensities: {},\n        };\n      }\n      groups[groupKey].count++;\n\n      const intensity = Number(tile.intensity);\n      if (!groups[groupKey].intensities[intensity]) {\n        groups[groupKey].intensities[intensity] = 0;\n      }\n      groups[groupKey].intensities[intensity]++;\n\n      return groups;\n    }, {});\n  } catch (error) {\n    console.error('Error in getTileCountsByGroup:', error);\n    return {};\n  }\n};\n\nexport const getActiveTiles = async (\n  gameMode: string | null = null,\n  locale: string | null = null\n): Promise<CustomTilePull[]> => {\n  const currentLocale = locale || i18next.resolvedLanguage || i18next.language || 'en';\n\n  // Get all enabled tiles first\n  const allEnabledTiles = await customTiles.where('isEnabled').equals(1).toArray();\n\n  // If we need to filter by gameMode or locale, we need to join with groups\n  if (gameMode || locale) {\n    const { getCustomGroups } = await import('./customGroups');\n    const groupsQuery: any = {};\n    if (gameMode) groupsQuery.gameMode = gameMode;\n    if (locale) groupsQuery.locale = currentLocale;\n\n    const matchingGroups = await getCustomGroups(groupsQuery);\n    const groupIds = new Set(matchingGroups.map((group) => group.id));\n\n    return allEnabledTiles.filter((tile) => tile.group_id && groupIds.has(tile.group_id));\n  }\n\n  return allEnabledTiles;\n};\n\nexport const addCustomTile = async (record: Partial<CustomTile>): Promise<number | undefined> => {\n  return await customTiles.add({\n    ...record,\n    isEnabled: 1,\n  } as CustomTile);\n};\n\nexport const updateCustomTile = async (\n  id: number,\n  record: Partial<CustomTile>\n): Promise<number> => {\n  return await customTiles.update(id, record);\n};\n\nexport const toggleCustomTile = async (id: number): Promise<number> => {\n  const tile = await customTiles.get(id);\n\n  if (!tile) {\n    throw new Error(`Custom tile with id ${id} not found`);\n  }\n\n  const newEnabledState = !tile.isEnabled ? 1 : 0;\n\n  const result = await customTiles.update(id, {\n    isEnabled: newEnabledState,\n  });\n\n  return result;\n};\n\nexport async function deleteAllIsCustomTiles(): Promise<boolean> {\n  try {\n    await db.customTiles.where('isCustom').equals(1).delete();\n    return true;\n  } catch (error) {\n    console.error('Error deleting custom tiles:', error);\n    return false;\n  }\n}\n\nexport const deleteCustomTile = async (id: number): Promise<void> => {\n  await customTiles.delete(id);\n};\n\n/**\n * Count custom tiles that belong to a specific group\n * @deprecated Use countTilesByGroupId instead for better performance\n */\nexport const countTilesByGroup = async (\n  groupName: string,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<number> => {\n  try {\n    // Since we need to work with group names, look up the group first\n    const { getCustomGroupByName } = await import('./customGroups');\n    const group = await getCustomGroupByName(groupName, locale, gameMode);\n    if (!group) return 0;\n\n    return await countTilesByGroupId(group.id, locale, gameMode);\n  } catch (error) {\n    console.error('Error counting tiles by group:', error);\n    return 0;\n  }\n};\n\n/**\n * Delete all custom tiles that belong to a specific group\n * @deprecated Use deleteCustomTilesByGroupId instead for better performance\n */\nexport const deleteCustomTilesByGroup = async (\n  groupName: string,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<number> => {\n  try {\n    // Since we need to work with group names, look up the group first\n    const { getCustomGroupByName } = await import('./customGroups');\n    const group = await getCustomGroupByName(groupName, locale, gameMode);\n    if (!group) return 0;\n\n    return await deleteCustomTilesByGroupId(group.id, locale, gameMode);\n  } catch (error) {\n    console.error('Error deleting tiles by group:', error);\n    return 0;\n  }\n};\n\n/**\n * NEW: Get tiles by group ID (normalized approach)\n * This uses the new group_id foreign key for better performance\n */\nexport const getTilesByGroupId = async (\n  groupId: string,\n  _locale = 'en',\n  _gameMode = 'online'\n): Promise<CustomTilePull[]> => {\n  try {\n    return await retryOnCursorError(\n      db,\n      async () => {\n        return await customTiles.where('group_id').equals(groupId).toArray();\n      },\n      (message: string, error?: Error) => {\n        console.error(`Error in getTilesByGroupId: ${message}`, error);\n      }\n    );\n  } catch (error) {\n    console.error('Final error in getTilesByGroupId:', error);\n    return [];\n  }\n};\n/**\n * NEW: Get tiles by multiple group IDs efficiently\n * This is the proper way to find tiles for multiple groups without locale/gameMode filtering\n */\nexport const getTilesByGroupIds = async (groupIds: string[]): Promise<CustomTilePull[]> => {\n  try {\n    if (groupIds.length === 0) {\n      return [];\n    }\n\n    return await retryOnCursorError(\n      db,\n      async () => {\n        // Use Dexie's anyOf for efficient multiple group ID lookup\n        return await customTiles.where('group_id').anyOf(groupIds).toArray();\n      },\n      (message: string, error?: Error) => {\n        console.error(`Error in getTilesByGroupIds: ${message}`, error);\n      }\n    );\n  } catch (error) {\n    console.error('Final error in getTilesByGroupIds:', error);\n    return [];\n  }\n};\n\n/**\n * NEW: Count tiles by group ID (normalized approach)\n */\nexport const countTilesByGroupId = async (\n  groupId: string,\n  _locale = 'en',\n  _gameMode = 'online'\n): Promise<number> => {\n  try {\n    return await customTiles.where('group_id').equals(groupId).count();\n  } catch (error) {\n    console.error('Error counting tiles by group ID:', error);\n    return 0;\n  }\n};\n\n/**\n * NEW: Delete tiles by group ID (normalized approach with cascading)\n */\nexport const deleteCustomTilesByGroupId = async (\n  groupId: string,\n  _locale = 'en',\n  _gameMode = 'online'\n): Promise<number> => {\n  try {\n    return await customTiles.where('group_id').equals(groupId).delete();\n  } catch (error) {\n    console.error('Error deleting tiles by group ID:', error);\n    return 0;\n  }\n};\n\n/**\n * NEW: Get tiles with group information joined (efficient normalized query)\n * Returns tiles with their associated group data\n */\nexport const getTilesWithGroups = async (\n  filters: Omit<CustomTileFilters, 'page' | 'limit' | 'paginated'> = {}\n): Promise<Array<CustomTilePull & { groupData?: any }>> => {\n  try {\n    const { getCustomGroups } = await import('./customGroups');\n\n    // Get tiles using existing filtering\n    const tiles = await getTiles(filters);\n\n    // Get all relevant groups for this locale/gameMode\n    const groups = await getCustomGroups({\n      locale: filters.locale,\n      gameMode: filters.gameMode,\n    });\n\n    // Create group lookup map\n    const groupMap = new Map(groups.map((g) => [g.id, g]));\n\n    // Join tiles with their group data\n    return tiles.map((tile) => ({\n      ...tile,\n      groupData: tile.group_id ? groupMap.get(tile.group_id) : null,\n    }));\n  } catch (error) {\n    console.error('Error in getTilesWithGroups:', error);\n    return [];\n  }\n};\n","import { Collection, Table } from 'dexie';\nimport {\n  CustomGroup,\n  CustomGroupBase,\n  CustomGroupFilters,\n  CustomGroupIntensity,\n  CustomGroupPull,\n} from '@/types/customGroups';\n\nimport db from './store';\nimport i18next from 'i18next';\nimport { nanoid } from 'nanoid';\nimport { retryOnCursorError } from '@/utils/dbRecovery';\n\nconst { customGroups } = db;\n\n// Hook to set default values when creating custom groups\ncustomGroups.hook(\n  'creating',\n  function (this: any, _primKey: string | undefined, obj: CustomGroup, _transaction: any) {\n    if (!obj.id) obj.id = nanoid();\n    if (obj.locale === undefined) obj.locale = i18next.resolvedLanguage || i18next.language || 'en';\n    if (obj.gameMode === undefined) obj.gameMode = 'online';\n    if (obj.isDefault === undefined) obj.isDefault = false;\n    const now = new Date();\n    if (!(obj as CustomGroupPull).createdAt) (obj as CustomGroupPull).createdAt = now;\n    (obj as CustomGroupPull).updatedAt = now;\n  }\n);\n\n// Hook to update the updatedAt timestamp when updating\ncustomGroups.hook(\n  'updating',\n  function (this: any, modifications: any, _primKey: string, _obj: CustomGroup, _transaction: any) {\n    modifications.updatedAt = new Date();\n  }\n);\n\n// Helper function to create and filter the query\nconst createFilteredQuery = (filters: Partial<CustomGroupFilters>) => {\n  const possibleFilters = ['locale', 'gameMode', 'name', 'isDefault'];\n  let query: Collection<CustomGroupPull, string | undefined> = (\n    customGroups as Table<CustomGroupPull, string>\n  ).toCollection();\n\n  const filtersArray = Object.entries(filters).filter(([key]) => possibleFilters.includes(key));\n\n  filtersArray.forEach(([key, value]) => {\n    if (value === undefined || value === null || value === '') return;\n\n    query = query.filter((group) => group[key as keyof CustomGroup] === value);\n  });\n\n  return query;\n};\n\n/**\n * Get custom groups with optional filtering\n */\nexport const getCustomGroups = async (\n  filters: Partial<CustomGroupFilters> = {}\n): Promise<CustomGroupPull[]> => {\n  try {\n    return await retryOnCursorError(\n      db,\n      async () => {\n        const query = createFilteredQuery(filters);\n        const arrayData = await query.toArray();\n        return arrayData.sort((a, b) => a.name.localeCompare(b.name));\n      },\n      (message: string, error?: Error) => {\n        console.error(`Error in getCustomGroups: ${message}`, error);\n      }\n    );\n  } catch (error) {\n    console.error('Final error in getCustomGroups:', error);\n    return [];\n  }\n};\n\n/**\n * Get a single custom group by ID\n */\nexport const getCustomGroup = async (id: string): Promise<CustomGroupPull | undefined> => {\n  try {\n    return await customGroups.get(id);\n  } catch (error) {\n    console.error('Error in getCustomGroup:', error);\n    return undefined;\n  }\n};\n\n/**\n * Get a custom group by name, locale, and game mode\n */\nexport const getCustomGroupByName = async (\n  name: string,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<CustomGroupPull | undefined> => {\n  try {\n    return await customGroups\n      .where('name')\n      .equals(name)\n      .and((group) => group.locale === locale && group.gameMode === gameMode)\n      .first();\n  } catch (error) {\n    console.error('Error in getCustomGroupByName:', error);\n    return undefined;\n  }\n};\n\n/**\n * Add a new custom group\n */\nexport const addCustomGroup = async (group: CustomGroupBase): Promise<string | undefined> => {\n  try {\n    return await retryOnCursorError(\n      db,\n      async () => {\n        // The creating hook will add/overwrite id, locale, gameMode, isDefault, and updatedAt fields\n        // We provide required timestamps here (hook will overwrite updatedAt)\n        const timestamp = new Date();\n        const groupWithTimestamp = {\n          ...group,\n          createdAt: timestamp,\n          updatedAt: timestamp, // Hook will overwrite this\n        } as Omit<CustomGroupPull, 'id'>;\n\n        const id = await customGroups.add(groupWithTimestamp);\n        return id;\n      },\n      (message: string, error?: Error) => {\n        console.error(`Error in addCustomGroup: ${message}`, error);\n      }\n    );\n  } catch (error) {\n    console.error('Final error in addCustomGroup:', error);\n    return undefined;\n  }\n};\n\n/**\n * Update an existing custom group\n */\nexport const updateCustomGroup = async (\n  id: string,\n  updates: Partial<CustomGroupBase>\n): Promise<number> => {\n  try {\n    // Ensure database is open before operation\n    if (typeof db.isOpen === 'function' && !db.isOpen()) {\n      await db.open();\n    }\n\n    return await customGroups.update(id, updates);\n  } catch (error) {\n    console.error('Error in updateCustomGroup:', error);\n    return 0;\n  }\n};\n\n/**\n * Delete a custom group with cascading delete protection\n * Prevents deletion if tiles exist, unless forced\n */\nexport const deleteCustomGroup = async (\n  id: string,\n  options: { force?: boolean; cascadeDelete?: boolean } = {}\n): Promise<{ success: boolean; tilesDeleted?: number; error?: string }> => {\n  try {\n    const { countTilesByGroupId, deleteCustomTilesByGroupId } = await import('./customTiles');\n\n    // Check if group has associated tiles\n    const group = await customGroups.get(id);\n    if (!group) {\n      return { success: false, error: 'Group not found' };\n    }\n\n    const tileCount = await countTilesByGroupId(id, group.locale, group.gameMode);\n\n    if (tileCount > 0) {\n      if (!options.force && !options.cascadeDelete) {\n        return {\n          success: false,\n          error: `Cannot delete group \"${group.name}\". It has ${tileCount} associated tiles. Use force or cascadeDelete option.`,\n        };\n      }\n\n      if (options.cascadeDelete) {\n        // Delete all associated tiles first\n        const deletedTiles = await deleteCustomTilesByGroupId(id, group.locale, group.gameMode);\n        await customGroups.delete(id);\n        return { success: true, tilesDeleted: deletedTiles };\n      }\n    }\n\n    // Safe to delete - no tiles or force option used\n    await customGroups.delete(id);\n    return { success: true };\n  } catch (error) {\n    console.error('Error in deleteCustomGroup:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n};\n\n/**\n * Delete all custom groups (useful for migrations and testing)\n */\nexport const deleteAllCustomGroups = async (): Promise<boolean> => {\n  try {\n    await customGroups.clear();\n    return true;\n  } catch (error) {\n    console.error('Error deleting all custom groups:', error);\n    return false;\n  }\n};\n\n/**\n * Import multiple custom groups\n */\nexport const importCustomGroups = async (\n  groups: Partial<CustomGroup>[]\n): Promise<string | undefined> => {\n  try {\n    const now = new Date();\n    const groupsWithAllFields = groups.map((group) => {\n      const fullGroup: CustomGroupPull = {\n        name: group.name || '',\n        label: group.label || '',\n        intensities: group.intensities || [],\n        id: group.id || nanoid(),\n        locale: group.locale || 'en',\n        gameMode: group.gameMode || 'online',\n        isDefault: group.isDefault || false,\n        createdAt: (group as CustomGroupPull).createdAt || now,\n        updatedAt: (group as CustomGroupPull).updatedAt || now,\n      };\n      return fullGroup;\n    });\n\n    return await customGroups.bulkAdd(groupsWithAllFields);\n  } catch (error) {\n    console.error('Error in importCustomGroups:', error);\n    return undefined;\n  }\n};\n\n/**\n * Create default custom groups from locale action files\n * This is used during migration and initial setup\n */\nexport const createDefaultGroups = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<CustomGroupPull[]> => {\n  try {\n    // Get all existing groups from Dexie for this locale/gameMode\n    const existingGroups = await getCustomGroups({ locale, gameMode, isDefault: true });\n\n    // If we already have default groups, return them\n    if (existingGroups.length > 0) {\n      return existingGroups;\n    }\n\n    // If no groups exist, migration probably hasn't run yet\n    // Return empty array - migration will handle creating groups\n    return [];\n  } catch (error) {\n    console.error('Error creating default groups:', error);\n    return [];\n  }\n};\n\n/**\n * Get all available intensity levels for a specific group\n */\nexport const getGroupIntensities = async (\n  groupName: string,\n  locale = 'en',\n  gameMode = 'online'\n): Promise<CustomGroupIntensity[]> => {\n  try {\n    const group = await getCustomGroupByName(groupName, locale, gameMode);\n    return group?.intensities || [];\n  } catch (error) {\n    console.error('Error in getGroupIntensities:', error);\n    return [];\n  }\n};\n\n/**\n * Validate that a custom group name is unique within the locale/gameMode\n */\nexport const isGroupNameUnique = async (\n  name: string,\n  locale = 'en',\n  gameMode = 'online',\n  excludeId?: string\n): Promise<boolean> => {\n  try {\n    const existingGroup = await getCustomGroupByName(name, locale, gameMode);\n    if (!existingGroup) return true;\n    if (excludeId && existingGroup.id === excludeId) return true;\n    return false;\n  } catch (error) {\n    console.error('Error in isGroupNameUnique:', error);\n    return false;\n  }\n};\n\n/**\n * Get all custom groups for the current locale and game mode\n */\nexport const getCurrentGroups = async (gameMode?: string): Promise<CustomGroupPull[]> => {\n  const currentLocale = i18next.resolvedLanguage || i18next.language || 'en';\n  return getCustomGroups({\n    locale: currentLocale,\n    gameMode: gameMode || 'online',\n  });\n};\n\n/**\n * Get default and custom groups combined for display in selectors\n */\n/**\n * Remove duplicate groups from the database\n * Keeps the first occurrence of each group name per locale/gameMode\n */\nexport const removeDuplicateGroups = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<number> => {\n  try {\n    const allGroups = await getCustomGroups({ locale, gameMode });\n    const groupsByName = new Map<string, CustomGroupPull[]>();\n\n    // Group by name\n    allGroups.forEach((group) => {\n      const existing = groupsByName.get(group.name) || [];\n      existing.push(group);\n      groupsByName.set(group.name, existing);\n    });\n\n    let removedCount = 0;\n\n    // Remove duplicates (keep the first, remove the rest)\n    for (const [, groups] of groupsByName) {\n      if (groups.length > 1) {\n        // Sort by creation date to keep the oldest\n        groups.sort((a, b) => {\n          try {\n            const aTime =\n              a.createdAt instanceof Date ? a.createdAt.getTime() : new Date(a.createdAt).getTime();\n            const bTime =\n              b.createdAt instanceof Date ? b.createdAt.getTime() : new Date(b.createdAt).getTime();\n            return aTime - bTime;\n          } catch (error) {\n            // If date parsing fails, fall back to createdAt comparison for deterministic ordering\n            console.warn(\n              'Date parsing failed in removeDuplicateGroups, using createdAt fallback:',\n              error\n            );\n            return a.createdAt.getTime() - b.createdAt.getTime();\n          }\n        });\n\n        // Remove all but the first\n        for (let i = 1; i < groups.length; i++) {\n          await deleteCustomGroup(groups[i].id);\n          removedCount++;\n        }\n      }\n    }\n\n    return removedCount;\n  } catch (error) {\n    console.error('Error in removeDuplicateGroups:', error);\n    return 0;\n  }\n};\n\n/**\n * Force recreate default groups with proper intensities from action files\n * This is useful when intensities need to be updated\n */\nexport const recreateDefaultGroups = async (): Promise<number> => {\n  // This function is no longer needed since migration handles creating groups\n  // Just return 0 to maintain compatibility\n  return 0;\n};\n\nexport const getAllAvailableGroups = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<CustomGroupPull[]> => {\n  try {\n    // Check if migration is in progress and wait if necessary\n    const migrationInProgress = localStorage.getItem('blitzed-out-migration-in-progress');\n    if (migrationInProgress) {\n      const migrationData = JSON.parse(migrationInProgress);\n      const migrationAge = Date.now() - new Date(migrationData.startedAt).getTime();\n\n      // If migration is recent (less than 30 seconds), wait for it to complete\n      if (migrationAge < 30000) {\n        let waitCount = 0;\n        const maxWait = 60; // Maximum 3 seconds wait (60 * 50ms)\n\n        while (localStorage.getItem('blitzed-out-migration-in-progress') && waitCount < maxWait) {\n          await new Promise((resolve) => setTimeout(resolve, 50));\n          waitCount++;\n        }\n      }\n    }\n\n    // Ensure database is ready before any operations (skip in test environment)\n    if (typeof db.isOpen === 'function' && !db.isOpen()) {\n      await db.open();\n    }\n\n    // Clean up any existing duplicates first (but skip if cursor error)\n    try {\n      await removeDuplicateGroups(locale, gameMode);\n    } catch (duplicateError) {\n      console.warn('Skipping duplicate removal due to database error:', duplicateError);\n    }\n\n    // Get all groups for this locale/gameMode from Dexie\n    const groups = await getCustomGroups({ locale, gameMode });\n\n    // Additional safety deduplication by name (keep the first occurrence)\n    const uniqueGroups = groups\n      .filter((group, index, self) => self.findIndex((g) => g.name === group.name) === index)\n      .sort((a, b) => a.name.localeCompare(b.name));\n\n    return uniqueGroups;\n  } catch (error) {\n    console.error('❌ getAllAvailableGroups: Database error', {\n      locale,\n      gameMode,\n      error,\n    });\n\n    // If it's a cursor error, provide better error context\n    if (error instanceof Error && error.message.includes('cursor')) {\n      console.warn(\n        'Database cursor error in getAllAvailableGroups, returning empty array to prevent crash'\n      );\n    }\n\n    return [];\n  }\n};\n\n/**\n * Get all groups that have associated tiles (both default and custom groups)\n * Returns groups that actually have tiles created for them, regardless of whether they're default or custom\n * Used by setup wizard and other contexts that need groups with tiles\n */\nexport const getGroupsWithTiles = async (gameMode = 'online'): Promise<CustomGroupPull[]> => {\n  try {\n    return await retryOnCursorError(\n      db,\n      async () => {\n        // Import the new efficient function\n        const { getTilesByGroupIds } = await import('./customTiles');\n\n        // Get all groups for this locale/gameMode (both default and custom)\n        const allGroups = await getCurrentGroups(gameMode);\n\n        // Extract group IDs for efficient tile lookup\n        const groupIds = allGroups.map((group) => group.id);\n\n        // Get tiles for these specific group IDs only (no locale/gameMode filtering)\n        const tilesForGroups = await getTilesByGroupIds(groupIds);\n\n        // Get unique group IDs that actually have tiles\n        const groupIdsWithTiles = new Set(\n          tilesForGroups.map((tile) => tile.group_id).filter(Boolean)\n        );\n\n        // Filter groups to only include those that have tiles\n        const groupsWithTiles = allGroups.filter((group) => groupIdsWithTiles.has(group.id));\n\n        return groupsWithTiles;\n      },\n      (message: string, error?: Error) => {\n        console.error(`Error in getGroupsWithTiles: ${message}`, error);\n      }\n    );\n  } catch (error) {\n    console.error('Final error in getGroupsWithTiles:', error);\n    return [];\n  }\n};\n\n/**\n * Utility functions for post-migration runtime queries\n * These query Dexie instead of reading JSON files\n */\n\n/**\n * Get all action group names for a specific locale and game mode\n */\nexport const getActionGroupsForMode = async (\n  locale: string,\n  gameMode: string\n): Promise<string[]> => {\n  try {\n    const groups = await getCustomGroups({ locale, gameMode, isDefault: true });\n    return groups.map((g) => g.name).sort();\n  } catch (error) {\n    console.error('Error getting action groups for mode:', error);\n    return [];\n  }\n};\n\n/**\n * Get all available action group names across all locales and game modes\n */\nexport const getAllActionGroupNames = async (): Promise<string[]> => {\n  try {\n    const groups = await getCustomGroups({ isDefault: true });\n    const groupNames = [...new Set(groups.map((g) => g.name))].sort();\n    return groupNames;\n  } catch (error) {\n    console.error('Error getting all action group names:', error);\n    return [];\n  }\n};\n\n/**\n * Get available groups with their locale and game mode information\n */\nexport const getGroupAvailability = async (): Promise<\n  {\n    groupName: string;\n    locales: string[];\n    gameModes: string[];\n    combinations: Array<{ locale: string; gameMode: string }>;\n  }[]\n> => {\n  try {\n    const groups = await getCustomGroups({ isDefault: true });\n    const availability = new Map<\n      string,\n      {\n        locales: Set<string>;\n        gameModes: Set<string>;\n        combinations: Array<{ locale: string; gameMode: string }>;\n      }\n    >();\n\n    groups.forEach((group) => {\n      if (!availability.has(group.name)) {\n        availability.set(group.name, {\n          locales: new Set(),\n          gameModes: new Set(),\n          combinations: [],\n        });\n      }\n\n      const groupData = availability.get(group.name);\n      if (groupData) {\n        groupData.locales.add(group.locale);\n        groupData.gameModes.add(group.gameMode);\n        groupData.combinations.push({ locale: group.locale, gameMode: group.gameMode });\n      } else {\n        console.error(`Unexpected error: group data not found for group: ${group.name}`);\n      }\n    });\n\n    return Array.from(availability.entries())\n      .map(([groupName, data]) => ({\n        groupName,\n        locales: Array.from(data.locales).sort(),\n        gameModes: Array.from(data.gameModes).sort(),\n        combinations: data.combinations,\n      }))\n      .sort((a, b) => a.groupName.localeCompare(b.groupName));\n  } catch (error) {\n    console.error('Error getting group availability:', error);\n    return [];\n  }\n};\n","import db from './store';\nimport { DBGameBoard } from '@/types/gameBoard';\n\nconst { gameBoard } = db;\n\nexport const getBoards = (): Promise<DBGameBoard[]> => {\n  return gameBoard.orderBy('title').toArray();\n};\n\nexport const getActiveBoard = async (): Promise<DBGameBoard | undefined> => {\n  return gameBoard.where('isActive').equals(1)?.first();\n};\n\nexport const getBoard = (id: number): Promise<DBGameBoard | undefined> => {\n  return gameBoard.get(id);\n};\n\nexport const addBoard = async (record: Partial<DBGameBoard>): Promise<number | undefined> => {\n  return gameBoard.add(record as DBGameBoard);\n};\n\nexport const updateBoard = async (\n  board: DBGameBoard,\n  record?: Partial<DBGameBoard>\n): Promise<number> => {\n  return gameBoard.update(board.id as number, { ...board, ...record });\n};\n\nexport const upsertBoard = async (record: Partial<DBGameBoard>): Promise<number | undefined> => {\n  const newData: DBGameBoard = {\n    title: record.title === undefined ? '' : record.title,\n    tiles: record.tiles || [],\n    isActive: record.isActive === undefined ? 1 : record.isActive,\n    tags: record.tags || [],\n    gameMode: record.gameMode || 'online',\n  };\n\n  // if we have tiles, we should have a title to go with it.\n  if (!newData?.title?.length && newData?.tiles?.length) {\n    return undefined;\n  }\n\n  const board = await gameBoard.where('title').equals(newData.title).first();\n\n  return db.transaction('rw', db.gameBoard, async () => {\n    if (newData.isActive) {\n      await deactivateAllBoards();\n    }\n\n    if (board) {\n      await updateBoard(board, record);\n      return board.id;\n    }\n\n    return await addBoard(newData);\n  });\n};\n\nexport const activateBoard = async (id: number): Promise<void> => {\n  const allBoards = await gameBoard.toArray();\n\n  const updatedBoards = allBoards.map((board) => ({\n    ...board,\n    isActive: board.id === id ? 1 : 0,\n  }));\n\n  await gameBoard.bulkPut(updatedBoards);\n};\n\nexport const deleteBoard = async (id: number): Promise<void> => {\n  await gameBoard.delete(id);\n};\n\nconst deactivateAllBoards = async (): Promise<void> => {\n  await gameBoard.where('isActive').equals(1).modify({ isActive: 0 });\n};\n","import { ActionEntry } from '@/types';\nimport { Settings } from '@/types/Settings';\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\nconst defaultSettings: Settings = {\n  locale: 'en',\n  gameMode: 'online',\n  boardUpdated: false,\n  room: 'PUBLIC',\n  background: 'color',\n  roomBackground: 'useAppBackground',\n  selectedActions: {},\n  hasSeenRollButton: false,\n  themeMode: 'system',\n  playerDialog: true,\n};\n\ninterface SettingsStore {\n  settings: Settings;\n  updateSettings: (partial: Partial<Settings>) => void;\n  setLocale: (locale: string) => void;\n  resetSettings: () => void;\n  updateSelectedAction: (key: string, actionEntry: ActionEntry | null) => void;\n  removeSelectedAction: (key: string) => void;\n  clearSelectedActions: () => void;\n  getSelectedActionsByType: (type: string) => Record<string, ActionEntry>;\n}\n\nexport const useSettingsStore = create<SettingsStore>()(\n  persist(\n    (set) => ({\n      settings: defaultSettings,\n      updateSettings: (partial) =>\n        set((state) => ({\n          settings: { ...state.settings, ...partial },\n        })),\n      setLocale: (locale) =>\n        set((state) => ({\n          settings: { ...state.settings, locale },\n        })),\n      resetSettings: () => set({ settings: defaultSettings }),\n      updateSelectedAction: (key, actionEntry) =>\n        set((state) => {\n          const newSelectedActions = { ...state.settings.selectedActions };\n          if (actionEntry === null) {\n            delete newSelectedActions[key];\n          } else {\n            newSelectedActions[key] = actionEntry;\n          }\n          return {\n            settings: { ...state.settings, selectedActions: newSelectedActions },\n          };\n        }),\n      removeSelectedAction: (key) =>\n        set((state) => {\n          const newSelectedActions = { ...state.settings.selectedActions };\n          delete newSelectedActions[key];\n          return {\n            settings: { ...state.settings, selectedActions: newSelectedActions },\n          };\n        }),\n      clearSelectedActions: () =>\n        set((state) => ({\n          settings: { ...state.settings, selectedActions: {} },\n        })),\n      getSelectedActionsByType: (type: string): Record<string, ActionEntry> => {\n        const { selectedActions = {} } = useSettingsStore.getState().settings;\n        const actions: Record<string, ActionEntry> = selectedActions || {};\n        return Object.entries(actions)\n          .filter(([, entry]: [string, ActionEntry]) => entry.type === type)\n          .reduce((acc: Record<string, ActionEntry>, [key, entry]: [string, ActionEntry]) => {\n            acc[key] = entry;\n            return acc;\n          }, {});\n      },\n    }),\n    {\n      name: 'gameSettings', // localStorage key\n      partialize: (state) => ({ settings: state.settings }),\n    }\n  )\n);\n\n// Compatibility hook for useLocalStorage('gameSettings') pattern\nexport const useSettings = (): [Settings, (partial: Partial<Settings>) => void] => {\n  const { settings, updateSettings } = useSettingsStore();\n  return [settings, updateSettings];\n};\n\n// Compatibility hook for useGameSettings() pattern\nexport const useGameSettings = () => {\n  const { settings, updateSettings } = useSettingsStore();\n  return { settings, updateSettings };\n};\n","import {\n  deleteAllIsCustomTiles,\n  deleteCustomTile,\n  getTiles,\n  updateCustomTile,\n} from '@/stores/customTiles';\nimport { deleteCustomGroup, getCustomGroups } from '@/stores/customGroups';\nimport { doc, getDoc, setDoc } from 'firebase/firestore';\n\nimport { CustomGroupPull } from '@/types/customGroups';\nimport { CustomTilePull } from '@/types/customTiles';\nimport { getAuth } from 'firebase/auth';\nimport { getBoards } from '@/stores/gameBoard';\nimport { getFirestore } from 'firebase/firestore';\nimport { useSettingsStore } from '@/stores/settingsStore';\n\n// Updated to use inline type instead of separate interface to avoid unused warning\n\nconst db = getFirestore();\n\n// Export function for sync modules (avoid naming conflict with import)\nexport const deleteAllCustomTiles = deleteAllIsCustomTiles;\n\n// Helper function to clean up ALL duplicate tiles created by sync bug\nexport async function cleanupDuplicateTiles(): Promise<boolean> {\n  try {\n    // Get all tiles to analyze duplicates\n    const allTiles = await getTiles({});\n\n    // Group tiles by composite key to find duplicates\n    const tileGroups = new Map<string, typeof allTiles>();\n\n    allTiles.forEach((tile) => {\n      const key = `${tile.group_id}|${tile.intensity}|${tile.action}`;\n      if (!tileGroups.has(key)) {\n        tileGroups.set(key, []);\n      }\n      tileGroups.get(key)!.push(tile);\n    });\n\n    // For each group, keep only the original (lowest ID) and remove ALL duplicates\n    for (const [, tiles] of tileGroups) {\n      if (tiles.length > 1) {\n        // Sort by ID to find original (lowest ID)\n        tiles.sort((a, b) => (a.id || 0) - (b.id || 0));\n        const original = tiles[0];\n        const duplicates = tiles.slice(1);\n\n        // Check if any duplicate was disabled (user's intent)\n        const wasDisabled = duplicates.some((tile) => tile.isEnabled === 0);\n\n        // Delete ALL duplicates regardless of enabled state\n        for (const duplicate of duplicates) {\n          if (duplicate.id) {\n            await deleteCustomTile(duplicate.id);\n          }\n        }\n\n        // If any duplicate was disabled, disable the original (preserve user intent)\n        if (wasDisabled && original.isEnabled === 1) {\n          await updateCustomTile(original.id!, { isEnabled: 0 });\n        }\n      }\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error cleaning up duplicate tiles:', error);\n    return false;\n  }\n}\n\n// Helper function to clear only user-created custom groups (preserve default groups)\nexport async function clearUserCustomGroups(): Promise<boolean> {\n  try {\n    const userGroups = await getCustomGroups({ isDefault: false });\n\n    // Convert serial deleteCustomGroup calls to concurrent operations\n    const deletePromises = userGroups.map((group) => deleteCustomGroup(group.id));\n    await Promise.all(deletePromises);\n\n    return true;\n  } catch (error) {\n    console.error('Error deleting user custom groups:', error);\n    return false;\n  }\n}\n\n// Helper function to reset disabled defaults back to enabled state before restoring from Firebase\nexport async function resetDisabledDefaults(): Promise<boolean> {\n  try {\n    const disabledDefaults = await getTiles({ isCustom: 0, isEnabled: 0 });\n\n    // Filter out tiles without IDs and batch updateCustomTile operations concurrently\n    const validTiles = disabledDefaults.filter((tile) => tile.id);\n    const updatePromises = validTiles.map(\n      (tile) => updateCustomTile(tile.id!, { isEnabled: 1 }) // Reset to enabled state - Firebase will restore the correct disabled state\n    );\n    await Promise.all(updatePromises);\n\n    return true;\n  } catch (error) {\n    console.error('Error resetting disabled default tiles:', error);\n    return false;\n  }\n}\n\n// Helper function to apply disabled defaults from Firebase to existing default tiles\nexport async function applyDisabledDefaults(disabledDefaults: CustomTilePull[]): Promise<boolean> {\n  try {\n    // Prefetch all existing default tiles in a single query\n    const allDefaultTiles = await getTiles({ isCustom: 0 });\n\n    // Build an in-memory map keyed by composite key (gameMode|group|intensity|action) for O(1) lookups\n    const defaultTilesMap = new Map<string, number>();\n    allDefaultTiles.forEach((tile) => {\n      const key = `${tile.group_id}|${tile.intensity}|${tile.action}`;\n      defaultTilesMap.set(key, tile.id);\n    });\n\n    // Iterate disabledDefaults and collect update calls only for matched IDs\n    const updatePromises: Promise<number>[] = [];\n    disabledDefaults.forEach((disabledTile) => {\n      const key = `${disabledTile.group_id}|${disabledTile.intensity}|${disabledTile.action}`;\n      const matchedId = defaultTilesMap.get(key);\n\n      if (matchedId) {\n        updatePromises.push(updateCustomTile(matchedId, { isEnabled: 0 }));\n      }\n    });\n\n    // Run updates in a single batch using Promise.all\n    await Promise.all(updatePromises);\n    return true;\n  } catch (error) {\n    console.error('Error applying disabled defaults:', error);\n    return false;\n  }\n}\n\n// Sync custom tiles and disabled defaults to Firebase\nexport async function syncCustomTilesToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get custom tiles (user-created content)\n    const customTiles = await getTiles({ isCustom: 1 });\n\n    // Get disabled default tiles (user disabled these defaults)\n    const disabledDefaults = await getTiles({ isCustom: 0, isEnabled: 0 });\n\n    // Add validation to prevent uploading excessive disabled defaults\n    const MAX_REASONABLE_DISABLED_DEFAULTS = 100;\n    if (disabledDefaults.length > MAX_REASONABLE_DISABLED_DEFAULTS) {\n      console.warn(\n        `⚠️  Attempting to sync ${disabledDefaults.length} disabled defaults, which seems excessive.`\n      );\n      console.warn(\n        'This may indicate corrupted local data. Limiting to first 100 disabled defaults.'\n      );\n\n      // Limit to first 100 to prevent Firebase corruption\n      disabledDefaults.splice(MAX_REASONABLE_DISABLED_DEFAULTS);\n    }\n\n    // Create a document in Firebase with both custom tiles and disabled defaults\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        customTiles,\n        disabledDefaults,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing custom tiles:', error);\n    return false;\n  }\n}\n\n// Utility function to clean up corrupted disabled defaults in Firebase\nexport async function cleanupCorruptedDisabledDefaults(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get only genuinely user-disabled tiles (reasonable count)\n    const disabledDefaults = await getTiles({ isCustom: 0, isEnabled: 0 });\n\n    // If still excessive, something is wrong locally too\n    if (disabledDefaults.length > 100) {\n      console.warn(\n        '⚠️  Local disabled defaults count is also excessive. This suggests system-wide data corruption.'\n      );\n      console.warn('Consider using the reset disabled defaults function in the app settings.');\n      return false;\n    }\n\n    // Get current Firebase data to preserve other fields\n    const userDocRef = doc(db, 'user-data', user.uid);\n    const userDoc = await getDoc(userDocRef);\n\n    if (!userDoc.exists()) {\n      return true;\n    }\n\n    const userData = userDoc.data();\n\n    // Update only the disabledDefaults field with the cleaned data\n    await setDoc(userDocRef, {\n      ...userData,\n      disabledDefaults,\n      lastUpdated: new Date(),\n    });\n\n    return true;\n  } catch (error) {\n    console.error('❌ Error cleaning up corrupted disabled defaults:', error);\n    return false;\n  }\n}\n\n// Sync only user-created custom groups to Firebase (NOT default groups)\nexport async function syncCustomGroupsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get only user-created custom groups (not default groups)\n    const customGroups = await getCustomGroups({ isDefault: false });\n\n    // Create a document in Firebase with only user-created custom groups\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        customGroups,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing custom groups:', error);\n    return false;\n  }\n}\n\n// Sync game boards to Firebase\nexport async function syncGameBoardsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get all game boards from Dexie\n    const gameBoards = await getBoards();\n\n    if (!gameBoards.length) {\n      return true;\n    }\n\n    // Create a document in Firebase with all game boards\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        gameBoards,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing game boards:', error);\n    return false;\n  }\n}\n\n// Sync user settings (including theme preferences) to Firebase\nexport async function syncSettingsToFirebase(): Promise<boolean> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    console.error('No user logged in');\n    return false;\n  }\n\n  try {\n    // Get current settings from store\n    const { settings } = useSettingsStore.getState();\n\n    // Filter out local player settings and any undefined values - they should stay in React app only\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { localPlayers, ...settingsForFirebase } = settings;\n\n    // Remove any undefined values from settings to prevent Firebase errors\n    const cleanSettings = Object.fromEntries(\n      Object.entries(settingsForFirebase).filter(([, value]) => value !== undefined)\n    );\n\n    // Create a document in Firebase with filtered user settings\n    await setDoc(\n      doc(db, 'user-data', user.uid),\n      {\n        settings: cleanSettings,\n        lastUpdated: new Date(),\n      },\n      { merge: true }\n    );\n\n    return true;\n  } catch (error) {\n    console.error('Error syncing settings:', error);\n    return false;\n  }\n}\n\n// Sync all data to Firebase\nexport async function syncAllDataToFirebase(): Promise<boolean> {\n  await syncCustomTilesToFirebase();\n  await syncCustomGroupsToFirebase();\n  await syncGameBoardsToFirebase();\n  await syncSettingsToFirebase();\n  return true;\n}\n\n// Intelligent sync that handles conflicts - meant for user-initiated sync\nexport async function intelligentSync(): Promise<{ success: boolean; conflicts?: string[] }> {\n  const auth = getAuth();\n  const user = auth.currentUser;\n\n  if (!user) {\n    return { success: false, conflicts: ['No user logged in'] };\n  }\n\n  try {\n    // Get both local and Firebase data\n    const userDocRef = doc(db, 'user-data', user.uid);\n    const userDoc = await getDoc(userDocRef);\n\n    const localCustomTiles = await getTiles({ isCustom: 1 });\n    const localCustomGroups = await getCustomGroups({ isDefault: false });\n\n    const conflicts: string[] = [];\n\n    if (!userDoc.exists()) {\n      // No Firebase data - sync local to Firebase\n      await syncAllDataToFirebase();\n      return { success: true };\n    }\n\n    const userData = userDoc.data();\n    const firebaseCustomTiles = (userData.customTiles as CustomTilePull[]) || [];\n    const firebaseCustomGroups = (userData.customGroups as CustomGroupPull[]) || [];\n\n    // Check for conflicts\n    if (localCustomTiles.length > 0 && firebaseCustomTiles.length > 0) {\n      conflicts.push(\n        `Custom tiles: Local has ${localCustomTiles.length}, Firebase has ${firebaseCustomTiles.length}`\n      );\n    }\n\n    if (localCustomGroups.length > 0 && firebaseCustomGroups.length > 0) {\n      conflicts.push(\n        `Custom groups: Local has ${localCustomGroups.length}, Firebase has ${firebaseCustomGroups.length}`\n      );\n    }\n\n    if (conflicts.length > 0) {\n      return { success: false, conflicts };\n    }\n\n    // No conflicts - proceed with normal sync\n    const result = await syncDataFromFirebase();\n    return { success: result };\n  } catch (error) {\n    console.error('Error in intelligent sync:', error);\n    return { success: false, conflicts: ['Sync failed due to error'] };\n  }\n}\n\n// Enhanced sync with conflict resolution - preserves local data when Firebase is empty\nexport async function syncDataFromFirebase(\n  options: { forceSync?: boolean } = {}\n): Promise<boolean> {\n  // Use the new sync orchestrator for better maintainability\n  const { SyncOrchestrator } = await import('./sync/syncOrchestrator');\n  return await SyncOrchestrator.syncFromFirebase(options);\n}\n\n// Variable to store the interval ID for periodic syncing\nlet syncIntervalId: number | null = null;\n\n// Start periodic syncing from Firebase (every 5 minutes)\nexport function startPeriodicSync(intervalMinutes = 5): boolean {\n  // Clear any existing interval first\n  stopPeriodicSync();\n\n  // Convert minutes to milliseconds\n  const intervalMs = intervalMinutes * 60 * 1000;\n\n  // Set up the interval\n  syncIntervalId = window.setInterval(async () => {\n    const auth = getAuth();\n    if (auth.currentUser && !auth.currentUser.isAnonymous) {\n      await syncDataFromFirebase();\n    }\n  }, intervalMs);\n\n  return true;\n}\n\n// Stop periodic syncing\nexport function stopPeriodicSync(): boolean {\n  if (syncIntervalId) {\n    window.clearInterval(syncIntervalId);\n    syncIntervalId = null;\n    return true;\n  }\n  return false;\n}\n\n// Check if periodic sync is active\nexport function isPeriodicSyncActive(): boolean {\n  return syncIntervalId !== null;\n}\n\n// Manual cleanup function that can be called from console for immediate cleanup\n(window as any).cleanupTiles = cleanupDuplicateTiles;\n","import React, { useEffect, useMemo, useState, useRef, ReactNode, useCallback } from 'react';\nimport { getAuth } from 'firebase/auth';\nimport {\n  loginAnonymously,\n  updateDisplayName,\n  loginWithEmail,\n  loginWithGoogle,\n  registerWithEmail,\n  resetPassword,\n  convertAnonymousAccount,\n  logout,\n  wipeAllAppData,\n} from '@/services/firebase';\nimport {\n  syncDataFromFirebase,\n  syncAllDataToFirebase,\n  intelligentSync,\n  startPeriodicSync,\n  stopPeriodicSync,\n} from '@/services/syncService';\nimport { User } from '@/types';\nimport { getErrorMessage } from '@/types/errors';\nimport { reportFirefoxMobileAuthError } from '@/utils/firefoxMobileReporting';\n\nexport interface SyncStatus {\n  syncing: boolean;\n  lastSync: Date | null;\n}\n\nexport interface AuthContextType {\n  user: User | null;\n  loading: boolean;\n  initializing: boolean;\n  error: string | null;\n  syncStatus: SyncStatus;\n  login: (displayName?: string) => Promise<User | null>;\n  loginEmail: (email: string, password: string) => Promise<User>;\n  loginGoogle: () => Promise<User>;\n  register: (email: string, password: string, displayName: string) => Promise<User>;\n  updateUser: (displayName?: string) => Promise<User | null>;\n  forgotPassword: (email: string) => Promise<boolean>;\n  convertToRegistered: (email: string, password: string) => Promise<User>;\n  logout: () => Promise<void>;\n  wipeAllData: () => Promise<void>;\n  syncData: () => Promise<boolean>;\n  intelligentSync: () => Promise<{ success: boolean; conflicts?: string[] }>;\n  isAnonymous: boolean;\n}\n\n// eslint-disable-next-line react-refresh/only-export-components\nexport const AuthContext = React.createContext<AuthContextType | undefined>(undefined);\n\ninterface AuthProviderProps {\n  children: ReactNode;\n  [key: string]: unknown;\n}\n\nfunction AuthProvider(props: AuthProviderProps): JSX.Element {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState<boolean>(false); // Changed: false by default for immediate UI\n  const [initializing, setInitializing] = useState<boolean>(true); // New: tracks initial auth check\n  const [error, setError] = useState<string | null>(null);\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({ syncing: false, lastSync: null });\n\n  // Debounce mechanism for sync operations\n  const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Track if initial auth check is complete\n  const authInitializedRef = useRef<boolean>(false);\n\n  // Function to safely perform sync operations with debouncing\n  const performSync = useCallback(\n    async (syncFunction: () => Promise<boolean>): Promise<boolean> => {\n      // Clear any pending sync timeout\n      if (syncTimeoutRef.current) {\n        clearTimeout(syncTimeoutRef.current);\n        syncTimeoutRef.current = null;\n      }\n\n      // Return early if user is not logged in or is anonymous\n      if (!user || user.isAnonymous) return false;\n\n      try {\n        setSyncStatus({ syncing: true, lastSync: syncStatus.lastSync });\n        await syncFunction();\n        setSyncStatus({ syncing: false, lastSync: new Date() });\n        return true;\n      } catch (err: unknown) {\n        console.error('Sync error:', err);\n        if (err instanceof Error) {\n          setError(err.message);\n        } else {\n          setError('An unknown error occurred');\n        }\n        setSyncStatus({ syncing: false, lastSync: syncStatus.lastSync });\n        return false;\n      }\n    },\n    [user, syncTimeoutRef, setSyncStatus, syncStatus.lastSync, setError]\n  );\n  async function login(displayName = ''): Promise<User | null> {\n    try {\n      setError(null); // Clear any previous errors\n\n      const loggedInUser = await loginAnonymously(displayName);\n\n      if (!loggedInUser) {\n        const error = new Error('Login failed: No user returned from Firebase');\n        reportFirefoxMobileAuthError('auth_context_no_user', error, {\n          authentication: {\n            step: 'auth_context_no_user',\n            displayName,\n          },\n        });\n        setError(error.message);\n        return null;\n      }\n\n      setUser(loggedInUser);\n      return loggedInUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n\n      // Normalize the error to ensure it's an Error object\n      const normalizedError =\n        err instanceof Error ? err : new Error(String(err || 'Unknown error'));\n\n      reportFirefoxMobileAuthError('auth_context_login_failed', normalizedError, {\n        authentication: {\n          step: 'auth_context_login_failed',\n          displayName,\n        },\n      });\n\n      setError(errorMessage);\n      throw err;\n    }\n  }\n\n  async function loginEmail(email: string, password: string): Promise<User> {\n    try {\n      setLoading(true);\n      const loggedInUser = await loginWithEmail(email, password);\n      setUser(loggedInUser);\n\n      // Sync will happen via onAuthStateChanged\n      return loggedInUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function loginGoogle(): Promise<User> {\n    try {\n      setLoading(true);\n      const loggedInUser = await loginWithGoogle();\n      setUser(loggedInUser);\n\n      // Sync will happen via onAuthStateChanged\n      return loggedInUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function register(email: string, password: string, displayName: string): Promise<User> {\n    try {\n      setLoading(true);\n      const registeredUser = await registerWithEmail(email, password, displayName);\n      setUser(registeredUser);\n      return registeredUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function forgotPassword(email: string): Promise<boolean> {\n    try {\n      await resetPassword(email);\n      return true;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }\n\n  const convertToRegistered = useCallback(\n    async (email: string, password: string): Promise<User> => {\n      try {\n        setLoading(true);\n        const convertedUser = await convertAnonymousAccount(email, password);\n        setUser(convertedUser);\n\n        // Sync local data to Firebase after conversion\n        await performSync(syncAllDataToFirebase);\n\n        return convertedUser;\n      } catch (err) {\n        if (err instanceof Error) {\n          setError(err.message);\n        }\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [setLoading, setUser, performSync, setError]\n  );\n\n  async function updateUser(displayName = ''): Promise<User | null> {\n    try {\n      const updatedUser = await updateDisplayName(displayName);\n      setUser(updatedUser);\n      return updatedUser;\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }\n\n  const logoutUser = useCallback(async (): Promise<void> => {\n    try {\n      // Sync data to Firebase before logout if user is not anonymous\n      if (user && !user.isAnonymous) {\n        // Add timeout to make sure logout doesn't hang\n        const syncPromise = performSync(syncAllDataToFirebase);\n        const timeoutPromise = new Promise((resolve) => setTimeout(resolve, 5000, false));\n        await Promise.race([syncPromise, timeoutPromise]);\n      }\n\n      await logout();\n      setUser(null);\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [user, performSync, setUser, setError]);\n\n  const wipeAllAppDataAndReload = useCallback(async (): Promise<void> => {\n    try {\n      // Use the comprehensive wipe function from firebase service\n      await wipeAllAppData();\n\n      // Clear user state\n      setUser(null);\n\n      // Reload the page to ensure all React state is reset\n      window.location.reload();\n    } catch (err: unknown) {\n      const errorMessage = getErrorMessage(err);\n      setError(errorMessage);\n      throw err;\n    }\n  }, [setUser, setError]);\n\n  const syncData = useCallback(async (): Promise<boolean> => {\n    return performSync(syncAllDataToFirebase);\n  }, [performSync]);\n\n  const handleIntelligentSync = useCallback(async (): Promise<{\n    success: boolean;\n    conflicts?: string[];\n  }> => {\n    // Don't use performSync wrapper for intelligent sync as it needs custom return type\n    if (!user || user.isAnonymous) {\n      return { success: false, conflicts: ['User not logged in or is anonymous'] };\n    }\n\n    try {\n      setSyncStatus({ syncing: true, lastSync: syncStatus.lastSync });\n      const result = await intelligentSync();\n      setSyncStatus({ syncing: false, lastSync: new Date() });\n      return result;\n    } catch (err: unknown) {\n      console.error('Intelligent sync error:', err);\n      setSyncStatus({ syncing: false, lastSync: syncStatus.lastSync });\n      if (err instanceof Error) {\n        setError(err.message);\n      }\n      return { success: false, conflicts: ['Sync failed due to error'] };\n    }\n  }, [user, syncStatus.lastSync]);\n\n  useEffect(() => {\n    const auth = getAuth();\n    const unsubscribe = auth.onAuthStateChanged((userData: User | null) => {\n      setUser(userData || null);\n\n      // Mark initial auth check as complete\n      if (!authInitializedRef.current) {\n        authInitializedRef.current = true;\n        setInitializing(false);\n      }\n\n      // If user is logged in and not anonymous, defer sync operations\n      if (userData && !userData.isAnonymous) {\n        // Defer sync to not block UI rendering - use requestIdleCallback or fallback\n        const deferSync = () => {\n          // Use debounced sync to prevent multiple rapid syncs\n          if (syncTimeoutRef.current) {\n            clearTimeout(syncTimeoutRef.current);\n          }\n\n          syncTimeoutRef.current = setTimeout(() => {\n            setSyncStatus({ syncing: true, lastSync: null });\n\n            // Handle case where syncDataFromFirebase might not be defined (e.g., in tests)\n            let syncPromise;\n            try {\n              syncPromise = syncDataFromFirebase ? syncDataFromFirebase() : Promise.resolve(false);\n            } catch (error) {\n              console.warn('syncDataFromFirebase is not available:', error);\n              syncPromise = Promise.resolve(false);\n            }\n\n            // Ensure syncPromise is always a Promise\n            if (!syncPromise || typeof syncPromise.then !== 'function') {\n              syncPromise = Promise.resolve(false);\n            }\n\n            syncPromise\n              .then(() => {\n                setSyncStatus({ syncing: false, lastSync: new Date() });\n                // Start periodic sync after initial sync completes\n                if (startPeriodicSync) {\n                  startPeriodicSync();\n                }\n              })\n              .catch((err) => {\n                console.error('Error syncing from Firebase:', err);\n                setSyncStatus({ syncing: false, lastSync: null });\n              })\n              .finally(() => {\n                syncTimeoutRef.current = null;\n              });\n          }, 3000); // Increased delay to 3 seconds to ensure UI is fully loaded first\n        };\n\n        if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {\n          (\n            window as Window & {\n              requestIdleCallback: (callback: () => void, options?: { timeout: number }) => void;\n            }\n          ).requestIdleCallback(deferSync, { timeout: 10000 });\n        } else {\n          // Fallback for browsers without requestIdleCallback - wait longer to allow UI to fully load\n          setTimeout(deferSync, 5000);\n        }\n      } else {\n        // User is logged out or anonymous, stop periodic sync\n        if (stopPeriodicSync) {\n          stopPeriodicSync();\n        }\n      }\n    });\n\n    // Make auth context available globally for middleware\n    (window as Window & { authContext?: { user: User | null } }).authContext = { user: null };\n\n    // Clean up function\n    return () => {\n      if (typeof unsubscribe === 'function') {\n        unsubscribe();\n      }\n      if (syncTimeoutRef.current) {\n        clearTimeout(syncTimeoutRef.current);\n      }\n      // Make sure to stop periodic sync when component unmounts\n      if (stopPeriodicSync) {\n        stopPeriodicSync();\n      }\n      (window as Window & { authContext?: { user: User | null } }).authContext = undefined;\n    };\n  }, []);\n\n  // Update global auth context when user changes\n  useEffect(() => {\n    const globalWindow = window as Window & { authContext?: { user: User | null } };\n    if (globalWindow.authContext) {\n      globalWindow.authContext.user = user;\n    }\n  }, [user]);\n  const value = useMemo(\n    () => ({\n      user,\n      loading,\n      initializing,\n      error,\n      syncStatus,\n      login,\n      loginEmail,\n      loginGoogle,\n      register,\n      updateUser,\n      forgotPassword,\n      convertToRegistered,\n      logout: logoutUser,\n      wipeAllData: wipeAllAppDataAndReload,\n      syncData,\n      intelligentSync: handleIntelligentSync,\n      isAnonymous: user?.isAnonymous || false,\n    }),\n    [\n      user,\n      loading,\n      initializing,\n      error,\n      syncStatus,\n      convertToRegistered,\n      logoutUser,\n      wipeAllAppDataAndReload,\n      syncData,\n      handleIntelligentSync,\n    ]\n  );\n\n  return <AuthContext.Provider value={value} {...props} />;\n}\n\nexport { AuthProvider };\n","import { getAllAvailableGroups } from '@/stores/customGroups';\nimport { importActions } from '@/services/dexieActionImport';\n\nexport interface DataCompletenessReport {\n  isComplete: boolean;\n  missingGroups: string[];\n  corruptedGroups: string[];\n  totalExpectedGroups: number;\n  totalDexieGroups: number;\n  details: {\n    [groupName: string]: {\n      exists: boolean;\n      hasIntensities: boolean;\n      hasLabel: boolean;\n      expectedIntensities: number;\n      actualIntensities: number;\n    };\n  };\n}\n\n/**\n * Check if Dexie contains complete and valid data for a given locale and game mode\n * by comparing against the expected JSON structure\n */\nexport const checkDataCompleteness = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<DataCompletenessReport> => {\n  const report: DataCompletenessReport = {\n    isComplete: false,\n    missingGroups: [],\n    corruptedGroups: [],\n    totalExpectedGroups: 0,\n    totalDexieGroups: 0,\n    details: {},\n  };\n\n  try {\n    // Get expected groups from JSON files\n    let expectedGroups: any = {};\n    try {\n      expectedGroups = await importActions(locale, gameMode);\n    } catch (error) {\n      console.warn(`Could not load expected actions for ${locale}/${gameMode}:`, error);\n      // If we can't load expected data, we can't validate completeness\n      return report;\n    }\n\n    const expectedGroupNames = Object.keys(expectedGroups);\n    report.totalExpectedGroups = expectedGroupNames.length;\n\n    // Get actual groups from Dexie\n    let dexieGroups: any[] = [];\n    try {\n      dexieGroups = await getAllAvailableGroups(locale, gameMode);\n    } catch (error) {\n      console.warn(`Could not load Dexie groups for ${locale}/${gameMode}:`, error);\n      return report;\n    }\n\n    report.totalDexieGroups = dexieGroups.length;\n\n    // Create a map of Dexie groups by name for quick lookup\n    const dexieGroupsMap = new Map(dexieGroups.map((group) => [group.name, group]));\n\n    // Check each expected group\n    for (const groupName of expectedGroupNames) {\n      const expectedGroup = expectedGroups[groupName];\n      const dexieGroup = dexieGroupsMap.get(groupName);\n\n      const groupDetail = {\n        exists: !!dexieGroup,\n        hasIntensities: false,\n        hasLabel: false,\n        expectedIntensities: 0,\n        actualIntensities: 0,\n      };\n\n      if (expectedGroup?.actions) {\n        // Count expected intensities (excluding 'None')\n        const expectedIntensityKeys = Object.keys(expectedGroup.actions).filter(\n          (key) => key !== 'None'\n        );\n        groupDetail.expectedIntensities = expectedIntensityKeys.length;\n      }\n\n      if (dexieGroup) {\n        groupDetail.hasLabel = !!dexieGroup.label;\n        groupDetail.hasIntensities =\n          Array.isArray(dexieGroup.intensities) && dexieGroup.intensities.length > 0;\n        groupDetail.actualIntensities = dexieGroup.intensities?.length || 0;\n\n        // Check if group is corrupted (missing essential data or incorrect intensity count)\n        const isCorrupted =\n          !groupDetail.hasLabel ||\n          !groupDetail.hasIntensities ||\n          (groupDetail.expectedIntensities > 0 &&\n            groupDetail.actualIntensities !== groupDetail.expectedIntensities);\n\n        if (isCorrupted) {\n          report.corruptedGroups.push(groupName);\n        }\n      } else {\n        report.missingGroups.push(groupName);\n      }\n\n      report.details[groupName] = groupDetail;\n    }\n\n    // Check if data is complete (no missing or corrupted groups)\n    report.isComplete =\n      report.missingGroups.length === 0 &&\n      report.corruptedGroups.length === 0 &&\n      report.totalDexieGroups >= report.totalExpectedGroups;\n\n    return report;\n  } catch (error) {\n    console.error('Error in checkDataCompleteness:', error);\n    return report;\n  }\n};\n\n/**\n * Quick check if Dexie data is complete without detailed analysis\n * This is optimized for performance and can be used for frequent checks\n */\nexport const isDexieDataComplete = async (locale = 'en', gameMode = 'online'): Promise<boolean> => {\n  try {\n    // Quick check: compare group counts first\n    const [expectedGroups, dexieGroups] = await Promise.all([\n      importActions(locale, gameMode).catch(() => ({})),\n      getAllAvailableGroups(locale, gameMode).catch(() => []),\n    ]);\n\n    const expectedCount = Object.keys(expectedGroups).length;\n    const dexieCount = dexieGroups.length;\n\n    // If counts don't match, definitely incomplete\n    if (dexieCount < expectedCount) {\n      return false;\n    }\n\n    // If counts match, do a quick validation of a few key groups\n    const expectedGroupNames = Object.keys(expectedGroups);\n    const dexieGroupNames = new Set(dexieGroups.map((g) => g.name));\n\n    // Check if all expected groups exist in Dexie\n    for (const groupName of expectedGroupNames) {\n      if (!dexieGroupNames.has(groupName)) {\n        return false;\n      }\n    }\n\n    // Basic validation passed\n    return true;\n  } catch (error) {\n    console.error('Error in isDexieDataComplete:', error);\n    return false;\n  }\n};\n\n/**\n * Get a summary of data completeness for debugging and monitoring\n */\nexport const getDataCompletenessSummary = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<string> => {\n  try {\n    const report = await checkDataCompleteness(locale, gameMode);\n\n    let summary = `Data Completeness for ${locale}/${gameMode}:\\n`;\n    summary += `Overall: ${report.isComplete ? 'COMPLETE' : 'INCOMPLETE'}\\n`;\n    summary += `Expected groups: ${report.totalExpectedGroups}\\n`;\n    summary += `Dexie groups: ${report.totalDexieGroups}\\n`;\n\n    if (report.missingGroups.length > 0) {\n      summary += `Missing groups: ${report.missingGroups.join(', ')}\\n`;\n    }\n\n    if (report.corruptedGroups.length > 0) {\n      summary += `Corrupted groups: ${report.corruptedGroups.join(', ')}\\n`;\n    }\n\n    return summary;\n  } catch (error) {\n    return `Error generating completeness summary: ${error}`;\n  }\n};\n","import i18next, { InitOptions } from 'i18next';\n\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport { initReactI18next } from 'react-i18next';\nimport resourcesToBackend from 'i18next-resources-to-backend';\n\n// Configuration constants\nconst LANGUAGE_PRELOAD_TIMEOUT = 5000; // 5 second timeout for requestIdleCallback\n\nconst i18nOptions: InitOptions = {\n  fallbackLng: 'en',\n  supportedLngs: ['en', 'es', 'fr', 'zh', 'hi'],\n  ns: ['translation', 'errors'],\n  defaultNS: 'translation',\n  // debug: process.env.NODE_ENV === 'development',\n  interpolation: {\n    escapeValue: false, // React already safes from XSS\n  },\n  react: {\n    useSuspense: false, // Disable suspense to prevent issues with language switching\n  },\n  detection: {\n    order: ['querystring', 'cookie', 'localStorage', 'navigator', 'htmlTag'],\n    caches: ['localStorage', 'cookie'],\n  },\n  // Performance optimizations\n  load: 'currentOnly', // Only load current language initially\n  preload: false, // Don't preload all languages\n  cleanCode: true, // Clean language codes\n};\n\n// Lazy loading function for additional resources\nconst lazyLoadTranslations = (language: string, namespace: string) => {\n  // Only load specific locale files when actually needed\n  if (namespace === 'translation') {\n    return import(`./locales/${language}/translation.json`);\n  }\n\n  // For game-specific translations, load them on-demand\n  return import(`./locales/${language}/${namespace}.json`).catch(() => {\n    // Fallback to English if translation doesn't exist\n    return import(`./locales/en/${namespace}.json`);\n  });\n};\n\nconst i18n = i18next\n  .use(initReactI18next)\n  .use(LanguageDetector)\n  .use(resourcesToBackend(lazyLoadTranslations));\n\n// Initialize i18n with optimized background loading\ni18n\n  .init(i18nOptions)\n  .then(() => {\n    // Defer preloading other languages until after migration is handled\n    const scheduleLanguagePreloading = () => {\n      const currentLang = i18n.language;\n      const commonLangs = ['en', 'es', 'fr'].filter((lang) => lang !== currentLang);\n\n      // Use requestIdleCallback for better performance\n      if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {\n        window.requestIdleCallback(\n          () => {\n            commonLangs.forEach((lang) => {\n              if (\n                i18n?.options?.supportedLngs &&\n                Array.isArray(i18n.options.supportedLngs) &&\n                i18n.options.supportedLngs.includes(lang)\n              ) {\n                i18n.loadLanguages(lang).catch(console.warn);\n              }\n            });\n          },\n          { timeout: LANGUAGE_PRELOAD_TIMEOUT }\n        ); // Timeout for requestIdleCallback\n      } else {\n        // Fallback with longer delay to allow app to become interactive first\n        setTimeout(() => {\n          commonLangs.forEach((lang) => {\n            if (\n              i18n?.options?.supportedLngs &&\n              Array.isArray(i18n.options.supportedLngs) &&\n              i18n.options.supportedLngs.includes(lang)\n            ) {\n              i18n.loadLanguages(lang).catch(console.warn);\n            }\n          });\n        }, LANGUAGE_PRELOAD_TIMEOUT); // Load other languages after timeout\n      }\n    };\n\n    // Delay language preloading to prioritize app startup\n    scheduleLanguagePreloading();\n  })\n  .catch(console.error);\n\nexport default i18n;\n","import { isDexieDataComplete } from '@/services/dataCompletenessChecker';\nimport i18n from '@/i18n';\n\nexport interface MigrationHealthReport {\n  isHealthy: boolean;\n  requiresRecovery: boolean;\n  lastValidation: Date;\n  failureCount: number;\n  details: {\n    migrationStatus: 'completed' | 'failed' | 'incomplete';\n    dataComplete: boolean;\n    locale: string;\n    gameMode: string;\n    errorMessage?: string;\n  };\n}\n\ninterface MigrationHealthState {\n  [localeGameMode: string]: {\n    failureCount: number;\n    lastValidation: string; // ISO string for JSON serialization\n    consecutiveFailures: number;\n  };\n}\n\nconst HEALTH_CHECK_KEY = 'blitzed-out-migration-health';\nconst MAX_RETRY_ATTEMPTS = 3;\nconst MIN_VALIDATION_INTERVAL = 5 * 60 * 1000; // 5 minutes\n\n/**\n * Get stored health state from localStorage\n */\nconst getHealthState = (): MigrationHealthState => {\n  try {\n    const stored = localStorage.getItem(HEALTH_CHECK_KEY);\n    return stored ? JSON.parse(stored) : {};\n  } catch (error) {\n    console.warn('Failed to load migration health state:', error);\n    return {};\n  }\n};\n\n/**\n * Update health state in localStorage\n */\nconst updateHealthState = (\n  locale: string,\n  gameMode: string,\n  update: Partial<MigrationHealthState[string]>\n): void => {\n  try {\n    const key = `${locale}-${gameMode}`;\n    const state = getHealthState();\n\n    state[key] = {\n      ...{\n        failureCount: 0,\n        lastValidation: new Date().toISOString(),\n        consecutiveFailures: 0,\n      },\n      ...state[key],\n      ...update,\n    };\n\n    localStorage.setItem(HEALTH_CHECK_KEY, JSON.stringify(state));\n  } catch (error) {\n    console.warn('Failed to update migration health state:', error);\n  }\n};\n\n/**\n * Check if migration is healthy for the given locale and game mode\n * This performs a comprehensive check of migration status and data integrity\n */\nexport const checkMigrationHealth = async (\n  locale?: string,\n  gameMode: string = 'online'\n): Promise<MigrationHealthReport> => {\n  const targetLocale = locale || i18n.resolvedLanguage || i18n.language || 'en';\n  const key = `${targetLocale}-${gameMode}`;\n  const healthState = getHealthState();\n  const storedState = healthState[key] || {\n    failureCount: 0,\n    lastValidation: new Date(0).toISOString(),\n    consecutiveFailures: 0,\n  };\n\n  // Ensure lastValidation is a Date object for calculations\n  const currentState = {\n    ...storedState,\n    lastValidation: new Date(storedState.lastValidation),\n  };\n\n  const report: MigrationHealthReport = {\n    isHealthy: false,\n    requiresRecovery: false,\n    lastValidation: currentState.lastValidation,\n    failureCount: currentState.failureCount,\n    details: {\n      migrationStatus: 'incomplete',\n      dataComplete: false,\n      locale: targetLocale,\n      gameMode,\n    },\n  };\n\n  try {\n    // Skip validation if we just validated recently (unless we have failures)\n    const timeSinceLastValidation = Date.now() - currentState.lastValidation.getTime();\n    if (\n      timeSinceLastValidation < MIN_VALIDATION_INTERVAL &&\n      currentState.consecutiveFailures === 0\n    ) {\n      // Return cached result if we validated recently and had no failures\n      report.isHealthy = true;\n      report.details.migrationStatus = 'completed';\n      report.details.dataComplete = true;\n      return report;\n    }\n\n    // Check if data is complete in Dexie\n    const dataComplete = await isDexieDataComplete(targetLocale, gameMode);\n    report.details.dataComplete = dataComplete;\n\n    if (dataComplete) {\n      // Data is complete, migration is healthy\n      report.isHealthy = true;\n      report.details.migrationStatus = 'completed';\n\n      // Reset failure counters on success\n      updateHealthState(targetLocale, gameMode, {\n        consecutiveFailures: 0,\n        lastValidation: new Date().toISOString(),\n      });\n    } else {\n      // Data is incomplete, check migration status\n      const migrationStatus = checkMigrationStatusFromStorage();\n      report.details.migrationStatus = migrationStatus;\n\n      // Increment failure count\n      const newFailureCount = currentState.failureCount + 1;\n      const newConsecutiveFailures = currentState.consecutiveFailures + 1;\n\n      updateHealthState(targetLocale, gameMode, {\n        failureCount: newFailureCount,\n        consecutiveFailures: newConsecutiveFailures,\n        lastValidation: new Date().toISOString(),\n      });\n\n      report.failureCount = newFailureCount;\n      report.requiresRecovery = newConsecutiveFailures >= MAX_RETRY_ATTEMPTS;\n\n      if (report.requiresRecovery) {\n        report.details.errorMessage = `Migration failed ${newConsecutiveFailures} consecutive times. Data incomplete for ${targetLocale}/${gameMode}.`;\n      }\n    }\n\n    return report;\n  } catch (error) {\n    console.error('Migration health check failed:', error);\n\n    // Increment failure count\n    const newFailureCount = currentState.failureCount + 1;\n    const newConsecutiveFailures = currentState.consecutiveFailures + 1;\n\n    updateHealthState(targetLocale, gameMode, {\n      failureCount: newFailureCount,\n      consecutiveFailures: newConsecutiveFailures,\n      lastValidation: new Date().toISOString(),\n    });\n\n    report.failureCount = newFailureCount;\n    report.requiresRecovery = newConsecutiveFailures >= MAX_RETRY_ATTEMPTS;\n    report.details.migrationStatus = 'failed';\n    report.details.errorMessage = `Health check failed: ${error instanceof Error ? error.message : String(error)}`;\n\n    return report;\n  }\n};\n\n/**\n * Check migration status from localStorage\n */\nconst checkMigrationStatusFromStorage = (): 'completed' | 'failed' | 'incomplete' => {\n  try {\n    // Check main migration status\n    const mainStatus = localStorage.getItem('blitzed-out-action-groups-migration');\n    if (mainStatus) {\n      const parsed = JSON.parse(mainStatus);\n      if (parsed.completed && parsed.version === '2.1.1') {\n        return 'completed';\n      }\n    }\n\n    // Check background migration status\n    const bgStatus = localStorage.getItem('blitzed-out-background-migration');\n    if (bgStatus) {\n      const parsed = JSON.parse(bgStatus);\n      if (parsed.completedLanguages && parsed.completedLanguages.length > 0) {\n        return 'completed';\n      }\n    }\n\n    return 'incomplete';\n  } catch (error) {\n    console.warn('Failed to check migration status from storage:', error);\n    return 'incomplete';\n  }\n};\n\n/**\n * Attempt to recover from a failed migration\n * This clears migration locks and status, forcing a fresh migration attempt\n */\nexport const recoverFromFailedMigration = async (\n  locale?: string,\n  gameMode: string = 'online'\n): Promise<boolean> => {\n  const targetLocale = locale || i18n.resolvedLanguage || i18n.language || 'en';\n\n  try {\n    // Clear migration locks and status to force fresh migration\n    const keysToRemove = [\n      'blitzed-out-migration-in-progress',\n      'blitzed-out-current-language-migration',\n      'blitzed-out-background-migration-in-progress',\n    ];\n\n    let hasErrors = false;\n    keysToRemove.forEach((key) => {\n      try {\n        localStorage.removeItem(key);\n      } catch (error) {\n        console.warn(`Failed to remove ${key}:`, error);\n        hasErrors = true;\n      }\n    });\n\n    // Reset health state for this locale/gameMode\n    try {\n      updateHealthState(targetLocale, gameMode, {\n        failureCount: 0,\n        consecutiveFailures: 0,\n        lastValidation: new Date(0).toISOString(), // Force revalidation\n      });\n    } catch (error) {\n      console.warn('Failed to update health state:', error);\n      hasErrors = true;\n    }\n\n    if (hasErrors) {\n      return false;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Migration recovery failed:', error);\n    return false;\n  }\n};\n\n/**\n * Force a complete migration reset (nuclear option)\n * This removes all migration status and forces a complete re-migration\n */\nexport const forceCompleteMigrationReset = (): boolean => {\n  try {\n    const keysToRemove = [\n      'blitzed-out-action-groups-migration',\n      'blitzed-out-background-migration',\n      'blitzed-out-migration-in-progress',\n      'blitzed-out-current-language-migration',\n      'blitzed-out-background-migration-in-progress',\n      HEALTH_CHECK_KEY,\n    ];\n\n    keysToRemove.forEach((key) => {\n      try {\n        localStorage.removeItem(key);\n      } catch (error) {\n        console.warn(`Failed to remove ${key}:`, error);\n      }\n    });\n\n    return true;\n  } catch (error) {\n    console.error('Complete migration reset failed:', error);\n    return false;\n  }\n};\n\n/**\n * Get a summary of migration health across all locales and game modes\n */\nexport const getMigrationHealthSummary = async (): Promise<string> => {\n  try {\n    const locales = ['en', 'es', 'fr', 'zh', 'hi'];\n    const gameModes = ['online', 'local'];\n\n    let summary = 'Migration Health Summary:\\n';\n    let totalChecked = 0;\n    let totalHealthy = 0;\n    let totalRequireRecovery = 0;\n\n    for (const locale of locales) {\n      for (const gameMode of gameModes) {\n        try {\n          const report = await checkMigrationHealth(locale, gameMode);\n          totalChecked++;\n\n          if (report.isHealthy) {\n            totalHealthy++;\n          }\n\n          if (report.requiresRecovery) {\n            totalRequireRecovery++;\n            summary += `❌ ${locale}/${gameMode}: REQUIRES RECOVERY (${report.failureCount} failures)\\n`;\n          } else if (!report.isHealthy) {\n            summary += `⚠️  ${locale}/${gameMode}: UNHEALTHY (${report.failureCount} failures)\\n`;\n          }\n        } catch (error) {\n          totalChecked++;\n          summary += `💥 ${locale}/${gameMode}: CHECK FAILED - ${error}\\n`;\n        }\n      }\n    }\n\n    summary += `\\nOverall: ${totalHealthy}/${totalChecked} healthy`;\n    if (totalRequireRecovery > 0) {\n      summary += `, ${totalRequireRecovery} require recovery`;\n    }\n\n    return summary;\n  } catch (error) {\n    return `Error generating migration health summary: ${error}`;\n  }\n};\n","import React, { createContext, useCallback, useContext, useEffect, useRef, useState } from 'react';\nimport {\n  checkMigrationHealth,\n  recoverFromFailedMigration,\n} from '@/services/migrationHealthChecker';\nimport { useTranslation } from 'react-i18next';\n\n/**\n * Context value interface for migration state management.\n * Provides centralized migration control and status tracking.\n */\ninterface MigrationContextValue {\n  /** Whether all supported languages have been migrated */\n  isMigrationCompleted: boolean;\n  /** Whether any migration operation is currently in progress */\n  isMigrationInProgress: boolean;\n  /** Whether the current language has been successfully migrated */\n  currentLanguageMigrated: boolean;\n  /** Any error that occurred during migration (non-blocking) */\n  error: string | null;\n  /** Whether the migration system is healthy and data is complete */\n  isHealthy: boolean;\n  /** Whether automatic recovery has been attempted */\n  recoveryAttempted: boolean;\n  /** Trigger migration for the current language */\n  triggerMigration: () => Promise<void>;\n  /** Ensure a specific language is migrated */\n  ensureLanguageMigrated: (locale?: string) => Promise<boolean>;\n  /** Force recovery from failed migration */\n  forceRecovery: () => Promise<void>;\n}\n\nconst MigrationContext = createContext<MigrationContextValue | undefined>(undefined);\n\n/**\n * Hook to access migration context.\n * Must be used within a MigrationProvider.\n *\n * @throws {Error} When used outside of MigrationProvider\n * @returns Migration context value with state and control functions\n */\n// eslint-disable-next-line react-refresh/only-export-components\nexport function useMigration() {\n  const context = useContext(MigrationContext);\n  if (context === undefined) {\n    throw new Error('useMigration must be used within a MigrationProvider');\n  }\n  return context;\n}\n\ninterface MigrationProviderProps {\n  children: React.ReactNode;\n}\n\n/**\n * Migration context provider that manages language file migration state.\n * Handles automatic migration on language changes with intelligent debouncing.\n *\n * ## Migration Lifecycle:\n * 1. **Initialization**: Checks migration status for current language\n * 2. **Language Change Detection**: Listens for i18next language changes\n * 3. **Debounced Migration**: Prevents duplicate migrations during rapid language switches\n * 4. **Status Updates**: Broadcasts migration state to all consuming components\n * 5. **Error Handling**: Graceful fallbacks when migration fails\n *\n * ## Key Features:\n * - **Lazy Loading**: Migration service loaded only when needed\n * - **Debouncing**: 300ms debounce prevents unnecessary migration attempts\n * - **Automatic Triggers**: Migrates new languages automatically\n * - **Status Tracking**: Comprehensive state management for all components\n * - **Error Resilience**: App continues functioning even if migration fails\n *\n * ## Usage:\n * Wrap your app with MigrationProvider at the root level, above all other providers\n * that might need access to migrated data.\n *\n * @example\n * ```tsx\n * function App() {\n *   return (\n *     <MigrationProvider>\n *       <AuthProvider>\n *         <Router>\n *           <AppRoutes />\n *         </Router>\n *       </AuthProvider>\n *     </MigrationProvider>\n *   );\n * }\n * ```\n */\nexport function MigrationProvider({ children }: MigrationProviderProps) {\n  const { i18n } = useTranslation();\n  const [isMigrationInProgress, setIsMigrationInProgress] = useState(false);\n  const [currentLanguageMigrated, setCurrentLanguageMigrated] = useState(false);\n  const [isMigrationCompleted, setIsMigrationCompleted] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [isHealthy, setIsHealthy] = useState(false);\n  const [recoveryAttempted, setRecoveryAttempted] = useState(false);\n  const [languageChangeTimeout, setLanguageChangeTimeout] = useState<NodeJS.Timeout | null>(null);\n  const migrationAttemptedRef = useRef<Set<string>>(new Set());\n\n  // Lazy load migration service to avoid blocking main bundle\n  const loadMigrationService = useCallback(async () => {\n    const migrationService = await import('@/services/migrationService');\n    return migrationService;\n  }, []);\n\n  // Check migration status and health on mount\n  useEffect(() => {\n    const checkMigrationStatus = async () => {\n      try {\n        const migrationService = await loadMigrationService();\n        const currentLocale = i18n.language || 'en';\n\n        // First check if migration status is corrupted\n        const integrityOk = await migrationService.verifyMigrationIntegrity(\n          currentLocale,\n          'online'\n        );\n\n        if (!integrityOk) {\n          migrationService.fixMigrationStatusCorruption();\n          // After reset, re-check status\n          setCurrentLanguageMigrated(false);\n          setIsMigrationCompleted(false);\n          return;\n        }\n\n        const isCurrentMigrated =\n          migrationService.isCurrentLanguageMigrationCompleted(currentLocale);\n        const isAllMigrated = migrationService.isMigrationCompleted();\n\n        setCurrentLanguageMigrated(isCurrentMigrated);\n        setIsMigrationCompleted(isAllMigrated);\n\n        // Perform health check if migration appears complete but we want to verify data integrity\n        if (isCurrentMigrated) {\n          const healthReport = await checkMigrationHealth(currentLocale, 'online');\n          setIsHealthy(healthReport.isHealthy);\n\n          // If migration claims to be complete but health check fails, attempt recovery\n          if (!healthReport.isHealthy && healthReport.requiresRecovery && !recoveryAttempted) {\n            setRecoveryAttempted(true);\n            const recovered = await recoverFromFailedMigration(currentLocale, 'online');\n\n            if (recovered) {\n              // Trigger a fresh migration attempt after recovery\n              setCurrentLanguageMigrated(false);\n              setError(null);\n            } else {\n              setError('Migration recovery failed. Some features may not work correctly.');\n            }\n          }\n        }\n      } catch (error) {\n        console.warn('Failed to check migration status:', false, error);\n        setError('Failed to check migration status');\n        setIsHealthy(false);\n      }\n    };\n\n    // Only check status after i18n is initialized\n    if (i18n.language && i18n.language !== 'undefined') {\n      checkMigrationStatus();\n    }\n  }, [i18n.language, loadMigrationService, recoveryAttempted]);\n\n  const forceRecovery = useCallback(async () => {\n    const currentLocale = i18n.language || 'en';\n\n    try {\n      setIsMigrationInProgress(true);\n      setError(null);\n\n      const recovered = await recoverFromFailedMigration(currentLocale, 'online');\n\n      if (recovered) {\n        setRecoveryAttempted(true);\n        setCurrentLanguageMigrated(false);\n        setIsHealthy(false);\n\n        // Trigger fresh migration after recovery\n        const migrationService = await loadMigrationService();\n        const success = await migrationService.runMigrationIfNeeded();\n\n        if (success) {\n          await migrationService.cleanupDuplicatesIfNeeded();\n          setCurrentLanguageMigrated(true);\n          setIsMigrationCompleted(migrationService.isMigrationCompleted());\n\n          // Re-check health after successful migration\n          const healthReport = await checkMigrationHealth(currentLocale, 'online');\n          setIsHealthy(healthReport.isHealthy);\n        }\n      } else {\n        setError('Force recovery failed. Please try refreshing the page.');\n      }\n    } catch (error) {\n      console.error('Force recovery failed:', error);\n      setError('Force recovery failed. Please try refreshing the page.');\n    } finally {\n      setIsMigrationInProgress(false);\n    }\n  }, [i18n.language, loadMigrationService]);\n\n  const triggerMigration = useCallback(async () => {\n    if (isMigrationInProgress) return;\n\n    setIsMigrationInProgress(true);\n    setError(null);\n\n    try {\n      // Lazy load sync recovery service\n      const { runSyncRecovery } = await import('@/services/syncRecoveryService');\n      await runSyncRecovery();\n\n      const migrationService = await loadMigrationService();\n      const success = await migrationService.runMigrationIfNeeded();\n\n      if (success) {\n        // Clean up any duplicates\n        await migrationService.cleanupDuplicatesIfNeeded();\n\n        setCurrentLanguageMigrated(true);\n        setIsMigrationCompleted(migrationService.isMigrationCompleted());\n\n        // Perform health check after successful migration\n        const currentLocale = i18n.language || 'en';\n        const healthReport = await checkMigrationHealth(currentLocale, 'online');\n        setIsHealthy(healthReport.isHealthy);\n\n        // If health check fails immediately after migration, something is wrong\n        if (!healthReport.isHealthy) {\n          setError(\n            'Migration completed but data validation failed. Some features may not work correctly.'\n          );\n        }\n      } else {\n        setError('Migration failed but app will continue with existing data');\n        setIsHealthy(false);\n      }\n    } catch (error) {\n      console.error('Migration failed:', error);\n      setError('Migration failed but app will continue with existing data');\n      setIsHealthy(false);\n    } finally {\n      setIsMigrationInProgress(false);\n    }\n  }, [isMigrationInProgress, loadMigrationService, i18n.language]);\n\n  // Debounced language change handler\n  const handleLanguageChange = useCallback(\n    (newLanguage: string) => {\n      // Clear any existing timeout\n      if (languageChangeTimeout) {\n        clearTimeout(languageChangeTimeout);\n      }\n\n      // Debounce language changes by 300ms to handle rapid switches\n      const timeout = setTimeout(async () => {\n        try {\n          const migrationService = await loadMigrationService();\n\n          // Check if this language is already migrated\n          if (migrationService.isCurrentLanguageMigrationCompleted(newLanguage)) {\n            setCurrentLanguageMigrated(true);\n            return;\n          }\n\n          // Trigger migration for the new language\n          setIsMigrationInProgress(true);\n          setError(null);\n\n          const success = await migrationService.ensureLanguageMigrated(newLanguage);\n\n          if (success) {\n            setCurrentLanguageMigrated(true);\n            // Update overall migration status\n            setIsMigrationCompleted(migrationService.isMigrationCompleted());\n          } else {\n            setError('Migration failed but app will continue with existing data');\n          }\n        } catch (err) {\n          console.error('Error during language migration:', err);\n          setError('Migration failed but app will continue with existing data');\n        } finally {\n          setIsMigrationInProgress(false);\n        }\n      }, 300);\n\n      setLanguageChangeTimeout(timeout);\n    },\n    [languageChangeTimeout, loadMigrationService]\n  );\n\n  const ensureLanguageMigrated = useCallback(\n    async (locale?: string): Promise<boolean> => {\n      const targetLocale = locale || i18n.language || 'en';\n\n      try {\n        const migrationService = await loadMigrationService();\n\n        // Check if already migrated\n        if (migrationService.isCurrentLanguageMigrationCompleted(targetLocale)) {\n          setCurrentLanguageMigrated(true);\n          return true;\n        }\n\n        // Trigger migration if needed\n        setIsMigrationInProgress(true);\n        const success = await migrationService.ensureLanguageMigrated(targetLocale);\n\n        if (success) {\n          setCurrentLanguageMigrated(true);\n        }\n\n        return success;\n      } catch (error) {\n        console.error(`Failed to ensure ${targetLocale} migration:`, error);\n        return false;\n      } finally {\n        setIsMigrationInProgress(false);\n      }\n    },\n    [i18n.language, loadMigrationService]\n  );\n\n  // Listen for i18next language changes\n  useEffect(() => {\n    if (!i18n.language || i18n.language === 'undefined') return;\n\n    // Set up language change listener\n    const languageChangedHandler = (lng: string) => {\n      handleLanguageChange(lng);\n    };\n\n    // Subscribe to language change events\n    i18n.on('languageChanged', languageChangedHandler);\n\n    // Initial migration check for current language\n    const checkInitialLanguage = async () => {\n      try {\n        const migrationService = await loadMigrationService();\n        const currentLocale = i18n.language || 'en';\n\n        const isCompleted = migrationService.isCurrentLanguageMigrationCompleted(currentLocale);\n        setCurrentLanguageMigrated(isCompleted);\n\n        // SAFETY: Only trigger migration if not already in progress, not completed, and not attempted\n        const migrationKey = `${currentLocale}-initial`;\n        if (\n          !isCompleted &&\n          !isMigrationInProgress &&\n          !migrationAttemptedRef.current.has(migrationKey)\n        ) {\n          // Mark as attempted to prevent React Strict Mode double-invoke\n          migrationAttemptedRef.current.add(migrationKey);\n\n          // Set in progress IMMEDIATELY to prevent infinite loop\n          setIsMigrationInProgress(true);\n\n          // Use setTimeout to break out of the current execution cycle\n          setTimeout(async () => {\n            try {\n              const migrationService = await loadMigrationService();\n              const success = await migrationService.ensureLanguageMigrated(currentLocale);\n\n              if (success) {\n                setCurrentLanguageMigrated(true);\n                setIsMigrationCompleted(migrationService.isMigrationCompleted());\n              } else {\n                setError('Migration failed but app will continue with existing data');\n                // Remove from attempted set if failed so it can be retried\n                migrationAttemptedRef.current.delete(migrationKey);\n              }\n            } catch (err) {\n              console.error('Error during migration execution:', err);\n              setError('Migration failed but app will continue with existing data');\n              // Remove from attempted set if failed so it can be retried\n              migrationAttemptedRef.current.delete(migrationKey);\n            } finally {\n              setIsMigrationInProgress(false);\n            }\n          }, 0);\n        }\n      } catch (err) {\n        console.error('Error during initial migration check:', err);\n        setIsMigrationInProgress(false);\n      }\n    };\n\n    checkInitialLanguage();\n\n    // Cleanup subscription on unmount\n    return () => {\n      i18n.off('languageChanged', languageChangedHandler);\n      if (languageChangeTimeout) {\n        clearTimeout(languageChangeTimeout);\n      }\n    };\n  }, [\n    i18n,\n    handleLanguageChange,\n    isMigrationInProgress,\n    languageChangeTimeout,\n    loadMigrationService,\n  ]);\n\n  const value: MigrationContextValue = {\n    isMigrationCompleted,\n    isMigrationInProgress,\n    currentLanguageMigrated,\n    error,\n    isHealthy,\n    recoveryAttempted,\n    triggerMigration,\n    ensureLanguageMigrated,\n    forceRecovery,\n  };\n\n  return <MigrationContext.Provider value={value}>{children}</MigrationContext.Provider>;\n}\n","import { create } from 'zustand';\nimport { ScheduleItem } from '@/context/schedule';\nimport dayjs from 'dayjs';\n\n// Performance tracking and caching\ninterface ScheduleCache {\n  upcomingSchedule: { data: ScheduleItem[]; timestamp: number; limit: number };\n  roomSchedule: Record<string, { data: ScheduleItem[]; timestamp: number }>;\n}\n\ninterface PerformanceMetrics {\n  lastUpdateTime: number;\n  updateCount: number;\n  cacheHitRate: number;\n}\n\ninterface ScheduleStore {\n  // State\n  schedule: ScheduleItem[];\n  loading: boolean;\n  error: string | null;\n  _cache: ScheduleCache;\n  _performanceMetrics: PerformanceMetrics;\n  _pendingUpdates: ScheduleItem[];\n  _batchTimeout: NodeJS.Timeout | null;\n\n  // Actions\n  loadSchedule: (schedule: ScheduleItem[]) => void;\n  addScheduleItem: (item: ScheduleItem) => void;\n  removeScheduleItem: (id: string) => void;\n  clearSchedule: () => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n\n  // Performance optimized actions\n  batchAddScheduleItems: (items: ScheduleItem[]) => void;\n  flushPendingScheduleUpdates: () => void;\n  invalidateCache: () => void;\n\n  // Selectors with caching\n  getUpcomingSchedule: (limit?: number) => ScheduleItem[];\n  getScheduleByRoom: (room: string) => ScheduleItem[];\n  getPerformanceMetrics: () => PerformanceMetrics;\n}\n\n// Cache timeout for schedule data (5 minutes)\nconst CACHE_TIMEOUT = 5 * 60 * 1000;\nconst SCHEDULE_BATCH_DELAY = 100; // 100ms debounce for schedule updates\n\nexport const useScheduleStore = create<ScheduleStore>((set, get) => ({\n  // State\n  schedule: [],\n  loading: false,\n  error: null,\n  _cache: {\n    upcomingSchedule: { data: [], timestamp: 0, limit: 0 },\n    roomSchedule: {},\n  },\n  _performanceMetrics: {\n    lastUpdateTime: Date.now(),\n    updateCount: 0,\n    cacheHitRate: 0,\n  },\n  _pendingUpdates: [],\n  _batchTimeout: null,\n\n  // Actions\n  loadSchedule: (schedule) => {\n    const now = Date.now();\n    set((state) => {\n      const newUpdateCount = state._performanceMetrics.updateCount + 1;\n\n      return {\n        schedule,\n        loading: false,\n        error: null,\n        _performanceMetrics: {\n          lastUpdateTime: now,\n          updateCount: newUpdateCount,\n          cacheHitRate: state._performanceMetrics.cacheHitRate,\n        },\n      };\n    });\n\n    // Invalidate cache when new data is loaded\n    get().invalidateCache();\n  },\n\n  addScheduleItem: (item) => {\n    const state = get();\n\n    // Add item to pending updates\n    set((prevState) => ({\n      _pendingUpdates: [...prevState._pendingUpdates, item],\n    }));\n\n    // Clear existing timeout and set new one\n    if (state._batchTimeout) {\n      clearTimeout(state._batchTimeout);\n    }\n\n    const newTimeout = setTimeout(() => {\n      get().flushPendingScheduleUpdates();\n    }, SCHEDULE_BATCH_DELAY);\n\n    set(() => ({ _batchTimeout: newTimeout }));\n  },\n\n  batchAddScheduleItems: (items) =>\n    set((state) => {\n      const newSchedule = [...state.schedule, ...items];\n      const now = Date.now();\n      const newUpdateCount = state._performanceMetrics.updateCount + 1;\n\n      return {\n        schedule: newSchedule,\n        _performanceMetrics: {\n          lastUpdateTime: now,\n          updateCount: newUpdateCount,\n          cacheHitRate: state._performanceMetrics.cacheHitRate,\n        },\n      };\n    }),\n\n  flushPendingScheduleUpdates: () => {\n    const state = get();\n    if (state._pendingUpdates.length === 0) return;\n\n    // Clear the timeout as we're flushing now\n    if (state._batchTimeout) {\n      clearTimeout(state._batchTimeout);\n    }\n\n    state.batchAddScheduleItems(state._pendingUpdates);\n    set(() => ({\n      _pendingUpdates: [],\n      _batchTimeout: null,\n    }));\n    state.invalidateCache();\n  },\n\n  removeScheduleItem: (id) => {\n    set((state) => ({\n      schedule: state.schedule.filter((item) => item.id !== id),\n    }));\n    get().invalidateCache();\n  },\n\n  clearSchedule: () => {\n    const state = get();\n\n    // Clear any pending timeout\n    if (state._batchTimeout) {\n      clearTimeout(state._batchTimeout);\n    }\n\n    set(() => ({\n      schedule: [],\n      loading: false,\n      error: null,\n      _pendingUpdates: [],\n      _batchTimeout: null,\n    }));\n    get().invalidateCache();\n  },\n\n  invalidateCache: () =>\n    set(() => ({\n      _cache: {\n        upcomingSchedule: { data: [], timestamp: 0, limit: 0 },\n        roomSchedule: {},\n      },\n    })),\n\n  setLoading: (loading) => set(() => ({ loading })),\n\n  setError: (error) => set(() => ({ error, loading: false })),\n\n  // Selectors with caching\n  getUpcomingSchedule: (limit = 10) => {\n    const state = get();\n    const now = Date.now();\n\n    // Check cache validity\n    const cache = state._cache.upcomingSchedule;\n    const isCacheValid =\n      cache.timestamp > 0 && now - cache.timestamp < CACHE_TIMEOUT && cache.limit >= limit;\n\n    if (isCacheValid) {\n      // Update cache hit rate\n      const totalRequests = state._performanceMetrics.updateCount + 1;\n      const currentHits = state._performanceMetrics.cacheHitRate * (totalRequests - 1);\n      const newHitRate = (currentHits + 1) / totalRequests;\n\n      set((prevState) => ({\n        _performanceMetrics: {\n          ...prevState._performanceMetrics,\n          cacheHitRate: newHitRate,\n        },\n      }));\n\n      return cache.data.slice(0, limit);\n    }\n\n    // Calculate and cache result\n    const currentTime = dayjs();\n    const upcoming = state.schedule\n      .filter((item) => item.dateTime.isAfter(currentTime))\n      .sort((a, b) => a.dateTime.valueOf() - b.dateTime.valueOf())\n      .slice(0, Math.max(limit, 20)); // Cache extra items for future requests\n\n    // Update cache\n    set((prevState) => ({\n      _cache: {\n        ...prevState._cache,\n        upcomingSchedule: {\n          data: upcoming,\n          timestamp: now,\n          limit: Math.max(limit, 20),\n        },\n      },\n    }));\n\n    return upcoming.slice(0, limit);\n  },\n\n  getScheduleByRoom: (room) => {\n    const state = get();\n    const now = Date.now();\n\n    // Check cache validity\n    const cache = state._cache.roomSchedule[room];\n    const isCacheValid = cache && cache.timestamp > 0 && now - cache.timestamp < CACHE_TIMEOUT;\n\n    if (isCacheValid) {\n      // Update cache hit rate\n      const totalRequests = state._performanceMetrics.updateCount + 1;\n      const currentHits = state._performanceMetrics.cacheHitRate * (totalRequests - 1);\n      const newHitRate = (currentHits + 1) / totalRequests;\n\n      set((prevState) => ({\n        _performanceMetrics: {\n          ...prevState._performanceMetrics,\n          cacheHitRate: newHitRate,\n        },\n      }));\n\n      return cache.data;\n    }\n\n    // Calculate and cache result\n    const roomSchedule = state.schedule.filter((item) => item.room === room);\n\n    // Update cache\n    set((prevState) => ({\n      _cache: {\n        ...prevState._cache,\n        roomSchedule: {\n          ...prevState._cache.roomSchedule,\n          [room]: {\n            data: roomSchedule,\n            timestamp: now,\n          },\n        },\n      },\n    }));\n\n    return roomSchedule;\n  },\n\n  getPerformanceMetrics: () => {\n    const state = get();\n    return state._performanceMetrics;\n  },\n}));\n\n// Compatibility selectors for optimized subscriptions\nexport const useScheduleItems = () => useScheduleStore((state) => state.schedule);\nexport const useScheduleLoading = () => useScheduleStore((state) => state.loading);\nexport const useScheduleError = () => useScheduleStore((state) => state.error);\nexport const useUpcomingSchedule = (limit?: number) =>\n  useScheduleStore((state) => state.getUpcomingSchedule(limit));\n\n// Performance-optimized hooks\nexport const useSchedulePerformance = () =>\n  useScheduleStore((state) => state.getPerformanceMetrics());\n\n// Memoized selectors for better performance\nexport const useScheduleCount = () => useScheduleStore((state) => state.schedule.length);\nexport const useHasSchedule = () => useScheduleStore((state) => state.schedule.length > 0);\nexport const useScheduleByRoom = (room: string) =>\n  useScheduleStore((state) => state.getScheduleByRoom(room));\n\n// Cached selectors that prevent recalculation\nexport const useCachedUpcomingSchedule = (limit = 10) =>\n  useScheduleStore((state) => {\n    const cached = state._cache.upcomingSchedule;\n    const now = Date.now();\n    const isCacheValid =\n      cached.timestamp > 0 && now - cached.timestamp < 5 * 60 * 1000 && cached.limit >= limit;\n\n    return isCacheValid ? cached.data.slice(0, limit) : state.getUpcomingSchedule(limit);\n  });\n\n// Specific schedule item selectors\nexport const useScheduleItem = (id: string) =>\n  useScheduleStore((state) => state.schedule.find((item) => item.id === id));\n","import React, { useMemo, useEffect, useCallback, ReactNode, useRef } from 'react';\nimport { getSchedule, addSchedule } from '@/services/firebase';\nimport { DocumentReference, DocumentData } from 'firebase/firestore';\nimport dayjs from 'dayjs';\nimport { useScheduleStore } from '@/stores/scheduleStore';\n\nexport interface ScheduleItem {\n  id?: string;\n  dateTime: dayjs.Dayjs;\n  url: string;\n  room: string;\n  [key: string]: any;\n}\n\nexport interface ScheduleContextType {\n  schedule: ScheduleItem[];\n  addToSchedule: (\n    dateTime: Date,\n    url: string,\n    room?: string\n  ) => Promise<undefined | DocumentReference<DocumentData>>;\n}\n\n// eslint-disable-next-line react-refresh/only-export-components\nexport const ScheduleContext = React.createContext<ScheduleContextType | undefined>(undefined);\n\ninterface ScheduleProviderProps {\n  children: ReactNode;\n  [key: string]: any;\n}\n\nfunction ScheduleProvider(props: ScheduleProviderProps): JSX.Element {\n  const { schedule, loadSchedule, flushPendingScheduleUpdates } = useScheduleStore();\n  const unsubscribeRef = useRef<(() => void) | null>(null);\n\n  // Optimized schedule update handler\n  const handleScheduleUpdate = useCallback(\n    (newSchedule: Array<Record<string, unknown>>) => {\n      loadSchedule(newSchedule as unknown as ScheduleItem[]);\n    },\n    [loadSchedule]\n  );\n\n  // Memoized addToSchedule function to prevent unnecessary re-renders\n  const memoizedAddToSchedule = useCallback(\n    async (\n      dateTime: Date,\n      url: string,\n      room?: string\n    ): Promise<undefined | DocumentReference<DocumentData>> => {\n      try {\n        const result = await addSchedule(dateTime, url, room);\n        // Flush any pending updates after adding\n        flushPendingScheduleUpdates();\n        return result || undefined;\n      } catch (error) {\n        console.error('Error adding to schedule:', error);\n        throw error;\n      }\n    },\n    [flushPendingScheduleUpdates]\n  );\n\n  // Cleanup function for Firebase listener\n  const cleanup = useCallback(() => {\n    if (unsubscribeRef.current) {\n      unsubscribeRef.current();\n      unsubscribeRef.current = null;\n    }\n    // Flush any pending updates before cleanup\n    flushPendingScheduleUpdates();\n  }, [flushPendingScheduleUpdates]);\n\n  useEffect(() => {\n    // Clean up previous listener\n    cleanup();\n\n    // Set up new listener\n    unsubscribeRef.current = getSchedule(handleScheduleUpdate);\n\n    // Cleanup on unmount\n    return cleanup;\n  }, [handleScheduleUpdate, cleanup]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return cleanup;\n  }, [cleanup]);\n\n  // Memoized context value with stable references\n  const value: ScheduleContextType = useMemo(\n    () => ({\n      schedule,\n      addToSchedule: memoizedAddToSchedule,\n    }),\n    [schedule, memoizedAddToSchedule]\n  );\n\n  return <ScheduleContext.Provider value={value} {...props} />;\n}\n\nexport { ScheduleProvider };\n","import {\n  createTheme,\n  responsiveFontSizes,\n  Theme,\n  ThemeOptions,\n  ComponentsOverrides,\n} from '@mui/material';\n\n// Color constants for better maintainability\nconst COLOR_CONSTANTS = {\n  // Primary colors\n  LIGHT_CYAN: '8, 145, 178', // Light mode cyan\n  DARK_CYAN: '72, 219, 251', // Dark mode cyan\n  BRIGHT_CYAN: '34, 211, 238', // Bright cyan for focus states\n\n  // Border and text colors\n  LIGHT_BORDER: '75, 85, 99', // Light mode border\n  DARK_BORDER: '148, 163, 184', // Dark mode border\n} as const;\n\n// Base theme configuration shared between light and dark themes\nconst baseTheme = {\n  typography: {\n    h1: {\n      fontWeight: 700,\n      letterSpacing: '-0.025em',\n    },\n    h2: {\n      fontWeight: 700,\n      letterSpacing: '-0.025em',\n    },\n    h3: {\n      fontWeight: 600,\n      letterSpacing: '-0.025em',\n    },\n    h4: {\n      fontWeight: 600,\n    },\n    h5: {\n      fontWeight: 600,\n    },\n    h6: {\n      fontWeight: 600,\n    },\n    button: {\n      fontWeight: 500,\n      textTransform: 'none' as const,\n    },\n  },\n  shape: {\n    borderRadius: 8,\n  },\n} satisfies ThemeOptions;\n\n// Define common component overrides function\nconst createComponents = (_mode: 'light' | 'dark'): ThemeOptions['components'] => ({\n  MuiBox: {\n    variants: [\n      {\n        props: { variant: 'systemMessage' },\n        style: ({ theme, ownerState }: { theme: Theme; ownerState: any }) => {\n          const { transparent = false, fullWidth = false } = ownerState;\n\n          return {\n            background: transparent\n              ? theme.palette.systemMessage.transparent\n              : theme.palette.systemMessage.main,\n            border: 'none',\n            borderRadius: 16,\n            margin: '8px auto',\n            alignSelf: 'center',\n            padding: '8px 12px',\n            width: 'fit-content',\n            backdropFilter: transparent ? 'blur(4px)' : 'none',\n            WebkitBackdropFilter: transparent ? 'blur(4px)' : 'none',\n            transition: theme.transitions.create(['background-color', 'backdrop-filter'], {\n              duration: theme.transitions.duration.short,\n            }),\n            ...(fullWidth && {\n              maxWidth: '95%',\n              width: 'auto',\n            }),\n            [theme.breakpoints.down('sm')]: {\n              maxWidth: fullWidth ? '98%' : '95%',\n            },\n          };\n        },\n      },\n    ],\n  },\n  MuiButton: {\n    styleOverrides: {\n      root: {\n        borderRadius: 8,\n        padding: '8px 16px',\n        transition: 'all 0.3s ease',\n        textTransform: 'none',\n        fontWeight: 500,\n        '&:hover': {\n          transform: 'translateY(-1px)',\n        },\n      },\n      contained: ({ theme }: { theme: Theme }) => {\n        return {\n          background: theme.palette.primary.main,\n          boxShadow: 'none',\n          '&:hover': {\n            background: theme.palette.primary.dark,\n            boxShadow: 'none',\n            transform: 'translateY(-2px)',\n          },\n        };\n      },\n      outlined: ({ theme }: { theme: Theme }) => {\n        const isLight = theme.palette.mode === 'light';\n        return {\n          borderColor: `rgba(${isLight ? COLOR_CONSTANTS.LIGHT_CYAN : COLOR_CONSTANTS.DARK_CYAN}, 0.5)`, // Use darker cyan for light mode\n          color: theme.palette.primary.main,\n          '&:hover': {\n            borderColor: `rgba(${isLight ? COLOR_CONSTANTS.LIGHT_CYAN : COLOR_CONSTANTS.DARK_CYAN}, 0.8)`,\n            background: `rgba(${isLight ? COLOR_CONSTANTS.LIGHT_CYAN : COLOR_CONSTANTS.DARK_CYAN}, 0.1)`,\n            boxShadow: `0 0 20px rgba(${isLight ? COLOR_CONSTANTS.LIGHT_CYAN : COLOR_CONSTANTS.DARK_CYAN}, 0.3)`,\n          },\n        };\n      },\n    },\n  },\n  MuiCard: {\n    styleOverrides: {\n      root: () => {\n        return {\n          borderRadius: 12,\n          background: 'var(--container-background)',\n          backdropFilter: 'blur(15px)',\n          WebkitBackdropFilter: 'blur(15px)',\n          border: '1px solid var(--container-border)',\n          boxShadow: 'var(--shadow-lg)',\n          transition: 'all 0.3s ease',\n          '&:hover': {\n            transform: 'translateY(-2px)',\n            boxShadow: 'var(--shadow-xl)',\n          },\n        };\n      },\n    },\n  },\n  MuiPaper: {\n    styleOverrides: {\n      root: {\n        backgroundImage: 'none',\n      },\n      elevation1: ({ theme }) => {\n        const isLight = theme.palette.mode === 'light';\n        return {\n          boxShadow: isLight\n            ? '0 1px 3px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.1)'\n            : '0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24)',\n        };\n      },\n      elevation2: ({ theme }) => {\n        const isLight = theme.palette.mode === 'light';\n        return {\n          boxShadow: isLight\n            ? '0 3px 6px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.06)'\n            : '0 3px 6px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.12)',\n        };\n      },\n      elevation4: ({ theme }) => {\n        const isLight = theme.palette.mode === 'light';\n        return {\n          boxShadow: isLight\n            ? '0 10px 20px rgba(0, 0, 0, 0.08), 0 3px 6px rgba(0, 0, 0, 0.05)'\n            : '0 10px 20px rgba(0, 0, 0, 0.15), 0 3px 6px rgba(0, 0, 0, 0.1)',\n        };\n      },\n    },\n  },\n  MuiTextField: {\n    styleOverrides: {\n      root: ({ theme }) => {\n        const isLight = theme.palette.mode === 'light';\n        return {\n          '& .MuiOutlinedInput-root': {\n            transition: 'border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out',\n            borderRadius: '8px',\n            '& .MuiOutlinedInput-notchedOutline': {\n              borderColor: isLight\n                ? `rgba(${COLOR_CONSTANTS.LIGHT_BORDER}, 0.4)`\n                : `rgba(${COLOR_CONSTANTS.DARK_BORDER}, 0.23)`, // Darker border for light mode\n            },\n            '&:hover .MuiOutlinedInput-notchedOutline': {\n              borderColor: isLight\n                ? `rgba(${COLOR_CONSTANTS.LIGHT_BORDER}, 0.6)`\n                : theme.palette.primary.main,\n            },\n            '&.Mui-focused .MuiOutlinedInput-notchedOutline': {\n              borderColor: theme.palette.primary.main,\n              boxShadow: `0 0 0 2px rgba(${isLight ? COLOR_CONSTANTS.LIGHT_CYAN : COLOR_CONSTANTS.BRIGHT_CYAN}, 0.2)`,\n            },\n            '& input::placeholder': {\n              color: isLight\n                ? `rgba(${COLOR_CONSTANTS.LIGHT_BORDER}, 0.7)`\n                : `rgba(${COLOR_CONSTANTS.DARK_BORDER}, 0.5)`, // Darker placeholder for light mode\n              opacity: 1,\n            },\n            '& textarea::placeholder': {\n              color: isLight\n                ? `rgba(${COLOR_CONSTANTS.LIGHT_BORDER}, 0.7)`\n                : `rgba(${COLOR_CONSTANTS.DARK_BORDER}, 0.5)`, // Darker placeholder for light mode\n              opacity: 1,\n            },\n          },\n          '& .MuiInputLabel-root': {\n            color: isLight\n              ? `rgba(${COLOR_CONSTANTS.LIGHT_BORDER}, 0.8)`\n              : `rgba(${COLOR_CONSTANTS.DARK_BORDER}, 0.7)`, // Darker label for light mode\n            '&.Mui-focused': {\n              color: theme.palette.primary.main,\n            },\n          },\n        };\n      },\n    },\n  },\n  MuiSelect: {\n    styleOverrides: {\n      root: ({ theme }) => {\n        const isLight = theme.palette.mode === 'light';\n        return {\n          borderRadius: '8px',\n          transition: 'border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out',\n          '& .MuiOutlinedInput-notchedOutline': {\n            borderColor: isLight\n              ? `rgba(${COLOR_CONSTANTS.LIGHT_BORDER}, 0.4)`\n              : `rgba(${COLOR_CONSTANTS.DARK_BORDER}, 0.23)`, // Darker border for light mode\n          },\n          '&:hover .MuiOutlinedInput-notchedOutline': {\n            borderColor: isLight\n              ? `rgba(${COLOR_CONSTANTS.LIGHT_BORDER}, 0.6)`\n              : theme.palette.primary.main,\n          },\n          '&.Mui-focused .MuiOutlinedInput-notchedOutline': {\n            borderColor: theme.palette.primary.main,\n            boxShadow: `0 0 0 2px rgba(${isLight ? COLOR_CONSTANTS.LIGHT_CYAN : COLOR_CONSTANTS.BRIGHT_CYAN}, 0.2)`,\n          },\n        };\n      },\n    },\n    defaultProps: {\n      MenuProps: {\n        disableScrollLock: true,\n        BackdropProps: {\n          invisible: true,\n        },\n        PaperProps: {\n          style: {\n            backdropFilter: 'none',\n            WebkitBackdropFilter: 'none',\n          },\n        },\n      },\n    },\n  },\n  MuiSwitch: {\n    styleOverrides: {\n      switchBase: ({ theme }) => ({\n        '&.Mui-checked': {\n          color: theme.palette.primary.main,\n          '& + .MuiSwitch-track': {\n            backgroundColor: theme.palette.primary.main,\n          },\n        },\n      }),\n    },\n  },\n  MuiSlider: {\n    styleOverrides: {\n      root: ({ theme }) => ({\n        color: theme.palette.primary.main,\n      }),\n    },\n  },\n  MuiCssBaseline: {\n    styleOverrides: {\n      body: ({ theme }: { theme: Theme }) => {\n        const isLight = theme.palette.mode === 'light';\n        return {\n          scrollbarWidth: 'thin',\n          scrollbarColor: isLight ? '#d1d5db transparent' : '#4b5563 transparent',\n          '&::-webkit-scrollbar': {\n            width: '8px',\n            height: '8px',\n          },\n          '&::-webkit-scrollbar-track': {\n            background: 'transparent',\n          },\n          '&::-webkit-scrollbar-thumb': {\n            background: isLight ? '#d1d5db' : '#4b5563',\n            borderRadius: '4px',\n          },\n          '&::-webkit-scrollbar-thumb:hover': {\n            background: isLight ? '#9ca3af' : '#6b7280',\n          },\n        };\n      },\n      // Add accessibility enhancements\n      '*': {\n        // High contrast mode support\n        '@media (forced-colors: active)': {\n          '&:focus': {\n            outline: '2px solid ButtonText !important',\n          },\n        },\n        // Reduced motion support\n        '@media (prefers-reduced-motion: reduce)': {\n          '&, &::before, &::after': {\n            animationDuration: '0.01ms !important',\n            animationIterationCount: '1 !important',\n            transitionDuration: '0.01ms !important',\n            scrollBehavior: 'auto !important',\n          },\n        },\n      },\n      // Enhanced focus visibility for keyboard navigation\n      '.keyboard-navigation *:focus': {\n        outline: '2px solid #22d3ee',\n        outlineOffset: '2px',\n      },\n    },\n  },\n  MuiAppBar: {\n    styleOverrides: {\n      root: () => {\n        return {\n          backgroundColor: 'var(--nav-background)',\n          borderBottom: '1px solid var(--nav-border)',\n          boxShadow: 'var(--nav-shadow)',\n        };\n      },\n    },\n  },\n  MuiContainer: {\n    styleOverrides: {\n      root: () => {\n        return {\n          '&.gradient-background': {\n            minHeight: '100vh',\n            background: 'var(--page-gradient)',\n            padding: '2rem 0',\n          },\n        };\n      },\n    },\n  },\n  MuiModal: {\n    styleOverrides: {\n      root: {\n        '&:not(.MuiPopover-root)': {\n          backdropFilter: 'blur(8px)',\n          WebkitBackdropFilter: 'blur(8px)',\n        },\n      },\n    },\n  },\n  MuiPopover: {\n    styleOverrides: {\n      root: {\n        '& .MuiModal-backdrop': {\n          backgroundColor: 'transparent',\n          backdropFilter: 'none',\n          WebkitBackdropFilter: 'none',\n        },\n      },\n    },\n  },\n  MuiDialog: {\n    styleOverrides: {\n      paper: () => {\n        return {\n          background: 'var(--color-surface)',\n          backdropFilter: 'blur(20px)',\n          WebkitBackdropFilter: 'blur(20px)',\n          border: '1px solid var(--nav-border)',\n          borderRadius: 'var(--border-radius-lg)',\n          boxShadow: 'var(--shadow-lg)',\n        };\n      },\n    },\n  },\n});\n\n// Extend the MUI theme type to include custom colors\ndeclare module '@mui/material/styles' {\n  interface Palette {\n    systemMessage: {\n      main: string;\n      transparent: string;\n    };\n  }\n\n  interface PaletteOptions {\n    systemMessage?: {\n      main: string;\n      transparent: string;\n    };\n  }\n}\n\n// Extend MUI Box to support custom variants\ndeclare module '@mui/material/Box' {\n  interface BoxPropsVariantOverrides {\n    systemMessage: true;\n  }\n}\n\n// Extend MUI theme components to include custom overrides\ndeclare module '@mui/material/styles' {\n  interface ComponentNameToClassKey {\n    MuiBox: 'root';\n  }\n\n  interface Components<Theme = unknown> {\n    MuiBox?: {\n      variants?: Array<{\n        props: Record<string, any>;\n        style:\n          | Record<string, any>\n          | ((props: { theme: Theme; ownerState: any }) => Record<string, any>);\n      }>;\n    } & ComponentsOverrides<Theme>['MuiBox'];\n  }\n}\n\n// Light theme configuration\nconst lightThemeOptions: ThemeOptions = {\n  ...baseTheme,\n  palette: {\n    mode: 'light',\n    primary: {\n      main: '#0891b2', // Cyan 600 - darker for better contrast on light background\n      dark: '#0e7490', // Cyan 700\n      light: '#22d3ee', // Cyan 400\n      contrastText: '#ffffff', // White text for better contrast\n    },\n    secondary: {\n      main: '#06b6d4', // Cyan 500 - slightly darker for better light mode contrast\n      dark: '#0e7490', // Cyan 700\n      light: '#a5f3fc', // Cyan 200\n      contrastText: '#ffffff', // White text for better contrast\n    },\n    background: {\n      default: '#f8fafc', // Slate 50\n      paper: '#ffffff', // Pure white\n    },\n    text: {\n      primary: '#0f172a', // Slate 900\n      secondary: '#475569', // Slate 600\n    },\n    divider: 'rgba(148, 163, 184, 0.2)', // Slate 400 with opacity for light mode\n    error: {\n      main: '#dc2626', // Red 600 - good contrast on light background\n    },\n    warning: {\n      main: '#d97706', // Amber 600 - good contrast on light background\n    },\n    systemMessage: {\n      main: 'rgba(148, 163, 184, 0.15)', // Slate 400 with low opacity for light mode\n      transparent: 'rgba(148, 163, 184, 0.25)', // Slate 400 with higher opacity for transparent mode\n    },\n    info: {\n      main: '#2563eb', // Blue 600 - good contrast on light background\n    },\n    success: {\n      main: '#059669', // Emerald 600 - good contrast on light background\n    },\n  },\n};\n\n// Dark theme configuration (existing theme adapted)\nconst darkThemeOptions: ThemeOptions = {\n  ...baseTheme,\n  palette: {\n    mode: 'dark',\n    primary: {\n      main: '#22d3ee', // Cyan 400\n      dark: '#0891b2', // Cyan 600\n      light: '#67e8f9', // Cyan 300\n    },\n    secondary: {\n      main: '#48dbfb', // Brand teal\n      dark: '#0e7490', // Cyan 700\n      light: '#a5f3fc', // Cyan 200\n    },\n    background: {\n      default: '#0f172a', // Slate 900\n      paper: '#1e293b', // Slate 800\n    },\n    text: {\n      primary: '#f8fafc', // Slate 50\n      secondary: '#cbd5e1', // Slate 300\n    },\n    divider: 'rgba(148, 163, 184, 0.12)', // Slate 400 with opacity\n    error: {\n      main: '#b91c1c', // Darker red\n    },\n    warning: {\n      main: '#b45309', // Darker amber\n    },\n    systemMessage: {\n      main: 'rgba(148, 163, 184, 0.1)', // Slate 400 with low opacity\n      transparent: 'rgba(148, 163, 184, 0.2)', // Slate 400 with higher opacity for transparent mode\n    },\n    info: {\n      main: '#1d4ed8', // Darker blue\n    },\n    success: {\n      main: '#047857', // Darker emerald\n    },\n  },\n};\n\n// Create themes with components\nconst createThemeWithComponents = (themeOptions: ThemeOptions): Theme => {\n  const baseTheme = createTheme(themeOptions);\n  return createTheme({\n    ...baseTheme,\n    components: createComponents(themeOptions.palette!.mode as 'light' | 'dark'),\n  });\n};\n\n// Export both themes\nexport const lightTheme = responsiveFontSizes(createThemeWithComponents(lightThemeOptions));\nexport const darkTheme = responsiveFontSizes(createThemeWithComponents(darkThemeOptions));\n\n// Export default dark theme for backward compatibility\nexport default darkTheme;\n\n// Helper function to get theme by mode\nexport const getThemeByMode = (mode: 'light' | 'dark'): Theme => {\n  return mode === 'light' ? lightTheme : darkTheme;\n};\n","import React, { createContext, useContext, useEffect, useMemo } from 'react';\nimport { Theme, useMediaQuery } from '@mui/material';\nimport { getThemeByMode } from '@/theme';\nimport { ThemeMode } from '@/types/Settings';\nimport { useSettingsStore } from '@/stores/settingsStore';\n\ninterface ThemeContextValue {\n  /** Current active theme object */\n  theme: Theme;\n  /** Current theme mode preference (light, dark, or system) */\n  themeMode: ThemeMode;\n  /** Actual resolved theme mode (light or dark, never system) */\n  resolvedThemeMode: 'light' | 'dark';\n  /** Whether the user prefers dark mode according to system settings */\n  prefersDarkMode: boolean;\n  /** Function to change theme mode */\n  setThemeMode: (mode: ThemeMode) => void;\n  /** Function to toggle between light and dark (ignores system preference) */\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextValue | undefined>(undefined);\n\ninterface ThemeProviderProps {\n  children: React.ReactNode;\n  /** Optional default theme mode (defaults to 'system') */\n  defaultMode?: ThemeMode;\n}\n\nexport function ThemeProvider({ children, defaultMode = 'system' }: ThemeProviderProps) {\n  const { settings, updateSettings } = useSettingsStore();\n\n  // Detect system preference for dark mode\n  const prefersDarkMode = useMediaQuery('(prefers-color-scheme: dark)', {\n    noSsr: true, // Prevent hydration mismatch\n  });\n\n  // Get theme mode from settings or use default\n  const themeMode: ThemeMode = settings.themeMode || defaultMode;\n\n  // Resolve the actual theme mode (convert 'system' to 'light' or 'dark')\n  const resolvedThemeMode: 'light' | 'dark' = useMemo(() => {\n    if (themeMode === 'system') {\n      return prefersDarkMode ? 'dark' : 'light';\n    }\n    return themeMode;\n  }, [themeMode, prefersDarkMode]);\n\n  // Get the actual theme object\n  const theme = useMemo(() => {\n    return getThemeByMode(resolvedThemeMode);\n  }, [resolvedThemeMode]);\n\n  // Function to update theme mode\n  const setThemeMode = (mode: ThemeMode) => {\n    updateSettings({ themeMode: mode });\n  };\n\n  // Function to toggle between light and dark (ignores system)\n  const toggleTheme = () => {\n    const newMode = resolvedThemeMode === 'light' ? 'dark' : 'light';\n    setThemeMode(newMode);\n  };\n\n  // No longer needed - useMediaQuery with noSsr handles initialization properly\n\n  // Listen for system theme changes and update if in system mode\n  useEffect(() => {\n    if (themeMode === 'system') {\n      // Theme will automatically update due to resolvedThemeMode dependency\n      // System theme preference changed: prefersDarkMode ? 'dark' : 'light'\n    }\n  }, [prefersDarkMode, themeMode]);\n\n  // Provide smooth transition classes to body\n  useEffect(() => {\n    const body = document.body;\n\n    // Add transition class for smooth theme switching\n    body.style.transition = 'background-color 0.3s ease, color 0.3s ease';\n\n    // Add theme mode class for any custom CSS that might need it\n    body.classList.remove('theme-light', 'theme-dark');\n    body.classList.add(`theme-${resolvedThemeMode}`);\n\n    return () => {\n      body.style.transition = '';\n      body.classList.remove('theme-light', 'theme-dark');\n    };\n  }, [resolvedThemeMode]);\n\n  const contextValue: ThemeContextValue = {\n    theme,\n    themeMode,\n    resolvedThemeMode,\n    prefersDarkMode,\n    setThemeMode,\n    toggleTheme,\n  };\n\n  return <ThemeContext.Provider value={contextValue}>{children}</ThemeContext.Provider>;\n}\n\n/**\n * Hook to access theme context\n * @throws Error if used outside of ThemeProvider\n */\n// eslint-disable-next-line react-refresh/only-export-components\nexport function useTheme(): ThemeContextValue {\n  const context = useContext(ThemeContext);\n\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n\n  return context;\n}\n\n/**\n * Hook to get just the theme mode and setter (lighter alternative)\n */\n// eslint-disable-next-line react-refresh/only-export-components\nexport function useThemeMode(): [ThemeMode, (mode: ThemeMode) => void] {\n  const { themeMode, setThemeMode } = useTheme();\n  return [themeMode, setThemeMode];\n}\n\n/**\n * Hook to get the resolved theme mode (always 'light' or 'dark')\n */\n// eslint-disable-next-line react-refresh/only-export-components\nexport function useResolvedThemeMode(): 'light' | 'dark' {\n  const { resolvedThemeMode } = useTheme();\n  return resolvedThemeMode;\n}\n\n/**\n * Hook for theme toggle functionality\n */\n// eslint-disable-next-line react-refresh/only-export-components\nexport function useThemeToggle(): () => void {\n  const { toggleTheme } = useTheme();\n  return toggleTheme;\n}\n","import { CssBaseline, ThemeProvider as MuiThemeProvider } from '@mui/material';\nimport { LocalizationProvider } from '@mui/x-date-pickers';\nimport { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';\nimport { useTheme } from '../../context/theme';\n\ninterface MuiProvidersProps {\n  children: React.ReactNode;\n}\n\nexport default function MuiProviders({ children }: MuiProvidersProps) {\n  const { theme } = useTheme();\n\n  return (\n    <MuiThemeProvider theme={theme}>\n      <CssBaseline />\n      <LocalizationProvider dateAdapter={AdapterDayjs}>{children}</LocalizationProvider>\n    </MuiThemeProvider>\n  );\n}\n","import { ProvidersProps } from '@/types/app';\nimport { MigrationProvider } from '@/context/migration';\nimport { ScheduleProvider } from '@/context/schedule';\nimport { ThemeProvider } from '@/context/theme';\nimport MuiProviders from '@/components/MuiProviders';\n\n/**\n * Consolidated providers component to reduce Suspense boundary nesting\n * This helps fix iOS Safari module loading issues by reducing import waterfalls\n */\nexport default function AllProviders({ children }: ProvidersProps) {\n  return (\n    <ThemeProvider>\n      <MigrationProvider>\n        <ScheduleProvider>\n          <MuiProviders>{children}</MuiProviders>\n        </ScheduleProvider>\n      </MigrationProvider>\n    </ThemeProvider>\n  );\n}\n","/**\n * Parses various timestamp formats into a Date object\n * @param timestamp - The timestamp to parse (Firebase Timestamp, string, number, object, or Date)\n * @returns Date object if parsing succeeds, null if it fails\n */\nexport function parseMessageTimestamp(timestamp: any): Date | null {\n  if (!timestamp) {\n    return null;\n  }\n\n  try {\n    if (typeof timestamp.toDate === 'function') {\n      // Firebase Timestamp format\n      return timestamp.toDate();\n    } else if (typeof timestamp === 'string') {\n      // Serialized timestamp format\n      const date = new Date(timestamp);\n      if (isNaN(date.getTime())) {\n        throw new Error('Invalid serialized timestamp format');\n      }\n      return date;\n    } else if (typeof timestamp === 'number') {\n      // Unix timestamp (milliseconds or seconds)\n      // If timestamp is less than year 3000 in seconds, convert to milliseconds\n      const timestampMs = timestamp < 32503680000 ? timestamp * 1000 : timestamp;\n      const date = new Date(timestampMs);\n      if (isNaN(date.getTime())) {\n        throw new Error('Invalid numeric timestamp format');\n      }\n      return date;\n    } else if (typeof timestamp === 'object' && timestamp.seconds !== undefined) {\n      // Firestore Timestamp serialized object format {seconds: number, nanoseconds: number}\n      const timestampObj = timestamp as { seconds: number; nanoseconds?: number };\n      const date = new Date(\n        timestampObj.seconds * 1000 + (timestampObj.nanoseconds || 0) / 1000000\n      );\n      if (isNaN(date.getTime())) {\n        throw new Error('Invalid Firestore timestamp object format');\n      }\n      return date;\n    } else if (timestamp instanceof Date) {\n      // Already a Date object\n      return timestamp;\n    } else {\n      // Log the actual timestamp value for debugging\n      console.warn('Unsupported timestamp format:', typeof timestamp, timestamp);\n      throw new Error(`Unsupported timestamp format: ${typeof timestamp}`);\n    }\n  } catch (error) {\n    console.warn('Failed to parse timestamp:', error);\n    return null;\n  }\n}\n","import { Message, MessageType } from '@/types/Message';\nimport { parseMessageTimestamp } from '@/helpers/timestamp';\n\n// chat box\nexport function normalSortedMessages(messages: Message[]): Message[] {\n  return messages.sort((a, b) => {\n    const aDate = parseMessageTimestamp(a.timestamp);\n    const bDate = parseMessageTimestamp(b.timestamp);\n    if (!aDate || !bDate) return 0;\n    return aDate.getTime() - bDate.getTime();\n  });\n}\n\n// latest on top\nexport function sortedMessages(messages: Message[]): Message[] {\n  const newMessage = JSON.parse(JSON.stringify(messages));\n  return newMessage.reverse();\n}\n\nexport default function latestMessageByType(\n  messages: Message[],\n  type: MessageType\n): Message | undefined {\n  return sortedMessages(messages).find((m) => m.type === type);\n}\n\nexport function orderedMessagesByType(\n  messages: Message[],\n  type: string,\n  order: 'ASC' | 'DESC' = 'ASC'\n): Message[] {\n  let sorted = sortedMessages(messages);\n  if (order === 'DESC') {\n    sorted = sorted.reverse();\n  }\n  return sorted.filter((m) => m.type === type);\n}\n\nexport function latestMessageBy(\n  messages: Message[],\n  callback: (message: Message) => boolean\n): Message | undefined {\n  return sortedMessages(messages).find(callback);\n}\n\nexport function latestMessage(messages: Message[]): Message | undefined {\n  return sortedMessages(messages)[0];\n}\n","import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { Message, MessageType } from '@/types/Message';\nimport latestMessageByType, {\n  normalSortedMessages,\n  orderedMessagesByType,\n  latestMessage,\n} from '@/helpers/messages';\nimport { parseMessageTimestamp } from '@/helpers/timestamp';\n\ninterface MessagesState {\n  messages: Message[];\n  loading: boolean;\n  error: string | null;\n  room: string | null;\n  paginationCursor: string | null;\n}\n\ninterface MessagesActions {\n  loadMessages: (messages: Message[]) => void;\n  addMessage: (message: Message) => void;\n  updateMessage: (id: string, updates: Partial<Message>) => void;\n  clearMessages: () => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n  setRoom: (room: string | null) => void;\n  setPaginationCursor: (cursor: string | null) => void;\n}\n\ninterface MessagesSelectors {\n  getMessagesByType: (type: MessageType) => Message[];\n  getLatestMessage: () => Message | undefined;\n  getLatestMessageByType: (type: MessageType) => Message | undefined;\n  getFilteredMessages: (predicate: (message: Message) => boolean) => Message[];\n  getOrderedMessagesByType: (type: string, order?: 'ASC' | 'DESC') => Message[];\n}\n\ninterface MessagesStore extends MessagesState, MessagesActions, MessagesSelectors {}\n\nconst initialState: MessagesState = {\n  messages: [],\n  loading: true,\n  error: null,\n  room: null,\n  paginationCursor: null,\n};\n\nexport const useMessagesStore = create<MessagesStore>()(\n  persist(\n    (set, get) => ({\n      ...initialState,\n\n      // Actions\n      loadMessages: (messages) => {\n        // Cast messages to proper type since Firebase returns any[]\n        const typedMessages = messages as Message[];\n        const sortedMessages = normalSortedMessages(typedMessages);\n        set({\n          messages: sortedMessages,\n          loading: false,\n          error: null,\n        });\n      },\n\n      addMessage: (message) => {\n        const { messages } = get();\n        // Check for duplicate messages to prevent unnecessary updates\n        const existingMessage = messages.find((msg) => msg.id === message.id);\n        if (existingMessage) {\n          return; // Message already exists, no update needed\n        }\n\n        const newMessages = [...messages, message];\n        const sortedMessages = normalSortedMessages(newMessages);\n        set({ messages: sortedMessages });\n      },\n\n      updateMessage: (id, updates) => {\n        const { messages } = get();\n        let hasChanges = false;\n        const updatedMessages = messages.map((msg) => {\n          if (msg.id === id) {\n            // Check if updates actually change anything\n            const updatedMsg = { ...msg, ...updates } as Message;\n            const hasActualChanges = Object.keys(updates).some(\n              (key) => (msg as any)[key] !== (updates as any)[key]\n            );\n            if (hasActualChanges) {\n              hasChanges = true;\n              return updatedMsg;\n            }\n          }\n          return msg;\n        });\n\n        // Only update state if there were actual changes\n        if (hasChanges) {\n          const sortedMessages = normalSortedMessages(updatedMessages);\n          set({ messages: sortedMessages });\n        }\n      },\n\n      clearMessages: () => {\n        set({ messages: [], loading: false, error: null });\n      },\n\n      setLoading: (loading) => {\n        const { loading: currentLoading } = get();\n        if (currentLoading !== loading) {\n          set({ loading });\n        }\n      },\n\n      setError: (error) => {\n        const { error: currentError } = get();\n        if (currentError !== error) {\n          set({ error });\n        }\n      },\n\n      setRoom: (room) => {\n        const { room: currentRoom } = get();\n        if (currentRoom !== room) {\n          set({ room });\n        }\n      },\n\n      setPaginationCursor: (cursor) => {\n        const { paginationCursor: currentCursor } = get();\n        if (currentCursor !== cursor) {\n          set({ paginationCursor: cursor });\n        }\n      },\n\n      // Selectors - Optimized for performance\n      getMessagesByType: (type) => {\n        const { messages } = get();\n        // Use a more efficient filter approach for large message arrays\n        const filtered: Message[] = [];\n        for (let i = 0; i < messages.length; i++) {\n          if (messages[i].type === type) {\n            filtered.push(messages[i]);\n          }\n        }\n        return filtered;\n      },\n\n      getLatestMessage: () => {\n        const { messages } = get();\n        return latestMessage(messages);\n      },\n\n      getLatestMessageByType: (type) => {\n        const { messages } = get();\n        return latestMessageByType(messages, type);\n      },\n\n      getFilteredMessages: (predicate) => {\n        const { messages } = get();\n        // Use for loop for better performance on large arrays\n        const filtered: Message[] = [];\n        for (let i = 0; i < messages.length; i++) {\n          if (predicate(messages[i])) {\n            filtered.push(messages[i]);\n          }\n        }\n        return filtered;\n      },\n\n      getOrderedMessagesByType: (type, order = 'ASC') => {\n        const { messages } = get();\n        return orderedMessagesByType(messages, type, order);\n      },\n    }),\n    {\n      name: 'messages-storage', // localStorage key\n      partialize: (state) => ({\n        messages: state.messages,\n        room: state.room,\n        paginationCursor: state.paginationCursor,\n      }),\n      // Add TTL functionality\n      onRehydrateStorage: () => {\n        return (state) => {\n          if (state) {\n            // Clear messages older than 24 hours on rehydration\n            const twentyFourHoursAgo = new Date();\n            twentyFourHoursAgo.setHours(twentyFourHoursAgo.getHours() - 24);\n\n            const validMessages = state.messages.filter((msg) => {\n              try {\n                const messageTime = parseMessageTimestamp(msg.timestamp);\n                if (!messageTime) {\n                  console.warn(\n                    `Failed to parse timestamp for message ${msg.id}:`,\n                    typeof msg.timestamp,\n                    msg.timestamp\n                  );\n                  throw new Error(`Failed to parse timestamp for message ${msg.id}`);\n                }\n\n                return messageTime > twentyFourHoursAgo;\n              } catch (error) {\n                // Log specific error messages for debugging\n                console.warn(\n                  `Failed to parse message timestamp for message ID ${msg.id}:`,\n                  (error as Error).message\n                );\n                return true; // Keep the message if parsing fails\n              }\n            });\n\n            if (validMessages.length !== state.messages.length) {\n              state.loadMessages(validMessages);\n            }\n          }\n        };\n      },\n    }\n  )\n);\n\n// Compatibility hook for existing useMessages pattern\nexport const useMessages = () => {\n  const { messages, loading: isLoading } = useMessagesStore();\n  return { messages, isLoading };\n};\n","import React, { ReactNode, useEffect } from 'react';\nimport { Params, useParams } from 'react-router-dom';\nimport { getMessages } from '@/services/firebase';\nimport { Message } from '@/types/Message';\nimport { useMessagesStore } from '@/stores/messagesStore';\n\nexport interface MessagesContextType {\n  messages: Message[];\n  isLoading: boolean;\n}\n\n// eslint-disable-next-line react-refresh/only-export-components\nexport const MessagesContext = React.createContext<MessagesContextType | undefined>(undefined);\n\ninterface MessagesProviderProps {\n  children: ReactNode;\n  [key: string]: any;\n}\n\nexport function MessagesProvider(props: MessagesProviderProps): JSX.Element {\n  const { id: room } = useParams<Params>();\n\n  const {\n    messages,\n    loading: isLoading,\n    loadMessages,\n    setLoading,\n    setRoom,\n    clearMessages,\n  } = useMessagesStore();\n\n  useEffect(() => {\n    setLoading(true);\n    setRoom(room || null);\n\n    if (!room) {\n      clearMessages();\n      return;\n    }\n\n    return getMessages(room, (newMessages: Array<Record<string, unknown>>) => {\n      loadMessages(newMessages as unknown as Message[]);\n    });\n  }, [room, loadMessages, setLoading, setRoom, clearMessages]);\n\n  const value = { messages, isLoading };\n\n  return <MessagesContext.Provider value={value} {...props} />;\n}\n","import { create } from 'zustand';\nimport { OnlineUser } from '@/context/userList';\n\n// Performance tracking\ninterface PerformanceMetrics {\n  lastUpdateTime: number;\n  updateCount: number;\n  averageUpdateInterval: number;\n}\n\ninterface UserListStore {\n  // State\n  onlineUsers: Record<string, OnlineUser>;\n  loading: boolean;\n  error: string | null;\n  room: string | null;\n  _performanceMetrics: PerformanceMetrics;\n  _pendingUpdates: Record<string, OnlineUser | null>; // null means removal\n  _batchTimeout: NodeJS.Timeout | null;\n\n  // Actions\n  setUsers: (users: Record<string, OnlineUser>) => void;\n  addUser: (uid: string, user: OnlineUser) => void;\n  removeUser: (uid: string) => void;\n  clearUsers: () => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n  setRoom: (room: string | null) => void;\n\n  // Performance optimized actions\n  batchUpdateUsers: (updates: Record<string, OnlineUser | null>) => void;\n  flushPendingUpdates: () => void;\n\n  // Selectors\n  getUsersByRoom: (room?: string) => Record<string, OnlineUser>;\n  getActiveUserCount: () => number;\n  getPerformanceMetrics: () => PerformanceMetrics;\n}\n\nconst BATCH_DELAY = 50; // 50ms debounce for real-time updates\n\nexport const useUserListStore = create<UserListStore>((set, get) => ({\n  // State\n  onlineUsers: {},\n  loading: false,\n  error: null,\n  room: null,\n  _performanceMetrics: {\n    lastUpdateTime: Date.now(),\n    updateCount: 0,\n    averageUpdateInterval: 0,\n  },\n  _pendingUpdates: {},\n  _batchTimeout: null,\n\n  // Actions\n  setUsers: (users) => {\n    const now = Date.now();\n    set((state) => {\n      const timeDiff = now - state._performanceMetrics.lastUpdateTime;\n      const newUpdateCount = state._performanceMetrics.updateCount + 1;\n      const newAverage =\n        (state._performanceMetrics.averageUpdateInterval * state._performanceMetrics.updateCount +\n          timeDiff) /\n        newUpdateCount;\n\n      return {\n        onlineUsers: users,\n        loading: false,\n        error: null,\n        _performanceMetrics: {\n          lastUpdateTime: now,\n          updateCount: newUpdateCount,\n          averageUpdateInterval: newAverage,\n        },\n      };\n    });\n  },\n\n  addUser: (uid, user) => {\n    const state = get();\n    state._pendingUpdates[uid] = user;\n\n    // Debounced batch update\n    if (state._batchTimeout) clearTimeout(state._batchTimeout);\n    const timeout = setTimeout(() => {\n      state.flushPendingUpdates();\n    }, BATCH_DELAY);\n    set({ _batchTimeout: timeout });\n  },\n\n  removeUser: (uid) => {\n    const state = get();\n    state._pendingUpdates[uid] = null; // null indicates removal\n\n    // Debounced batch update\n    if (state._batchTimeout) clearTimeout(state._batchTimeout);\n    const timeout = setTimeout(() => {\n      state.flushPendingUpdates();\n    }, BATCH_DELAY);\n    set({ _batchTimeout: timeout });\n  },\n\n  batchUpdateUsers: (updates) =>\n    set((state) => {\n      const newUsers = { ...state.onlineUsers };\n\n      Object.entries(updates).forEach(([uid, user]) => {\n        if (user === null) {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { [uid]: _, ...remaining } = newUsers;\n          Object.assign(newUsers, remaining);\n        } else {\n          newUsers[uid] = user;\n        }\n      });\n\n      const now = Date.now();\n      const timeDiff = now - state._performanceMetrics.lastUpdateTime;\n      const newUpdateCount = state._performanceMetrics.updateCount + 1;\n      const newAverage =\n        (state._performanceMetrics.averageUpdateInterval * state._performanceMetrics.updateCount +\n          timeDiff) /\n        newUpdateCount;\n\n      return {\n        onlineUsers: newUsers,\n        _performanceMetrics: {\n          lastUpdateTime: now,\n          updateCount: newUpdateCount,\n          averageUpdateInterval: newAverage,\n        },\n      };\n    }),\n\n  flushPendingUpdates: () => {\n    const state = get();\n    if (Object.keys(state._pendingUpdates).length === 0) return;\n\n    state.batchUpdateUsers(state._pendingUpdates);\n    set(() => ({ _pendingUpdates: {} }));\n  },\n\n  clearUsers: () =>\n    set(() => ({\n      onlineUsers: {},\n      loading: false,\n      error: null,\n      _pendingUpdates: {},\n    })),\n\n  setLoading: (loading) => set(() => ({ loading })),\n\n  setError: (error) => set(() => ({ error, loading: false })),\n\n  setRoom: (room) => set(() => ({ room })),\n\n  // Selectors\n  getUsersByRoom: (room) => {\n    const state = get();\n    if (!room) return state.onlineUsers;\n\n    // Filter users by room if needed (current implementation doesn't filter by room)\n    // This is here for future extensibility when room-specific user filtering is needed\n    return state.onlineUsers;\n  },\n\n  getActiveUserCount: () => {\n    const state = get();\n    return Object.keys(state.onlineUsers).length;\n  },\n\n  getPerformanceMetrics: () => {\n    const state = get();\n    return state._performanceMetrics;\n  },\n}));\n\n// Compatibility selectors for optimized subscriptions\nexport const useOnlineUsers = () => useUserListStore((state) => state.onlineUsers);\nexport const useUserListLoading = () => useUserListStore((state) => state.loading);\nexport const useUserListError = () => useUserListStore((state) => state.error);\nexport const useActiveUserCount = () => useUserListStore((state) => state.getActiveUserCount());\n\n// Performance-optimized hooks\nexport const useUserListPerformance = () =>\n  useUserListStore((state) => state.getPerformanceMetrics());\n\n// Memoized selectors for better performance\nexport const useUserCount = () =>\n  useUserListStore((state) => Object.keys(state.onlineUsers).length);\nexport const useUserIds = () => useUserListStore((state) => Object.keys(state.onlineUsers));\nexport const useHasUsers = () =>\n  useUserListStore((state) => Object.keys(state.onlineUsers).length > 0);\n\n// Specific user selectors to prevent unnecessary re-renders\nexport const useUser = (uid: string) => useUserListStore((state) => state.onlineUsers[uid]);\nexport const useIsUserOnline = (uid: string) =>\n  useUserListStore((state) => !!state.onlineUsers[uid]);\n","import React, { useMemo, useEffect, useCallback, ReactNode, useRef } from 'react';\nimport { Params, useParams } from 'react-router-dom';\nimport { useShallow } from 'zustand/react/shallow';\nimport { getUserList } from '@/services/firebase';\nimport { useUserListStore } from '@/stores/userListStore';\n\nexport interface OnlineUser {\n  displayName: string;\n  uid: string;\n  lastSeen: Date;\n  [key: string]: any;\n}\n\nfunction isValidOnlineUser(obj: unknown): obj is OnlineUser {\n  if (!obj || typeof obj !== 'object') return false;\n\n  const user = obj as Record<string, unknown>;\n\n  return (\n    typeof user.displayName === 'string' &&\n    typeof user.uid === 'string' &&\n    (user.lastSeen instanceof Date ||\n      typeof user.lastSeen === 'number' ||\n      typeof user.lastSeen === 'string')\n  );\n}\n\nexport interface UserListContextType {\n  onlineUsers: Record<string, OnlineUser>;\n}\n\n// eslint-disable-next-line react-refresh/only-export-components\nexport const UserListContext = React.createContext<UserListContextType | undefined>(undefined);\n\ninterface UserListProviderProps {\n  children: ReactNode;\n  [key: string]: any;\n}\n\nfunction UserListProvider(props: UserListProviderProps): JSX.Element {\n  const { id: room } = useParams<Params>();\n  const onlineUsers = useUserListStore((s) => s.onlineUsers);\n  const unsubscribeRef = useRef<(() => void) | null>(null);\n  const prevRoomRef = useRef<string | undefined>(undefined);\n  const onlineUsersRef = useRef(onlineUsers);\n\n  useEffect(() => {\n    onlineUsersRef.current = onlineUsers;\n  }, [onlineUsers]);\n\n  const handleUserUpdateRef = useRef<(newUsers: Record<string, unknown> | null) => void>(() => {});\n\n  const { setUsers, clearUsers, setRoom, flushPendingUpdates } = useUserListStore(\n    useShallow((s) => ({\n      setUsers: s.setUsers,\n      clearUsers: s.clearUsers,\n      setRoom: s.setRoom,\n      flushPendingUpdates: s.flushPendingUpdates,\n    }))\n  );\n\n  const setUsersRef = useRef(setUsers);\n  const clearUsersRef = useRef(clearUsers);\n  const setRoomRef = useRef(setRoom);\n  const flushPendingUpdatesRef = useRef(flushPendingUpdates);\n\n  useEffect(() => {\n    setUsersRef.current = setUsers;\n    clearUsersRef.current = clearUsers;\n    setRoomRef.current = setRoom;\n    flushPendingUpdatesRef.current = flushPendingUpdates;\n  }, [setUsers, clearUsers, setRoom, flushPendingUpdates]);\n\n  useEffect(() => {\n    handleUserUpdateRef.current = (newUsers: Record<string, unknown> | null) => {\n      if (newUsers === null) {\n        clearUsersRef.current();\n        return;\n      }\n\n      const validatedUsers: Record<string, OnlineUser> = {};\n\n      Object.entries(newUsers).forEach(([uid, userData]) => {\n        if (isValidOnlineUser(userData)) {\n          const user: OnlineUser = {\n            ...userData,\n            lastSeen:\n              userData.lastSeen instanceof Date\n                ? userData.lastSeen\n                : new Date(userData.lastSeen as string | number),\n          };\n          validatedUsers[uid] = user;\n        }\n      });\n\n      setUsersRef.current(validatedUsers);\n    };\n  }, []);\n\n  const handleUserUpdate = useCallback((newUsers: Record<string, unknown> | null) => {\n    handleUserUpdateRef.current?.(newUsers);\n  }, []);\n\n  const cleanup = useCallback(() => {\n    if (unsubscribeRef.current) {\n      unsubscribeRef.current();\n      unsubscribeRef.current = null;\n    }\n    flushPendingUpdatesRef.current();\n  }, []);\n\n  useEffect(() => {\n    if (prevRoomRef.current !== room) {\n      setRoomRef.current(room || null);\n      prevRoomRef.current = room;\n    }\n\n    if (!room) {\n      cleanup();\n      clearUsersRef.current();\n      return;\n    }\n\n    cleanup();\n\n    const unsubscribe = getUserList(room, handleUserUpdate, onlineUsersRef.current);\n    unsubscribeRef.current = unsubscribe || null;\n\n    return cleanup;\n  }, [room, handleUserUpdate, cleanup]);\n\n  useEffect(() => {\n    return cleanup;\n  }, [cleanup]);\n\n  const value = useMemo(() => ({ onlineUsers }), [onlineUsers]);\n\n  return <UserListContext.Provider value={value} {...props} />;\n}\n\nexport { UserListProvider };\n","import React from 'react';\nimport { ScheduleContext, ScheduleContextType } from '../schedule';\n\nexport default function useSchedule(): ScheduleContextType {\n  const value = React.useContext(ScheduleContext);\n\n  if (!value) {\n    throw new Error(\"ScheduleContext's value is undefined.\");\n  }\n\n  return value;\n}\n","import { useContext } from 'react';\nimport { AuthContext, AuthContextType } from '@/context/auth';\n\nexport default function useAuth(): Omit<AuthContextType, 'user'> & {\n  user: NonNullable<AuthContextType['user']>;\n} {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context as Omit<AuthContextType, 'user'> & { user: NonNullable<AuthContextType['user']> };\n}\n","import React from 'react';\nimport { MessagesContext, MessagesContextType } from '../messages';\n\nexport default function useMessages(): MessagesContextType {\n  const value = React.useContext(MessagesContext);\n\n  if (!value) {\n    throw new Error(\"MessagesContext's value is undefined.\");\n  }\n\n  return value;\n}\n","import { createContext, useContext, useState, useEffect, ReactNode } from 'react';\n\n// Minimal auth context for initial load - no Firebase imports\nexport interface MinimalAuthContextType {\n  initializing: boolean;\n  hasUser: boolean;\n}\n\nconst MinimalAuthContext = createContext<MinimalAuthContextType>({\n  initializing: true,\n  hasUser: false,\n});\n\n// eslint-disable-next-line react-refresh/only-export-components\nexport const useMinimalAuth = () => useContext(MinimalAuthContext);\n\ninterface MinimalAuthProviderProps {\n  children: ReactNode;\n}\n\nexport function MinimalAuthProvider({ children }: MinimalAuthProviderProps) {\n  const [initializing, setInitializing] = useState(true);\n  const [hasUser, setHasUser] = useState(false);\n\n  useEffect(() => {\n    // Quick check for existing auth without loading Firebase\n    const checkAuth = () => {\n      let hasStoredAuth = false;\n\n      try {\n        // Check if there's a stored user session or token\n        hasStoredAuth = !!(\n          localStorage.getItem('firebase:authUser:') ||\n          sessionStorage.getItem('firebase:authUser:') ||\n          document.cookie.includes('firebase-auth')\n        );\n      } catch (error) {\n        // Handle SecurityError in iOS Safari private browsing or restricted contexts\n        console.warn(\n          'Authentication check failed due to storage restrictions (e.g., private browsing mode):',\n          error\n        );\n        hasStoredAuth = false;\n      }\n\n      setHasUser(hasStoredAuth);\n      setInitializing(false);\n    };\n\n    // Small delay to allow instant loading screen to show\n    setTimeout(checkAuth, 50);\n  }, []);\n\n  return (\n    <MinimalAuthContext.Provider value={{ initializing, hasUser }}>\n      {children}\n    </MinimalAuthContext.Provider>\n  );\n}\n"],"file":"js/chunk-Dai8FbIP.js"}