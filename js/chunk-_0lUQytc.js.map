{"version":3,"file":"chunk-_0lUQytc.js","sources":["../../src/helpers/cssUrl.ts","../../src/components/DirectMediaHandler/index.tsx","../../src/components/ImageSlideshow/index.tsx","../../src/services/redditService.ts","../../src/hooks/useRedditFeed.ts","../../src/components/RedditSlideshow/index.tsx","../../src/components/RoomBackground/index.tsx","../../src/services/getBackgroundSource.ts","../../src/hooks/useTurnIndicator.ts"],"sourcesContent":["/**\n * Creates a properly formatted CSS url() string with safe escaping\n * @param url - The URL to format for CSS\n * @returns A properly formatted CSS url() string\n */\nexport function cssUrl(url: string): string {\n  // Convert to string and strip control characters by iterating over code points\n  let cleanedUrl = '';\n  for (const char of String(url)) {\n    const codePoint = char.codePointAt(0)!; // Non-null assertion safe here since char is from string iteration\n\n    // Filter out control characters:\n    // - C0 controls: U+0000 to U+001F\n    // - DEL: U+007F\n    // - C1 controls: U+0080 to U+009F\n    // - Line separator: U+2028\n    // - Paragraph separator: U+2029\n    if (\n      !(\n        (codePoint >= 0x00 && codePoint <= 0x1f) ||\n        codePoint === 0x7f ||\n        (codePoint >= 0x80 && codePoint <= 0x9f) ||\n        codePoint === 0x2028 ||\n        codePoint === 0x2029\n      )\n    ) {\n      cleanedUrl += char;\n    }\n  }\n\n  // Escape backslashes and double quotes\n  const escapedUrl = cleanedUrl.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n\n  return `url(\"${escapedUrl}\")`;\n}\n","import { useEffect, useState } from 'react';\n\nimport { cssUrl } from '@/helpers/cssUrl';\n\ninterface DirectMediaHandlerProps {\n  url: string | null;\n}\n\nconst inferMediaType = (u: string | null): 'video' | 'image' => {\n  if (!u) return 'video';\n  // Treat image formats as images (including GIFs and modern formats)\n  if (/\\.(jpe?g|png|webp|bmp|svg|gif|avif|tiff?|heic|heif|jfif)(\\?.*)?$/i.test(u)) return 'image';\n  // Default to video for video extensions or unknown URLs\n  return 'video';\n};\n\nfunction DirectMediaHandler({ url }: DirectMediaHandlerProps) {\n  const [mediaType, setMediaType] = useState<'video' | 'image'>(inferMediaType(url));\n  const [currentUrl, setCurrentUrl] = useState(url);\n\n  // Reset state when URL prop changes\n  useEffect(() => {\n    setCurrentUrl(url);\n    setMediaType(inferMediaType(url));\n  }, [url]);\n\n  if (!currentUrl) return null;\n\n  const handleVideoError = () => {\n    const failingUrl = currentUrl ?? url ?? '';\n    // Special handling for Imgur URLs\n    let isImgur = false;\n    try {\n      const parsed = new URL(failingUrl);\n      isImgur = parsed.host === 'imgur.com' || parsed.host === 'i.imgur.com';\n    } catch {\n      // If URL parsing fails, skip Imgur-specific logic for security\n      isImgur = false;\n    }\n\n    if (isImgur) {\n      const imgurId = failingUrl.match(/(?:i\\.)?imgur\\.com\\/([a-zA-Z0-9]+)(?:\\.[a-z]+)?/)?.[1];\n      if (imgurId) {\n        const imageUrl = `https://i.imgur.com/${imgurId}.jpg`;\n        setCurrentUrl(imageUrl);\n        setMediaType('image');\n        return;\n      }\n    }\n\n    // For other URLs, try changing extension from .mp4 to common image formats\n    const baseUrl = failingUrl.replace(/\\.(mp4|webm|ogg|mov)(\\?.*)?$/i, '');\n    const imageUrl = `${baseUrl}.jpg`;\n    setCurrentUrl(imageUrl);\n    setMediaType('image');\n  };\n\n  const handleImageError = () => {\n    const failingUrl = currentUrl ?? url ?? '';\n    let isImgur = false;\n    try {\n      const parsed = new URL(failingUrl);\n      isImgur = parsed.host === 'imgur.com' || parsed.host === 'i.imgur.com';\n    } catch {\n      // If URL parsing fails, skip Imgur-specific logic for security\n      isImgur = false;\n    }\n\n    if (isImgur) {\n      // Imgur-specific format trying\n      const imgurId = failingUrl.match(/(?:i\\.)?imgur\\.com\\/([a-zA-Z0-9]+)(?:\\.[a-z]+)?/)?.[1];\n      if (imgurId) {\n        const formats = ['jpg', 'png', 'gif', 'jpeg', 'webp'];\n        const currentFormat = currentUrl?.split('.').pop();\n        const currentIndex = formats.indexOf(currentFormat || '');\n        const nextIndex = currentIndex + 1;\n\n        if (nextIndex < formats.length) {\n          const nextFormat = formats[nextIndex];\n          const nextUrl = `https://i.imgur.com/${imgurId}.${nextFormat}`;\n          setCurrentUrl(nextUrl);\n        }\n      }\n    } else {\n      // For other URLs, try different image extensions\n      const formats = ['jpg', 'png', 'gif', 'jpeg', 'webp'];\n      const currentFormat = currentUrl?.split('.').pop();\n      const currentIndex = formats.indexOf(currentFormat || '');\n      const nextIndex = currentIndex + 1;\n\n      if (nextIndex < formats.length && currentUrl) {\n        const nextFormat = formats[nextIndex];\n        const baseUrl = currentUrl.replace(/\\.[^.]+(\\?.*)?$/, '');\n        const nextUrl = `${baseUrl}.${nextFormat}`;\n        setCurrentUrl(nextUrl);\n      }\n    }\n  };\n\n  if (mediaType === 'video') {\n    return (\n      <video\n        autoPlay={true}\n        loop={true}\n        muted={true}\n        playsInline={true}\n        src={currentUrl || undefined}\n        className=\"video-background\"\n        onError={handleVideoError}\n        // Cast-specific optimizations\n        preload=\"auto\"\n        crossOrigin=\"anonymous\"\n        controls={true}\n      />\n    );\n  }\n\n  // Render as background image - use hidden img for error handling\n  return (\n    <>\n      <div\n        className=\"image-background\"\n        style={{\n          backgroundImage: currentUrl ? cssUrl(currentUrl) : undefined,\n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n          backgroundRepeat: 'no-repeat',\n          width: '100%',\n          height: '100%',\n          position: 'absolute',\n          top: 0,\n          left: 0,\n        }}\n      />\n      <img\n        src={currentUrl || undefined}\n        onError={handleImageError}\n        style={{ display: 'none' }}\n        alt=\"\"\n      />\n    </>\n  );\n}\n\nexport default DirectMediaHandler;\n","import './styles.css';\n\nimport { useEffect, useRef, useState } from 'react';\n\nimport clsx from 'clsx';\nimport { useTranslation } from 'react-i18next';\n\ninterface ImageSlideshowProps {\n  images: string[];\n  className?: string;\n  zoomDuration?: number; // Duration in milliseconds\n  zoomScale?: number; // Scale factor (e.g., 1.4 = 140%)\n}\n\nexport default function ImageSlideshow({\n  images,\n  className,\n  zoomDuration = 3000,\n  zoomScale = 1.4,\n}: ImageSlideshowProps) {\n  const { t } = useTranslation();\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [imageKey, setImageKey] = useState(0);\n  const [preloadedImages, setPreloadedImages] = useState<Set<string>>(new Set());\n  const [imageLoadErrors, setImageLoadErrors] = useState<Set<string>>(new Set());\n  const [hasLoadedFirstImage, setHasLoadedFirstImage] = useState(false);\n\n  const intervalRef = useRef<number | null>(null);\n  const preloadRef = useRef<Map<string, HTMLImageElement>>(new Map());\n\n  // Reset loading state when images change\n  useEffect(() => {\n    setHasLoadedFirstImage(false);\n    setPreloadedImages(new Set());\n    setImageLoadErrors(new Set());\n    preloadRef.current.clear();\n    setCurrentIndex(0);\n    setImageKey(0);\n  }, [images]);\n\n  // Preload images for smooth transitions\n  useEffect(() => {\n    if (images.length === 0) return;\n\n    const preloadImage = (src: string): Promise<void> => {\n      return new Promise((resolve) => {\n        // Skip if already preloaded or failed\n        if (preloadRef.current.has(src) || imageLoadErrors.has(src)) {\n          resolve();\n          return;\n        }\n\n        const img = new Image();\n        img.onload = () => {\n          preloadRef.current.set(src, img);\n          setPreloadedImages((prev) => {\n            const newSet = new Set(prev).add(src);\n            // Mark first image as loaded if this is the first image we've loaded\n            if (!hasLoadedFirstImage && src === images[0]) {\n              setHasLoadedFirstImage(true);\n            }\n            return newSet;\n          });\n          resolve();\n        };\n        img.onerror = () => {\n          setImageLoadErrors((prev) => new Set(prev).add(src));\n          resolve();\n        };\n        img.src = src;\n      });\n    };\n\n    // Preload current and next few images\n    const preloadNext = async () => {\n      const preloadCount = Math.min(5, images.length); // Preload next 5 images\n      const preloadPromises: Promise<void>[] = [];\n\n      for (let i = 0; i < preloadCount; i++) {\n        const index = (currentIndex + i) % images.length;\n        preloadPromises.push(preloadImage(images[index]));\n      }\n\n      await Promise.all(preloadPromises);\n    };\n\n    preloadNext();\n  }, [images, currentIndex, imageLoadErrors, hasLoadedFirstImage]);\n\n  // Start slideshow when images are available\n  useEffect(() => {\n    if (images.length === 0) return;\n    if (images.length === 1) return; // No cycling needed for single image\n\n    const startSlideshow = () => {\n      intervalRef.current = window.setInterval(() => {\n        setCurrentIndex((prev) => (prev + 1) % images.length);\n        setImageKey((prev) => prev + 1);\n      }, zoomDuration);\n    };\n\n    // Start cycling after brief delay to allow for initial preloading\n    const initialDelay = window.setTimeout(startSlideshow, 2000);\n\n    return () => {\n      window.clearTimeout(initialDelay);\n      if (intervalRef.current) {\n        window.clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [images.length, zoomDuration]);\n\n  // Cleanup interval on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        window.clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, []);\n\n  const currentImage = images[currentIndex] || '';\n  const isCurrentImagePreloaded =\n    preloadedImages.has(currentImage) || preloadRef.current.has(currentImage);\n  const hasCurrentImageError = imageLoadErrors.has(currentImage);\n\n  // Skip to next image if current image failed to load\n  useEffect(() => {\n    if (hasCurrentImageError && images.length > 1) {\n      // Check if all images have failed to prevent infinite loop\n      const allImagesFailed = images.every((img) => imageLoadErrors.has(img));\n      if (!allImagesFailed) {\n        const nextIndex = (currentIndex + 1) % images.length;\n        setCurrentIndex(nextIndex);\n        setImageKey((prev) => prev + 1);\n      }\n    }\n  }, [hasCurrentImageError, currentIndex, images.length, images, imageLoadErrors]);\n\n  if (images.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={clsx('image-slideshow-container', className)} aria-hidden>\n      {/* Fallback background during loading */}\n      <div className=\"image-slideshow-fallback\" />\n\n      {/* Show loading message while waiting for first image */}\n      {!hasLoadedFirstImage && images.length > 0 && (\n        <div className=\"loading-message\">{t('loadingImages')}</div>\n      )}\n\n      {/* Only show image if it's preloaded and not errored */}\n      {isCurrentImagePreloaded && !hasCurrentImageError && (\n        <div\n          key={imageKey}\n          className=\"image-slideshow-slide\"\n          style={\n            {\n              backgroundImage: `url(${currentImage})`,\n              animationDuration: `${zoomDuration}ms`,\n              '--zoom-scale': zoomScale,\n            } as React.CSSProperties & { '--zoom-scale': number }\n          }\n        />\n      )}\n    </div>\n  );\n}\n","// Dedicated service for fetching images from Reddit\n\nexport interface RedditFeedConfig {\n  subreddit: string;\n  maxImages?: number;\n}\n\nexport interface RedditFeedResult {\n  images: string[];\n  source: string;\n}\n\n// Basic HTML entity decoding for Reddit preview URLs\nfunction decodeHtmlEntities(str: string): string {\n  return str.replace(/&amp;/g, '&');\n}\n\n// Multiple proxy services for CORS issues as fallbacks\n// cspell:ignore jina allorigins\nconst PROXY_SERVICES = ['r.jina.ai', 'api.allorigins.win/get?url=', 'corsproxy.io/?'];\n\nconst toProxyUrl = (url: string, serviceIndex: number = 0) => {\n  const service = PROXY_SERVICES[serviceIndex];\n  if (service === 'api.allorigins.win/get?url=') {\n    return `https://${service}${encodeURIComponent(url)}`;\n  }\n  if (service === 'corsproxy.io/?') {\n    return `https://${service}${encodeURIComponent(url)}`;\n  }\n  const withoutScheme = url.replace(/^https?:\\/\\//, '');\n  const scheme = url.startsWith('https://') ? 'https' : 'http';\n  return `https://${service}/${scheme}://${withoutScheme}`;\n};\n\n// Reddit-specific fetching logic\nexport async function fetchRedditImages(\n  subreddit: string,\n  maxCount: number,\n  signal: AbortSignal\n): Promise<string[]> {\n  const collected = new Set<string>();\n  let after: string | null = null;\n\n  const endpoints = [\n    // Use Reddit RSS/JSON feeds which are more permissive\n    (a: string | null) =>\n      `https://www.reddit.com/r/${subreddit}/top.json?limit=100&t=year&raw_json=1${a ? `&after=${a}` : ''}`,\n    (a: string | null) =>\n      `https://www.reddit.com/r/${subreddit}/hot.json?limit=100&raw_json=1${a ? `&after=${a}` : ''}`,\n  ];\n\n  const fetchJson = async (url: string): Promise<any | null> => {\n    // Try direct fetch with Reddit-friendly headers\n    try {\n      const resp = await fetch(url, {\n        signal,\n        credentials: 'omit',\n        mode: 'cors',\n        headers: {\n          'User-Agent': 'BlitzedOut/1.0',\n          Accept: 'application/json, text/plain, */*',\n          'Accept-Language': 'en-US,en;q=0.9',\n        },\n      });\n      if (resp.ok) {\n        const text = await resp.text();\n        try {\n          return JSON.parse(text);\n        } catch {\n          // Try to extract JSON from HTML response\n          const start = text.indexOf('{');\n          const end = text.lastIndexOf('}');\n          if (start !== -1 && end !== -1 && end > start) {\n            try {\n              return JSON.parse(text.slice(start, end + 1));\n            } catch {\n              return null;\n            }\n          }\n          return null;\n        }\n      }\n    } catch (error) {\n      if (error instanceof DOMException && error.name === 'AbortError') {\n        throw error;\n      }\n    }\n\n    // Try multiple CORS proxy services\n    for (let i = 0; i < PROXY_SERVICES.length; i++) {\n      try {\n        const proxyResp = await fetch(toProxyUrl(url, i), {\n          signal,\n          credentials: 'omit',\n          mode: 'cors',\n          headers: {\n            'User-Agent': 'BlitzedOut/1.0',\n            Accept: 'application/json, text/plain, */*',\n          },\n        });\n\n        if (!proxyResp.ok) continue;\n\n        const text = await proxyResp.text();\n\n        // Handle different proxy response formats\n        let jsonData;\n        try {\n          const parsed = JSON.parse(text);\n          // AllOrigins wraps response in contents property\n          jsonData = parsed.contents ? JSON.parse(parsed.contents) : parsed;\n        } catch {\n          // Try to extract JSON from HTML response\n          const start = text.indexOf('{');\n          const end = text.lastIndexOf('}');\n          if (start !== -1 && end !== -1 && end > start) {\n            try {\n              jsonData = JSON.parse(text.slice(start, end + 1));\n            } catch {\n              continue;\n            }\n          } else {\n            continue;\n          }\n        }\n\n        if (jsonData) {\n          return jsonData;\n        }\n      } catch (error) {\n        if (error instanceof DOMException && error.name === 'AbortError') {\n          throw error;\n        }\n        continue;\n      }\n    }\n\n    return null;\n  };\n\n  let endpointIndex = 0;\n  while (collected.size < maxCount && endpointIndex < endpoints.length) {\n    after = null;\n    for (let page = 0; page < 5 && collected.size < maxCount; page += 1) {\n      const url = endpoints[endpointIndex](after);\n      const json = await fetchJson(url);\n      if (!json) break;\n\n      const children = json?.data?.children ?? [];\n      after = json?.data?.after ?? null;\n\n      for (const child of children) {\n        const data = child?.data;\n        if (!data) continue;\n\n        const direct = data.url_overridden_by_dest as string | undefined;\n        const postHint = data.post_hint as string | undefined;\n\n        // Gallery support\n        if (data.is_gallery && data.media_metadata && data.gallery_data) {\n          const items = (data.gallery_data.items || []) as Array<{ media_id: string }>;\n          for (const it of items) {\n            const meta = data.media_metadata[it.media_id];\n            const source = meta?.s?.u || meta?.s?.gif || meta?.s?.mp4;\n            if (typeof source === 'string') {\n              const normalized = source.startsWith('http') ? source : `https:${source}`;\n              if (/\\.(jpe?g|png|gif|webp)(\\?.*)?$/i.test(normalized)) {\n                collected.add(decodeHtmlEntities(normalized));\n              }\n            }\n          }\n          continue;\n        }\n\n        if (postHint === 'image' && typeof direct === 'string') {\n          if (/\\.(jpe?g|png|gif|webp)(\\?.*)?$/i.test(direct)) {\n            collected.add(decodeHtmlEntities(direct));\n            continue;\n          }\n        }\n\n        const preview = data.preview?.images?.[0]?.source?.url as string | undefined;\n        if (preview) {\n          const normalized = preview.startsWith('http') ? preview : `https:${preview}`;\n          collected.add(decodeHtmlEntities(normalized));\n        }\n      }\n\n      if (!after) break;\n    }\n    endpointIndex += 1;\n  }\n\n  return Array.from(collected).slice(0, maxCount);\n}\n\n// Main Reddit service function\nexport async function fetchRedditFeed(\n  config: RedditFeedConfig,\n  signal: AbortSignal\n): Promise<RedditFeedResult> {\n  const maxImages = config.maxImages || 150;\n  const images = await fetchRedditImages(config.subreddit, maxImages, signal);\n\n  return {\n    images,\n    source: `r/${config.subreddit}`,\n  };\n}\n\n// Helper functions\nexport function isRedditUrl(url: string): boolean {\n  try {\n    const parsed = new URL(url);\n    return /(^|\\.)reddit\\.com$/i.test(parsed.hostname) && /\\/r\\//i.test(parsed.pathname);\n  } catch {\n    return false;\n  }\n}\n\nexport function extractSubredditFromUrl(url: string): string | null {\n  try {\n    const parsed = new URL(url);\n    const match = parsed.pathname.match(/\\/r\\/([^/]+)/i);\n    return match?.[1] ?? null;\n  } catch {\n    return null;\n  }\n}\n\n// Cache management for Reddit feeds\nconst CACHE_TTL_MS = 300_000; // 300 seconds (5 minutes)\nconst cache = new Map<string, { fetchedAt: number; result: RedditFeedResult }>();\nconst inFlight = new Map<string, Promise<RedditFeedResult>>();\n\nexport async function getCachedRedditFeed(\n  config: RedditFeedConfig,\n  signal: AbortSignal\n): Promise<RedditFeedResult> {\n  const cacheKey = JSON.stringify(config);\n  const now = Date.now();\n\n  const cached = cache.get(cacheKey);\n  if (cached && now - cached.fetchedAt < CACHE_TTL_MS) {\n    return cached.result;\n  }\n\n  const existing = inFlight.get(cacheKey);\n  if (existing) {\n    try {\n      return await existing;\n    } catch {\n      // fall through to fresh fetch\n    }\n  }\n\n  const promise = fetchRedditFeed(config, signal)\n    .then((result) => {\n      cache.set(cacheKey, { fetchedAt: Date.now(), result });\n      return result;\n    })\n    .finally(() => {\n      inFlight.delete(cacheKey);\n    });\n\n  inFlight.set(cacheKey, promise);\n  return promise;\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\n\nimport {\n  type RedditFeedConfig,\n  getCachedRedditFeed,\n  extractSubredditFromUrl,\n  isRedditUrl,\n} from '@/services/redditService';\n\ninterface UseRedditFeedResult {\n  images: string[];\n  isLoading: boolean;\n  error: string | null;\n  source: string | null;\n}\n\nexport function useRedditFeed(url: string | null): UseRedditFeedResult {\n  const { t } = useTranslation();\n  const [images, setImages] = useState<string[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [errorCode, setErrorCode] = useState<string | null>(null);\n  const [source, setSource] = useState<string | null>(null);\n\n  const abortRef = useRef<AbortController | null>(null);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    // Cleanup previous request and timeouts\n    if (abortRef.current) {\n      abortRef.current.abort();\n    }\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n    if (retryTimeoutRef.current) {\n      clearTimeout(retryTimeoutRef.current);\n      retryTimeoutRef.current = null;\n    }\n\n    // Reset state\n    setImages([]);\n    setErrorCode(null);\n    setSource(null);\n\n    // Check if URL is a Reddit URL\n    if (!url || !isRedditUrl(url)) {\n      setIsLoading(false);\n      return;\n    }\n\n    const subreddit = extractSubredditFromUrl(url);\n    if (!subreddit) {\n      setErrorCode('invalidRedditUrl');\n      setIsLoading(false);\n      return;\n    }\n\n    const config: RedditFeedConfig = {\n      subreddit,\n      maxImages: 150,\n    };\n\n    setIsLoading(true);\n    const controller = new AbortController();\n    abortRef.current = controller;\n\n    const loadRedditImages = async (retryCount = 0) => {\n      try {\n        const result = await getCachedRedditFeed(config, controller.signal);\n\n        if (controller.signal.aborted) return;\n\n        setImages(result.images);\n        setSource(result.source);\n        setErrorCode(null);\n        setIsLoading(false);\n      } catch {\n        if (controller.signal.aborted) return;\n\n        // Retry logic for Reddit CORS/network issues\n        const maxRetries = 2;\n        if (retryCount < maxRetries) {\n          const retryDelay = Math.pow(2, retryCount) * 1000; // Exponential backoff\n\n          retryTimeoutRef.current = setTimeout(() => {\n            if (!controller.signal.aborted) {\n              loadRedditImages(retryCount + 1);\n            }\n          }, retryDelay);\n          return;\n        }\n\n        // Final error after all retries\n        setErrorCode('redditBlocked');\n        setImages([]);\n        setSource(null);\n        setIsLoading(false);\n      }\n    };\n\n    // Small delay to avoid rapid API calls during development\n    timeoutRef.current = setTimeout(loadRedditImages, 300);\n\n    return () => {\n      controller.abort();\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n        retryTimeoutRef.current = null;\n      }\n    };\n  }, [url]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortRef.current) {\n        abortRef.current.abort();\n      }\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n        retryTimeoutRef.current = null;\n      }\n    };\n  }, []);\n\n  return {\n    images,\n    isLoading,\n    error: errorCode ? t(errorCode) : null,\n    source,\n  };\n}\n","import { alpha, useTheme } from '@mui/material/styles';\n\nimport ImageSlideshow from '@/components/ImageSlideshow';\nimport { useRedditFeed } from '@/hooks/useRedditFeed';\nimport { useTranslation } from 'react-i18next';\n\ninterface RedditSlideshowProps {\n  url: string;\n}\n\nexport default function RedditSlideshow({ url }: RedditSlideshowProps) {\n  const { t } = useTranslation();\n  const theme = useTheme();\n  const { images, isLoading, error } = useRedditFeed(url);\n\n  if (isLoading) {\n    return (\n      <div className=\"slideshow-container slideshow-loading\" aria-hidden>\n        {/* Show fallback gradient background during loading */}\n        <div className=\"image-slideshow-fallback\" />\n        <div className=\"loading-message\">{t('loadingRedditImages')}</div>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"slideshow-container slideshow-error\" aria-hidden>\n        {/* Show fallback gradient background on error */}\n        <div className=\"image-slideshow-fallback\" />\n        <div\n          className=\"error-message\"\n          style={{\n            position: 'absolute',\n            bottom: '20px',\n            right: '20px',\n            background: alpha(theme.palette.background.paper, 0.7),\n            color: theme.palette.text.primary,\n            padding: '12px 16px',\n            borderRadius: '8px',\n            fontSize: '14px',\n            maxWidth: '300px',\n            zIndex: 1000,\n          }}\n        >\n          <strong>{t('redditBackgroundNote')}</strong>\n          <br />\n          {t('redditBlocked')}\n        </div>\n      </div>\n    );\n  }\n\n  if (images.length === 0) {\n    return (\n      <div className=\"slideshow-container slideshow-empty\" aria-hidden>\n        <div className=\"image-slideshow-fallback\" />\n      </div>\n    );\n  }\n\n  return <ImageSlideshow images={images} />;\n}\n","import './styles.css';\n\nimport { Box } from '@mui/material';\nimport clsx from 'clsx';\n\nimport DirectMediaHandler from '@/components/DirectMediaHandler';\nimport RedditSlideshow from '@/components/RedditSlideshow';\nimport { isRedditUrl } from '@/services/redditService';\n\ninterface RoomBackgroundProps {\n  url?: string | null;\n  isVideo?: boolean | null;\n}\n\nexport default function RoomBackground({ url = null, isVideo = null }: RoomBackgroundProps) {\n  // Check if the URL is a direct video file (MP4, WebM, etc.)\n  const isDirectVideo = url && /\\.(mp4|webm|ogg|mov|gif)(\\?.*)?$/i.test(url);\n\n  // Check if URL is a Reddit URL\n  const isReddit = url ? isRedditUrl(url) : false;\n\n  // Show default background when no custom background is set OR when background is \"color\" or \"gray\"\n  const isNonImageBackground =\n    url === 'color' || url === 'gray' || url?.includes('/color') || url?.includes('/gray');\n  const hasCustomBackground = url && !isNonImageBackground && (isVideo || (!isVideo && url));\n\n  // Special handling for different content types\n  const shouldShowRedditSlideshow = !isVideo && isReddit && url;\n\n  return (\n    <Box\n      className={clsx('main-container', !hasCustomBackground && 'default-background')}\n      role=\"presentation\"\n      sx={{\n        backgroundImage:\n          !isVideo && url && !isNonImageBackground && !isReddit ? `url(${url})` : 'none',\n      }}\n    >\n      {isVideo &&\n        !isReddit &&\n        // Use DirectMediaHandler only for direct video files (e.g., mp4, webm, etc.)\n        (isDirectVideo ? (\n          <DirectMediaHandler url={url} />\n        ) : (\n          <iframe\n            src={url || undefined}\n            title=\"video\"\n            width=\"100%\"\n            height=\"100%\"\n            allow=\"autoplay; fullscreen; encrypted-media; picture-in-picture\"\n            sandbox=\"allow-same-origin allow-scripts allow-presentation\"\n            style={{ border: 'none' }}\n          />\n        ))}\n\n      {/* Reddit slideshow if a Reddit URL is provided */}\n      {shouldShowRedditSlideshow ? <RedditSlideshow url={url} /> : null}\n    </Box>\n  );\n}\n","import { getURLPath } from '@/helpers/urls';\nimport { isPublicRoom } from '@/helpers/strings';\nimport { logger } from '@/utils/logger';\n\nfunction vimeo(url: string): string {\n  const vimeoRegex = /vimeo\\.com\\/(\\d+)/;\n  const match = url.match(vimeoRegex);\n  const videoId = match ? match[1] : '';\n\n  return `https://player.vimeo.com/video/${videoId}?autoplay=1&loop=1&autostart=true`;\n}\n\nfunction youtube(url: string): string {\n  const youtubeRegex =\n    /(?:youtube\\.com\\/(?:[^/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|[^#]*[?&]v=|youtu\\.be\\/)([^\"&?/ ]{11})|^(?:[^\"&?/ ]{11})$)/;\n  const match = url.match(youtubeRegex);\n  const videoId = match ? match[1] : '';\n\n  return `https://www.youtube.com/embed/${videoId}?autoplay=1&loop=1&autostart=true&mute=1&playsinline=1&controls=0&disablekb=1&fs=0&modestbranding=1&rel=0&iv_load_policy=3`;\n}\n\nfunction googleDrive(url: string): string {\n  const driveRegex = /drive\\.google\\.com\\/file\\/d\\/([^/]+)/;\n  const match = url.match(driveRegex);\n  const fileId = match ? match[1] : '';\n\n  return `https://drive.google.com/file/d/${fileId}/preview?loop=1`;\n}\n\nfunction dropBox(url: string): string {\n  const dropBoxRegex = /dropbox\\.com\\/s\\/([^/]+)/;\n  const match = url.match(dropBoxRegex);\n  const fileId = match ? match[1] : '';\n\n  return `https://www.dropbox.com/s/${fileId}?raw=1`;\n}\n\nfunction pornhub(url: string): string {\n  const params = new URL(url);\n  const viewKey = params.searchParams.get('viewkey') || '';\n\n  return `https://pornhub.com/embed/${viewKey}?autoplay=1&loop=1&autostart=true&playsinline=1`;\n}\n\nfunction xhamster(url: string): string {\n  const urlParts = url.split('-');\n  const key = urlParts[urlParts.length - 1];\n\n  return `https://xhamster.com/xembed.php?video=${key}?autoplay=1&loop=1&autostart=true&playsinline=1`;\n}\n\nfunction tenor(url: string): { url: string; isVideo: boolean } {\n  // Handle direct media URLs: https://media.tenor.com/{id}/filename.{ext} or https://media1.tenor.com/m/{id}/filename.{ext}\n  const directMediaRegex =\n    /media1?\\.tenor\\.com\\/(?:m\\/)?([a-zA-Z0-9_-]+)\\/[^/]*\\.(mp4|gif|webp|webm)/;\n  const directMatch = url.match(directMediaRegex);\n\n  if (directMatch) {\n    const extension = directMatch[2].toLowerCase();\n    // Return the direct media URL as-is for direct playback\n    return {\n      url,\n      isVideo: ['mp4', 'webm'].includes(extension),\n    };\n  }\n\n  // Handle view URLs: https://tenor.com/view/{title}-{id}\n  const viewRegex = /tenor\\.com\\/view\\/[^/]*-(\\d+)/;\n  const viewMatch = url.match(viewRegex);\n\n  if (viewMatch) {\n    const numericId = viewMatch[1];\n    // Use Tenor's embed endpoint which will be handled by iframe\n    return {\n      url: `https://tenor.com/embed/${numericId}`,\n      isVideo: true,\n    };\n  }\n\n  // If we can't match any pattern, return the original URL\n  return {\n    url,\n    isVideo: false,\n  };\n}\n\nfunction giphy(url: string): string {\n  const giphyRegex = /giphy\\.com\\/gifs\\/[^/]*-([a-zA-Z0-9]+)/;\n  const match = url.match(giphyRegex);\n  const gifId = match ? match[1] : '';\n\n  // For Cast compatibility, try direct media URL first, fallback to embed\n  // Giphy direct media format: https://media.giphy.com/media/{id}/giphy.gif\n  return `https://media.giphy.com/media/${gifId}/giphy.gif`;\n}\n\nfunction tumblr(url: string): string {\n  // Handle direct Tumblr media URLs: https://64.media.tumblr.com/...\n  // These are already direct media URLs, so return as-is for GIF playback\n  const directMediaRegex = /\\d+\\.media\\.tumblr\\.com\\/.*\\.(gif|mp4|webm)(\\?.*)?$/i;\n  if (directMediaRegex.test(url)) {\n    return url;\n  }\n\n  // Handle other Tumblr URL patterns if needed in the future\n  // For now, just return the URL as-is since most Tumblr media URLs are direct\n  return url;\n}\n\nfunction gfycat(url: string): string {\n  // Handle both gfycat.com and redgifs.com\n  const gfycatRegex = /(?:gfycat\\.com|redgifs\\.com)\\/(?:watch\\/)?([a-zA-Z0-9]+)/;\n  const match = url.match(gfycatRegex);\n  const gifId = match ? match[1] : '';\n\n  // For Cast compatibility, try direct video URLs\n  if (isValidHost(url, ['redgifs.com'])) {\n    // RedGifs direct video format\n    return `https://files.redgifs.com/${gifId}.mp4`;\n  }\n  // Gfycat direct video format\n  return `https://giant.gfycat.com/${gifId}.mp4`;\n}\n\nfunction redtube(url: string): string {\n  const redtubeRegex = /redtube\\.com\\/(\\d+)/;\n  const match = url.match(redtubeRegex);\n  const videoId = match ? match[1] : '';\n  return `https://embed.redtube.com/?id=${videoId}&autoplay=true&auto_play=1&playsinline=1&controls=1`;\n}\n\nfunction youporn(url: string): string {\n  const youpornRegex = /youporn\\.com\\/watch\\/(\\d+)/;\n  const match = url.match(youpornRegex);\n  const videoId = match ? match[1] : '';\n\n  return `https://www.youporn.com/embed/${videoId}?autoplay=1&playsinline=1`;\n}\n\nfunction tube8(url: string): string {\n  const tube8Regex = /tube8\\.com\\/[^/]+\\/[^/]+\\/(\\d+)/;\n  const match = url.match(tube8Regex);\n  const videoId = match ? match[1] : '';\n\n  return `https://www.tube8.com/embed/${videoId}?autoplay=1&playsinline=1`;\n}\n\nfunction twitter(url: string): string {\n  // Twitter/X embed: use twitframe.com to generate an embeddable URL for the tweet\n  // This works for most public tweets and does not require API keys\n  return `https://twitframe.com/show?url=${encodeURIComponent(url)}`;\n}\n\nfunction thisvid(url: string): string {\n  // Thisvid URLs don't have extractable IDs in a predictable format\n  // Return the original URL as-is since the site handles its own embedding\n  return url;\n}\n\nfunction boyfriendtv(url: string): string {\n  // BoyfriendTV URLs don't have extractable IDs in a predictable format\n  // Return the original URL as-is since the site handles its own embedding\n  return url;\n}\n\nfunction imgur(url: string): string {\n  // For Discord proxy URLs that contain Imgur links, just return the URL directly\n  try {\n    const parsed = new URL(url);\n    // Check if this is a legitimate Discord external proxy URL for Imgur\n    // Discord external URLs follow the pattern: /external/{hash}/https/i.imgur.com/{id}.{ext}\n    if (\n      (parsed.host === 'discordapp.net' || parsed.host.endsWith('.discordapp.net')) &&\n      parsed.pathname.startsWith('/external/') &&\n      (parsed.pathname.includes('/https/i.imgur.com/') ||\n        parsed.pathname.includes('/https/imgur.com/'))\n    ) {\n      return url;\n    }\n  } catch (error) {\n    // If URL parsing fails, skip Discord proxy check for security\n    logger.debug('URL parsing failed for Discord proxy check:', error);\n  }\n\n  // Check if URL is already a direct i.imgur.com link with parameters or extension and return unchanged\n  try {\n    const parsed = new URL(url);\n    if (parsed.host === 'i.imgur.com') {\n      // Only return unchanged if it has parameters or a file extension\n      if (parsed.search || parsed.pathname.match(/\\.[a-zA-Z0-9]+$/)) {\n        return url;\n      }\n      // If it's a bare i.imgur.com URL without extension or parameters, continue processing\n    }\n  } catch (error) {\n    logger.debug('URL parsing failed for direct link check:', error);\n  }\n\n  // Extract the Imgur ID from different possible URL formats\n  let imgurId = '';\n\n  // Validate that this is actually an Imgur URL for security\n  let isImgur = false;\n  try {\n    const parsed = new URL(url);\n    isImgur = parsed.host === 'imgur.com' || parsed.host === 'i.imgur.com';\n  } catch (error) {\n    // If URL parsing fails, skip processing for security\n    logger.debug('URL parsing failed for Imgur processing:', error);\n    return '';\n  }\n\n  if (!isImgur) {\n    // Not a valid Imgur URL, return empty string\n    return '';\n  }\n\n  // Handle gallery URLs like:\n  // https://imgur.com/gallery/title-3YkU9Yc#6fDSu6z (with fragment)\n  // https://imgur.com/gallery/fusion-friday-wIJ8AJs (without fragment)\n  if (url.includes('/gallery/')) {\n    const galleryMatch = url.match(/imgur\\.com\\/gallery\\/[^#]*#([a-zA-Z0-9]+)/);\n    if (galleryMatch) {\n      // Gallery URL with fragment - use the fragment ID (this is usually a direct image ID)\n      imgurId = galleryMatch[1];\n    } else {\n      // Gallery URL without fragment - these are tricky because the ID in the path\n      // is often a gallery ID, not a direct image ID. For galleries, we should\n      // return the original URL and let the browser handle it, or try common formats\n      const pathMatch = url.match(/imgur\\.com\\/gallery\\/.*-([a-zA-Z0-9]+)/);\n      if (pathMatch) {\n        // Try the extracted ID but note this might not work for all galleries\n        imgurId = pathMatch[1];\n      } else {\n        // If we can't extract an ID, return the original URL for graceful handling\n        logger.debug('Could not extract image ID from gallery URL, returning original:', url);\n        return url;\n      }\n    }\n  } else {\n    // Handle regular URLs - enhanced regex to be more inclusive\n    const imgurRegex =\n      /imgur\\.com\\/([a-zA-Z0-9]+)(?:\\.(mp4|mov|avi|webm|mkv|flv|wmv|jpg|jpeg|png|gif|gifv|webp|bmp|tiff|svg))?|images-ext-\\d+\\.discordapp\\.net\\/external\\/[^/]+\\/https\\/i\\.imgur\\.com\\/([a-zA-Z0-9]+)\\.(mp4|mov|avi|webm|mkv|flv|wmv|jpg|jpeg|png|gif|gifv|webp|bmp|tiff|svg)/;\n    const match = url.match(imgurRegex);\n    imgurId = match ? match[1] || match[3] : '';\n  }\n\n  if (!imgurId) {\n    return '';\n  }\n\n  // Enhanced extension detection with more inclusive regex\n  const extensionMatch = url.match(/\\.([a-zA-Z0-9]+)(?:\\?.*)?$/);\n  let extension = 'jpg'; // Use .jpg as default instead of .gif for better compatibility\n\n  if (extensionMatch && extensionMatch[1]) {\n    // Preserve the original extension if it exists\n    let originalExtension = extensionMatch[1].toLowerCase();\n\n    // Extension mapping for compatibility - convert .gifv to .mp4\n    const extensionMap: { [key: string]: string } = {\n      gifv: 'mp4',\n    };\n\n    if (extensionMap[originalExtension]) {\n      originalExtension = extensionMap[originalExtension];\n    }\n\n    // Only use common image/video extensions for security\n    if (\n      [\n        'jpg',\n        'jpeg',\n        'png',\n        'gif',\n        'webp',\n        'mp4',\n        'mov',\n        'avi',\n        'webm',\n        'mkv',\n        'flv',\n        'wmv',\n        'bmp',\n        'tiff',\n        'svg',\n      ].includes(originalExtension)\n    ) {\n      extension = originalExtension;\n    }\n  }\n\n  const finalUrl = `https://i.imgur.com/${imgurId}.${extension}`;\n\n  // Return direct link with preserved or converted extension\n  return finalUrl;\n}\n\nfunction isDirectVideoUrl(url: string): boolean {\n  return /\\.(mp4|webm|ogg|mov)(\\?.*)?$/.test(url);\n}\n\nfunction isDiscordMediaUrl(url: string): boolean {\n  return isValidHost(url, ['media.discordapp.net', 'cdn.discordapp.com']) && !isDirectVideoUrl(url);\n}\n\nfunction isValidHost(url: string, allowedHosts: string[]): boolean {\n  try {\n    const parsed = new URL(url);\n    return allowedHosts.some((host) => parsed.host === host || parsed.host.endsWith('.' + host));\n  } catch (error) {\n    // If URL parsing fails, reject for security\n    logger.debug('URL parsing failed in isValidHost, rejecting for security:', error);\n    return false;\n  }\n}\n\ninterface BackgroundResult {\n  url: string | null;\n  isVideo: boolean;\n}\n\nexport function processBackground(url: string | null | undefined): BackgroundResult {\n  let embedUrl: string | null = null;\n  let isVideo = true;\n\n  if (!url) {\n    return { url: '', isVideo: false };\n  }\n\n  switch (true) {\n    case isValidHost(url, ['vimeo.com']):\n      embedUrl = vimeo(url);\n      break;\n    case isValidHost(url, ['youtube.com', 'youtu.be']):\n      embedUrl = youtube(url);\n      break;\n    case isValidHost(url, ['drive.google.com']):\n      embedUrl = googleDrive(url);\n      break;\n    case isValidHost(url, ['pornhub.com']):\n      embedUrl = pornhub(url);\n      break;\n    case isValidHost(url, ['xhamster.com']):\n      embedUrl = xhamster(url);\n      break;\n    case isValidHost(url, ['dropbox.com']):\n      embedUrl = dropBox(url);\n      break;\n    case isValidHost(url, ['imgur.com', 'i.imgur.com']):\n      embedUrl = imgur(url);\n      break;\n    case isValidHost(url, ['tenor.com']): {\n      const tenorResult = tenor(url);\n      embedUrl = tenorResult.url;\n      isVideo = tenorResult.isVideo;\n      break;\n    }\n    case isValidHost(url, ['giphy.com']):\n      embedUrl = giphy(url);\n      isVideo = true;\n      break;\n    case isValidHost(url, ['tumblr.com', 'media.tumblr.com']) ||\n      /\\d+\\.media\\.tumblr\\.com/.test(url):\n      embedUrl = tumblr(url);\n      isVideo = embedUrl ? isDirectVideoUrl(embedUrl) : false;\n      break;\n    case isValidHost(url, ['gfycat.com', 'redgifs.com']):\n      embedUrl = gfycat(url);\n      isVideo = true;\n      break;\n    case isValidHost(url, ['redtube.com']):\n      embedUrl = redtube(url);\n      break;\n    case isValidHost(url, ['youporn.com']):\n      embedUrl = youporn(url);\n      break;\n    case isValidHost(url, ['tube8.com']):\n      embedUrl = tube8(url);\n      break;\n    case isValidHost(url, ['twitter.com', 'x.com']):\n      embedUrl = twitter(url);\n      isVideo = false;\n      break;\n    case isValidHost(url, ['thisvid.com']):\n      embedUrl = thisvid(url);\n      break;\n    case isValidHost(url, ['boyfriendtv.com']):\n      embedUrl = boyfriendtv(url);\n      break;\n    case isDiscordMediaUrl(url):\n      embedUrl = url;\n      isVideo = false;\n      break;\n    case isDirectVideoUrl(url):\n      embedUrl = url;\n      break;\n    default:\n      embedUrl = getURLPath(url);\n      isVideo = false;\n      break;\n  }\n  return {\n    url: embedUrl,\n    isVideo,\n  };\n}\n\ninterface BackgroundSettings {\n  background?: string;\n  backgroundURL?: string;\n  roomBackground?: string;\n  roomBackgroundURL?: string;\n}\n\nexport default function getBackgroundSource(\n  settings: BackgroundSettings,\n  room: string\n): BackgroundResult {\n  const { background, backgroundURL, roomBackgroundURL } = settings;\n\n  // New simplified background resolution logic:\n  // 1. User-set app background (always wins if set)\n  // 2. Private room with \"Use Room Background\" + room has URL → use room URL\n  // 3. Private room with \"Use Room Background\" + no room URL → \"color\"\n  // 4. Public room → \"color\" (no \"Use Room Background\" option)\n  // 5. No app background set → \"color\"\n\n  let finalBackground: string | null = null;\n\n  // Priority 1: Check if user has set an app background preference\n  if (background) {\n    if (background === 'custom') {\n      // User wants custom app background\n      finalBackground = backgroundURL || null;\n    } else if (background === 'useRoomBackground') {\n      // User wants to use room background (only valid in private rooms)\n      if (!isPublicRoom(room) && roomBackgroundURL) {\n        // Private room with room background URL set\n        finalBackground = roomBackgroundURL;\n      } else {\n        // Public room or private room without room background URL\n        finalBackground = 'color';\n      }\n    } else {\n      // Built-in app background (color, gray, metronome.gif, etc.)\n      finalBackground = background;\n    }\n  } else {\n    // No app background preference set - default to color tiles\n    finalBackground = 'color';\n  }\n\n  if (!finalBackground) {\n    finalBackground = 'color';\n  }\n\n  // Handle built-in background types without processing\n  if (finalBackground === 'color' || finalBackground === 'gray') {\n    const result = { url: finalBackground, isVideo: false };\n    return result;\n  }\n\n  const result = processBackground(finalBackground);\n\n  return result;\n}\n","import { useEffect, useState, useMemo } from 'react';\nimport useHybridPlayerList, { type HybridPlayer } from './useHybridPlayerList';\nimport { Player } from '@/types/player';\n\ninterface Message {\n  uid: string;\n  [key: string]: any;\n}\n\nfunction convertHybridPlayerToPlayer(hybridPlayer: HybridPlayer): Player {\n  return {\n    uid: hybridPlayer.uid,\n    displayName: hybridPlayer.displayName,\n    isSelf: hybridPlayer.isSelf,\n    isFinished: hybridPlayer.isFinished,\n  };\n}\n\nexport default function useTurnIndicator(message?: Message): Player | null {\n  const [turnIndicator, setTurnIndicator] = useState<Player | null>(null);\n  const hybridPlayers = useHybridPlayerList();\n\n  // Create a stable representation of players to prevent infinite loops\n  const playersHash = useMemo(() => {\n    return hybridPlayers\n      .map((p) => `${p.uid}-${p.displayName}-${p.isFinished}-${p.isSelf}`)\n      .join('|');\n  }, [hybridPlayers]);\n\n  // Create a stable representation of the message to prevent infinite loops\n  const messageHash = useMemo(() => {\n    return message ? `${message.uid}-${message.displayName || ''}` : null;\n  }, [message]);\n\n  useEffect(() => {\n    if (!message) {\n      setTurnIndicator(null);\n      return;\n    }\n\n    // Single player or not enough players for turns\n    if (hybridPlayers.length <= 1) {\n      setTurnIndicator(null);\n      return;\n    }\n\n    // Filter out finished players\n    const stillPlaying = hybridPlayers.filter((player) => !player.isFinished);\n\n    if (stillPlaying.length <= 1) {\n      setTurnIndicator(null);\n      return;\n    }\n\n    // For local players, we need to find by displayName since message.uid might not match\n    // For remote players, we find by uid\n    let currentPlayerIndex = -1;\n\n    // First try to find by uid (works for remote players)\n    currentPlayerIndex = stillPlaying.findIndex((player) => player.uid === message.uid);\n\n    // If not found and we have local players, try finding by displayName\n    if (currentPlayerIndex === -1) {\n      currentPlayerIndex = stillPlaying.findIndex(\n        (player) => player.displayName === message.displayName\n      );\n    }\n\n    // If we still can't find the player, use the first player as fallback\n    if (currentPlayerIndex === -1) {\n      currentPlayerIndex = 0;\n    }\n\n    // Get the next player in turn order\n    const nextIndex = (currentPlayerIndex + 1) % stillPlaying.length;\n    const nextHybridPlayer = stillPlaying[nextIndex];\n\n    // Convert to Player format for the indicator\n    const nextPlayer = convertHybridPlayerToPlayer(nextHybridPlayer);\n    setTurnIndicator(nextPlayer);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [messageHash, playersHash]);\n\n  return turnIndicator;\n}\n"],"names":["cssUrl","url","cleanedUrl","char","codePoint","inferMediaType","u","DirectMediaHandler","mediaType","setMediaType","useState","currentUrl","setCurrentUrl","useEffect","handleVideoError","_a","_b","failingUrl","isImgur","parsed","e","imgurId","imageUrl","handleImageError","formats","currentFormat","nextIndex","nextFormat","nextUrl","jsx","jsxs","Fragment","ImageSlideshow","images","className","zoomDuration","zoomScale","t","useTranslation","currentIndex","setCurrentIndex","imageKey","setImageKey","preloadedImages","setPreloadedImages","imageLoadErrors","setImageLoadErrors","hasLoadedFirstImage","setHasLoadedFirstImage","intervalRef","useRef","preloadRef","preloadImage","src","resolve","img","prev","newSet","preloadCount","preloadPromises","i","index","startSlideshow","initialDelay","currentImage","isCurrentImagePreloaded","hasCurrentImageError","clsx","decodeHtmlEntities","str","PROXY_SERVICES","toProxyUrl","serviceIndex","service","withoutScheme","scheme","fetchRedditImages","subreddit","maxCount","signal","_c","_d","_e","_f","_g","_h","_i","_j","_k","collected","after","endpoints","a","fetchJson","resp","text","start","end","error","proxyResp","jsonData","endpointIndex","page","json","children","child","data","direct","postHint","items","it","meta","source","normalized","preview","fetchRedditFeed","config","maxImages","isRedditUrl","extractSubredditFromUrl","match","CACHE_TTL_MS","cache","inFlight","getCachedRedditFeed","cacheKey","now","cached","existing","promise","result","useRedditFeed","setImages","isLoading","setIsLoading","errorCode","setErrorCode","setSource","abortRef","timeoutRef","retryTimeoutRef","controller","loadRedditImages","retryCount","retryDelay","RedditSlideshow","theme","useTheme","alpha","RoomBackground","isVideo","isDirectVideo","isReddit","isNonImageBackground","hasCustomBackground","shouldShowRedditSlideshow","Box","vimeo","vimeoRegex","youtube","youtubeRegex","googleDrive","driveRegex","dropBox","dropBoxRegex","pornhub","xhamster","urlParts","tenor","directMediaRegex","directMatch","extension","viewRegex","viewMatch","giphy","giphyRegex","tumblr","gfycat","gfycatRegex","gifId","isValidHost","redtube","redtubeRegex","youporn","youpornRegex","tube8","tube8Regex","twitter","imgur","logger","galleryMatch","pathMatch","imgurRegex","extensionMatch","originalExtension","extensionMap","isDirectVideoUrl","isDiscordMediaUrl","allowedHosts","host","processBackground","embedUrl","tenorResult","getURLPath","getBackgroundSource","settings","room","background","backgroundURL","roomBackgroundURL","finalBackground","isPublicRoom","convertHybridPlayerToPlayer","hybridPlayer","useTurnIndicator","message","turnIndicator","setTurnIndicator","hybridPlayers","useHybridPlayerList","playersHash","useMemo","p","messageHash","stillPlaying","player","currentPlayerIndex","nextHybridPlayer","nextPlayer"],"mappings":"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"}