import{b as d}from"./chunk-DCqCmTw7.js";import{n as U,a as M}from"./chunk-rJHcTq4h.js";import{d as P,p as z}from"./chunk-5SGEHjMG.js";(function(){var n=typeof window!="undefined"?window:typeof global!="undefined"?global:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:{};n.SENTRY_RELEASE={id:"b82d01bea29447e452b49ba3e85b9fac2f7942a4"}})();try{(function(){var n=typeof window!="undefined"?window:typeof global!="undefined"?global:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:{},r=new n.Error().stack;r&&(n._sentryDebugIds=n._sentryDebugIds||{},n._sentryDebugIds[r]="7bc07e75-ad6b-4b45-b20e-4c6fba1cfc7c",n._sentryDebugIdIdentifier="sentry-dbid-7bc07e75-ad6b-4b45-b20e-4c6fba1cfc7c")})()}catch(n){}var V=Object.defineProperty,B=(n,r,e)=>r in n?V(n,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[r]=e,L=(n,r,e)=>B(n,typeof r!="symbol"?r+"":r,e);const A=class S{constructor(){L(this,"currentSession",null)}static getInstance(){return S.instance||(S.instance=new S),S.instance}async createSession(r,e,s){try{this.validateSessionInput(r,e,s);const o=U(),t=Date.now(),l=e.map(f=>{var v,h;return{...f,location:(v=f.location)!=null?v:0,isFinished:(h=f.isFinished)!=null?h:!1}}),a={id:o,roomId:r,players:l,currentPlayerIndex:0,isActive:!0,createdAt:t,updatedAt:t,settings:{...s}},i={sessionId:a.id,roomId:a.roomId,players:a.players,currentPlayerIndex:a.currentPlayerIndex,isActive:a.isActive,createdAt:a.createdAt,updatedAt:a.updatedAt,settings:a.settings};return await P.localPlayerSessions.add(i),this.currentSession=a,a}catch(o){throw new Error(`Failed to create local player session: ${o instanceof Error?o.message:"Unknown error"}`)}}async getSession(r){try{if(!r)throw new Error("Session ID is required");const e=await P.localPlayerSessions.where("sessionId").equals(r).first();return e?this.convertDbSessionToSession(e):null}catch(e){throw new Error(`Failed to get session: ${e instanceof Error?e.message:"Unknown error"}`)}}async updateSession(r,e){var s;try{if(!r)throw new Error("Session ID is required");const o=await this.getSession(r);if(!o)throw new Error("Session not found");const t={...o,...e,id:r,createdAt:o.createdAt,updatedAt:Date.now()},l={roomId:t.roomId,players:t.players,currentPlayerIndex:t.currentPlayerIndex,isActive:t.isActive,updatedAt:t.updatedAt,settings:t.settings};return await P.localPlayerSessions.where("sessionId").equals(r).modify(l),((s=this.currentSession)==null?void 0:s.id)===r&&(this.currentSession=t),t}catch(o){throw new Error(`Failed to update session: ${o instanceof Error?o.message:"Unknown error"}`)}}async advanceLocalTurn(r){try{if(!r)throw new Error("Session ID is required");const e=await this.getSession(r);if(!e)throw new Error("Session not found");if(!e.isActive)throw new Error("Cannot advance turn on inactive session");if(e.players.length===0)throw new Error("No players in session");const s=(e.currentPlayerIndex+1)%e.players.length,o=e.players.map((l,a)=>({...l,isActive:a===s}));return(await this.updateSession(r,{players:o,currentPlayerIndex:s})).players[s]}catch(e){throw new Error(`Failed to advance turn: ${e instanceof Error?e.message:"Unknown error"}`)}}getCurrentSession(){return this.currentSession}async updatePlayerPosition(r,e,s,o=!1){try{if(!r)throw new Error("Session ID is required");if(!e)throw new Error("Player ID is required");if(s<0)throw new Error("Location must be non-negative");const t=await this.getSession(r);if(!t)throw new Error("Session not found");if(!t.isActive)throw new Error("Cannot update player position on inactive session");const l=t.players.findIndex(i=>i.id===e);if(l===-1)throw new Error(`Player with ID ${e} not found in session`);const a=[...t.players];return a[l]={...a[l],location:s,isFinished:o},await this.updateSession(r,{players:a}),a[l]}catch(t){throw new Error(`Failed to update player position: ${t instanceof Error?t.message:"Unknown error"}`)}}clearCurrentSession(){this.currentSession=null}validateSessionInput(r,e,s){if(!r||typeof r!="string")throw new Error("Valid room ID is required");if(!Array.isArray(e)||e.length<2||e.length>4)throw new Error("Session must have between 2 and 4 players");e.forEach((i,f)=>{if(!i.id||typeof i.id!="string")throw new Error(`Player at index ${f} must have a valid ID`);if(!i.name||typeof i.name!="string")throw new Error(`Player at index ${f} must have a valid name`);if(!["sub","dom","vers"].includes(i.role))throw new Error(`Player at index ${f} must have a valid role`);if(typeof i.location!="undefined"&&(typeof i.location!="number"||i.location<0))throw new Error(`Player at index ${f} must have a valid location (non-negative number)`)});const o=e.map(i=>i.id),t=new Set(o);if(o.length!==t.size)throw new Error("All players must have unique IDs");const l=e.map(i=>i.name.toLowerCase()),a=new Set(l);if(l.length!==a.size)throw new Error("All players must have unique names");if(!s||typeof s!="object")throw new Error("Valid settings object is required")}convertDbSessionToSession(r){return{id:r.sessionId,roomId:r.roomId,players:r.players,currentPlayerIndex:r.currentPlayerIndex,isActive:r.isActive,createdAt:r.createdAt,updatedAt:r.updatedAt,settings:r.settings}}};L(A,"instance");let j=A;const g=j.getInstance(),O=M()(z((n,r)=>({session:null,error:null,isLoading:!1,hasLocalPlayers:()=>{const e=r().session;return(e==null?void 0:e.isActive)===!0&&e.players.length>0},isLocalPlayerRoom:()=>{const e=r().session;return(e==null?void 0:e.isActive)===!0},getCurrentPlayer:()=>{const e=r().session;if(!(e!=null&&e.isActive)||!e.players||e.players.length===0)return null;const s=e.currentPlayerIndex||0,o=e.players[s];if(!o)return null;const t={...o};return typeof t.location!="number"&&(t.location=0),typeof t.isFinished!="boolean"&&(t.isFinished=!1),t},setSession:e=>{const s=e?r()._migrateSession(e):null;n({session:s,error:null})},_migrateSession:e=>{if(!e||!e.players)return e;const s=e.players.map(o=>({...o,location:typeof o.location=="number"?o.location:0,isFinished:typeof o.isFinished=="boolean"?o.isFinished:!1,sound:o.sound||""}));return{...e,players:s}},clearSession:()=>{g.clearCurrentSession(),n({session:null,error:null})},setError:e=>{n({error:e,isLoading:!1})},setLoading:e=>{n({isLoading:e})},initSession:async(e,s,o)=>{try{n({isLoading:!0,error:null});const t=await g.createSession(e,s,o);n({session:t,isLoading:!1,error:null})}catch(t){const l=t instanceof Error?t.message:"Failed to create session";n({error:l,isLoading:!1,session:null})}},loadSession:async e=>{try{n({isLoading:!0,error:null});const s=await g.getSession(e);n({session:s,isLoading:!1,error:null})}catch(s){const o=s instanceof Error?s.message:"Failed to load session";n({error:o,isLoading:!1,session:null})}},nextLocalPlayer:async()=>{try{n({isLoading:!0,error:null});const e=r().session;if(!e)throw new Error("No active session");await g.advanceLocalTurn(e.id);const s=await g.getSession(e.id);n({session:s,isLoading:!1,error:null})}catch(e){const s=e instanceof Error?e.message:"Failed to advance turn";n({error:s,isLoading:!1})}},updateSessionSettings:async e=>{try{n({isLoading:!0,error:null});const s=r().session;if(!s)throw new Error("No active session");const o=await g.updateSession(s.id,{settings:e});n({session:o,isLoading:!1,error:null})}catch(s){const o=s instanceof Error?s.message:"Failed to update session settings";n({error:o,isLoading:!1})}}}),{name:"local-player-store",partialize:n=>({session:n.session}),onRehydrateStorage:()=>n=>{n&&(n.isLoading=!1,n.error=null)}}));function J(){var n;const{session:r,error:e,isLoading:s,hasLocalPlayers:o,isLocalPlayerRoom:t,getCurrentPlayer:l,setSession:a,clearSession:i,setError:f,setLoading:v,initSession:h,loadSession:b,nextLocalPlayer:E,updateSessionSettings:I}=O(),u=d.useMemo(()=>(r==null?void 0:r.players)||[],[r==null?void 0:r.players]),x=l(),y=(n=r==null?void 0:r.currentPlayerIndex)!=null?n:-1,C=r==null?void 0:r.settings,D=d.useCallback(async(c,w,R)=>{await h(c,w,R)},[h]),F=d.useCallback(async c=>{await b(c)},[b]),_=d.useCallback(async()=>{await E()},[E]),q=d.useCallback(()=>{i()},[i]),k=d.useCallback(async c=>{await I(c)},[I]),p=d.useCallback(c=>c>=0&&c<u.length?u[c]:null,[u]),m=d.useCallback(c=>u.find(w=>w.id===c)||null,[u]),T=d.useCallback(c=>{const w=m(c);return(w==null?void 0:w.isActive)===!0},[m]),$=d.useCallback(()=>{if(u.length===0)return null;const c=(y+1)%u.length;return p(c)},[u,y,p]),N=d.useCallback(()=>{if(u.length===0)return null;const c=y===0?u.length-1:y-1;return p(c)},[u,y,p]);return{session:r,localPlayers:u,currentPlayer:x,currentPlayerIndex:y,sessionSettings:C,error:e,isLoading:s,hasLocalPlayers:o(),isLocalPlayerRoom:t(),playerCount:u.length,isValidSession:(r==null?void 0:r.isActive)===!0&&u.length>=2,createLocalSession:D,loadLocalSession:F,clearLocalSession:q,advanceToNextPlayer:_,updateSettings:k,getPlayerByIndex:p,getPlayerById:m,isPlayerActive:T,getNextPlayer:$,getPreviousPlayer:N,setSession:a,setError:f,setLoading:v}}export{O as a,g as l,J as u};
//# sourceMappingURL=chunk-B47UJojq.js.map
