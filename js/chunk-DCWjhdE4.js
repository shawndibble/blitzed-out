var M=Object.defineProperty;var T=(t,r,e)=>r in t?M(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e;var m=(t,r,e)=>T(t,typeof r!="symbol"?r+"":r,e);import{r as d}from"./chunk-D6lSgkQl.js";import{n as R,a as V}from"./chunk-CygiBK7d.js";import{z as P,p as j}from"./chunk-CI62jVUQ.js";const h=class h{constructor(){m(this,"currentSession",null)}static getInstance(){return h.instance||(h.instance=new h),h.instance}async createSession(r,e,s){try{this.validateSessionInput(r,e,s);const n=R(),o=Date.now(),c=e.map(y=>({...y,location:y.location??0,isFinished:y.isFinished??!1})),a={id:n,roomId:r,players:c,currentPlayerIndex:0,isActive:!0,createdAt:o,updatedAt:o,settings:{...s}},i={sessionId:a.id,roomId:a.roomId,players:a.players,currentPlayerIndex:a.currentPlayerIndex,isActive:a.isActive,createdAt:a.createdAt,updatedAt:a.updatedAt,settings:a.settings};return await P.localPlayerSessions.add(i),this.currentSession=a,a}catch(n){throw new Error(`Failed to create local player session: ${n instanceof Error?n.message:"Unknown error"}`)}}async getSession(r){try{if(!r)throw new Error("Session ID is required");const e=await P.localPlayerSessions.where("sessionId").equals(r).first();return e?this.convertDbSessionToSession(e):null}catch(e){throw new Error(`Failed to get session: ${e instanceof Error?e.message:"Unknown error"}`)}}async updateSession(r,e){try{if(!r)throw new Error("Session ID is required");const s=await this.getSession(r);if(!s)throw new Error("Session not found");const n={...s,...e,id:r,createdAt:s.createdAt,updatedAt:Date.now()},o={roomId:n.roomId,players:n.players,currentPlayerIndex:n.currentPlayerIndex,isActive:n.isActive,updatedAt:n.updatedAt,settings:n.settings};return await P.localPlayerSessions.where("sessionId").equals(r).modify(o),this.currentSession?.id===r&&(this.currentSession=n),n}catch(s){throw new Error(`Failed to update session: ${s instanceof Error?s.message:"Unknown error"}`)}}async advanceLocalTurn(r){try{if(!r)throw new Error("Session ID is required");const e=await this.getSession(r);if(!e)throw new Error("Session not found");if(!e.isActive)throw new Error("Cannot advance turn on inactive session");if(e.players.length===0)throw new Error("No players in session");const s=(e.currentPlayerIndex+1)%e.players.length,n=e.players.map((c,a)=>({...c,isActive:a===s}));return(await this.updateSession(r,{players:n,currentPlayerIndex:s})).players[s]}catch(e){throw new Error(`Failed to advance turn: ${e instanceof Error?e.message:"Unknown error"}`)}}getCurrentSession(){return this.currentSession}async updatePlayerPosition(r,e,s,n=!1){try{if(!r)throw new Error("Session ID is required");if(!e)throw new Error("Player ID is required");if(s<0)throw new Error("Location must be non-negative");const o=await this.getSession(r);if(!o)throw new Error("Session not found");if(!o.isActive)throw new Error("Cannot update player position on inactive session");const c=o.players.findIndex(i=>i.id===e);if(c===-1)throw new Error(`Player with ID ${e} not found in session`);const a=[...o.players];return a[c]={...a[c],location:s,isFinished:n},await this.updateSession(r,{players:a}),a[c]}catch(o){throw new Error(`Failed to update player position: ${o instanceof Error?o.message:"Unknown error"}`)}}clearCurrentSession(){this.currentSession=null}validateSessionInput(r,e,s){if(!r||typeof r!="string")throw new Error("Valid room ID is required");if(!Array.isArray(e)||e.length<2||e.length>4)throw new Error("Session must have between 2 and 4 players");e.forEach((i,y)=>{if(!i.id||typeof i.id!="string")throw new Error(`Player at index ${y} must have a valid ID`);if(!i.name||typeof i.name!="string")throw new Error(`Player at index ${y} must have a valid name`);if(!["sub","dom","vers"].includes(i.role))throw new Error(`Player at index ${y} must have a valid role`);if(typeof i.location<"u"&&(typeof i.location!="number"||i.location<0))throw new Error(`Player at index ${y} must have a valid location (non-negative number)`)});const n=e.map(i=>i.id),o=new Set(n);if(n.length!==o.size)throw new Error("All players must have unique IDs");const c=e.map(i=>i.name.toLowerCase()),a=new Set(c);if(c.length!==a.size)throw new Error("All players must have unique names");if(!s||typeof s!="object")throw new Error("Valid settings object is required")}convertDbSessionToSession(r){return{id:r.sessionId,roomId:r.roomId,players:r.players,currentPlayerIndex:r.currentPlayerIndex,isActive:r.isActive,createdAt:r.createdAt,updatedAt:r.updatedAt,settings:r.settings}}};m(h,"instance");let v=h;const f=v.getInstance(),B=V()(j((t,r)=>({session:null,error:null,isLoading:!1,hasLocalPlayers:()=>{const e=r().session;return e?.isActive===!0&&e.players.length>0},isLocalPlayerRoom:()=>r().session?.isActive===!0,getCurrentPlayer:()=>{const e=r().session;if(!e?.isActive||!e.players||e.players.length===0)return null;const s=e.currentPlayerIndex||0,n=e.players[s];if(!n)return null;const o={...n};return typeof o.location!="number"&&(o.location=0),typeof o.isFinished!="boolean"&&(o.isFinished=!1),o},setSession:e=>{const s=e?r()._migrateSession(e):null;t({session:s,error:null})},_migrateSession:e=>{if(!e||!e.players)return e;const s=e.players.map(n=>({...n,location:typeof n.location=="number"?n.location:0,isFinished:typeof n.isFinished=="boolean"?n.isFinished:!1,sound:n.sound||""}));return{...e,players:s}},clearSession:()=>{f.clearCurrentSession(),t({session:null,error:null})},setError:e=>{t({error:e,isLoading:!1})},setLoading:e=>{t({isLoading:e})},initSession:async(e,s,n)=>{try{t({isLoading:!0,error:null});const o=await f.createSession(e,s,n);t({session:o,isLoading:!1,error:null})}catch(o){const c=o instanceof Error?o.message:"Failed to create session";t({error:c,isLoading:!1,session:null})}},loadSession:async e=>{try{t({isLoading:!0,error:null});const s=await f.getSession(e);t({session:s,isLoading:!1,error:null})}catch(s){const n=s instanceof Error?s.message:"Failed to load session";t({error:n,isLoading:!1,session:null})}},nextLocalPlayer:async()=>{try{t({isLoading:!0,error:null});const e=r().session;if(!e)throw new Error("No active session");await f.advanceLocalTurn(e.id);const s=await f.getSession(e.id);t({session:s,isLoading:!1,error:null})}catch(e){const s=e instanceof Error?e.message:"Failed to advance turn";t({error:s,isLoading:!1})}},updateSessionSettings:async e=>{try{t({isLoading:!0,error:null});const s=r().session;if(!s)throw new Error("No active session");const n=await f.updateSession(s.id,{settings:e});t({session:n,isLoading:!1,error:null})}catch(s){const n=s instanceof Error?s.message:"Failed to update session settings";t({error:n,isLoading:!1})}}}),{name:"local-player-store",partialize:t=>({session:t.session}),onRehydrateStorage:()=>t=>{t&&(t.isLoading=!1,t.error=null)}}));function O(){const{session:t,error:r,isLoading:e,hasLocalPlayers:s,isLocalPlayerRoom:n,getCurrentPlayer:o,setSession:c,clearSession:a,setError:i,setLoading:y,initSession:E,loadSession:A,nextLocalPlayer:I,updateSessionSettings:L}=B(),u=d.useMemo(()=>t?.players||[],[t?.players]),x=o(),w=t?.currentPlayerIndex??-1,b=t?.settings,C=d.useCallback(async(l,p,z)=>{await E(l,p,z)},[E]),F=d.useCallback(async l=>{await A(l)},[A]),k=d.useCallback(async()=>{await I()},[I]),q=d.useCallback(()=>{a()},[a]),D=d.useCallback(async l=>{await L(l)},[L]),g=d.useCallback(l=>l>=0&&l<u.length?u[l]:null,[u]),S=d.useCallback(l=>u.find(p=>p.id===l)||null,[u]),$=d.useCallback(l=>S(l)?.isActive===!0,[S]),N=d.useCallback(()=>{if(u.length===0)return null;const l=(w+1)%u.length;return g(l)},[u,w,g]),U=d.useCallback(()=>{if(u.length===0)return null;const l=w===0?u.length-1:w-1;return g(l)},[u,w,g]);return{session:t,localPlayers:u,currentPlayer:x,currentPlayerIndex:w,sessionSettings:b,error:r,isLoading:e,hasLocalPlayers:s(),isLocalPlayerRoom:n(),playerCount:u.length,isValidSession:t?.isActive===!0&&u.length>=2,createLocalSession:C,loadLocalSession:F,clearLocalSession:q,advanceToNextPlayer:k,updateSettings:D,getPlayerByIndex:g,getPlayerById:S,isPlayerActive:$,getNextPlayer:N,getPreviousPlayer:U,setSession:c,setError:i,setLoading:y}}export{B as a,f as l,O as u};
