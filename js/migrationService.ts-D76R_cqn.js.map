{"version":3,"mappings":"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","names":["SUPPORTED_LANGUAGES","MIGRATION_VERSION","MIGRATION_KEY","BACKGROUND_MIGRATION_KEY","MIGRATION_IN_PROGRESS_KEY","CURRENT_LANGUAGE_MIGRATION_KEY","BACKGROUND_MIGRATION_IN_PROGRESS_KEY","MIGRATION_TIMEOUT","STALE_LOCK_TIMEOUT","BACKGROUND_MIGRATION_DELAY","QUEUE_BACKGROUND_MIGRATION_DELAY","IDLE_CALLBACK_TIMEOUT","GAME_MODES","logError","level","context","error","details","errorMessage","logMessage","safeLocalStorage","key","value","item","withErrorHandling","operation","fallback","isDuplicateError","isMigrationInProgress","status","setMigrationInProgress","inProgress","isLanguageMigrationInProgress","locale","setLanguageMigrationInProgress","l","isBackgroundMigrationInProgress","setBackgroundMigrationInProgress","markMigrationComplete","markLanguageMigrated","bgStatus","completedSet","markBackgroundMigrationInProgress","isMigrationCompleted","isCurrentLanguageMigrationCompleted","lang","getMigrationStatus","resetMigrationStatus","checkAndHandleVersionChange","oldVersion","clearAllMigrationData","getCurrentLanguage","resolved","i18n","currentLang","storedLanguage","browserLang","getAvailableLocales","locales","existingLocales","__variableDynamicImportRuntimeHelper","__vitePreload","e","getAvailableGameModes","gameModes","existingGameModes","gameMode","getActionGroupNames","allActionFiles","existingGroups","targetPath","filePath","variant","fileName","groupName","importActionFile","actionFile","label","type","actions","intensities","intensityName","index","customGroup","customTiles","actionList","intensity","i","action","addCustomGroupSafely","addCustomGroup","getNewTiles","existingTiles","getTiles","tile","existing","importCustomTilesSafely","tiles","importCustomTiles","importGroupsForLocaleAndGameMode","groupNames","groupsImported","tilesImported","db","n","module","getCustomGroupByName","result","newTiles","tilesAdded","cleanupDuplicateGroups","totalDuplicatesRemoved","duplicatesRemoved","removeDuplicateGroups","verifyMigrationIntegrity","localStorageComplete","getAllAvailableGroups","groups","fixMigrationStatusCorruption","migrateActionGroups","cleanupDuplicatesIfNeeded","_a","_b","_c","migrateCurrentLanguage","currentLocale","waitForMigrationCompletion","migrateRemainingLanguages","excludeLocale","remainingLocales","resolve","constants","completedLanguages","queueBackgroundMigration","ensureLanguageMigrated","runMigrationIfNeeded","versionChanged","success","forceFreshMigration","checkInProgress","operationName","startTime"],"ignoreList":[],"sources":["../../src/services/migration/constants.ts","../../src/services/migration/errorHandling.ts","../../src/services/migration/statusManager.ts","../../src/services/migration/versionManager.ts","../../src/services/migration/fileDiscovery.ts","../../src/services/migration/importOperations.ts","../../src/services/migration/validationUtils.ts","../../src/services/migration/index.ts"],"sourcesContent":["/**\n * Constants and configuration for the migration service\n */\n\n// Supported languages for migration\nexport const SUPPORTED_LANGUAGES = ['en', 'es', 'fr', 'zh', 'hi'] as const;\n\n// ============================================================================\n// MIGRATION VERSION CONFIGURATION\n// ============================================================================\n//\n// VERSION HISTORY:\n// - 2.1.0: Initial migration system\n// - 2.1.1: Fixed import path matching (@/locales vs /src/locales)\n// - 2.1.2: Added corruption detection and auto-recovery\n// --2.2.0: Added body worship group\n//\nexport const MIGRATION_VERSION = '2.2.0';\n// ============================================================================\n\n// Configuration keys for localStorage\nexport const MIGRATION_KEY = 'blitzed-out-action-groups-migration';\nexport const BACKGROUND_MIGRATION_KEY = 'blitzed-out-background-migration';\n\n// localStorage-based concurrency control keys for better reliability in hot module reloading environments\nexport const MIGRATION_IN_PROGRESS_KEY = 'blitzed-out-migration-in-progress';\nexport const CURRENT_LANGUAGE_MIGRATION_KEY = 'blitzed-out-current-language-migration';\nexport const BACKGROUND_MIGRATION_IN_PROGRESS_KEY = 'blitzed-out-background-migration-in-progress';\n\n// Timeout configurations (in milliseconds)\nexport const MIGRATION_TIMEOUT = 30 * 1000; // 30 seconds\nexport const BACKGROUND_MIGRATION_TIMEOUT = 10 * 60 * 1000; // 10 minutes\nexport const STALE_LOCK_TIMEOUT = 5 * 60 * 1000; // 5 minutes\n\n// Delay configurations\nexport const BACKGROUND_MIGRATION_DELAY = 10; // 10ms between operations\nexport const QUEUE_BACKGROUND_MIGRATION_DELAY = 1000; // 1 second\nexport const IDLE_CALLBACK_TIMEOUT = 5000; // 5 seconds\n\n// Game modes\nexport const GAME_MODES = ['local', 'online'] as const;\n\nexport type SupportedLanguage = typeof SUPPORTED_LANGUAGES[number];\nexport type GameMode = typeof GAME_MODES[number];","/**\n * Centralized error handling utilities for the migration service\n */\n\nexport type ErrorLevel = 'debug' | 'warn' | 'error';\n\n/**\n * Standardized error logging with consistent format\n */\nexport const logError = (level: ErrorLevel, context: string, error: unknown, details?: any): void => {\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  const logMessage = `[Migration ${context}] ${errorMessage}`;\n  \n  if (details) {\n    console[level](logMessage, details);\n  } else {\n    console[level](logMessage);\n  }\n};\n\n/**\n * Safe localStorage operation wrapper\n */\nexport const safeLocalStorage = {\n  getItem: (key: string): string | null => {\n    try {\n      return localStorage.getItem(key);\n    } catch (error) {\n      logError('warn', 'localStorage.getItem', error, { key });\n      return null;\n    }\n  },\n\n  setItem: (key: string, value: string): boolean => {\n    try {\n      localStorage.setItem(key, value);\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.setItem', error, { key });\n      return false;\n    }\n  },\n\n  removeItem: (key: string): boolean => {\n    try {\n      localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.removeItem', error, { key });\n      return false;\n    }\n  },\n\n  getJSON: <T>(key: string): T | null => {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      logError('warn', 'localStorage.getJSON', error, { key });\n      return null;\n    }\n  },\n\n  setJSON: (key: string, value: any): boolean => {\n    try {\n      localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.setJSON', error, { key });\n      return false;\n    }\n  },\n};\n\n/**\n * Async operation wrapper with consistent error handling\n */\nexport const withErrorHandling = async <T>(\n  operation: () => Promise<T>,\n  context: string,\n  fallback?: T\n): Promise<T | null> => {\n  try {\n    return await operation();\n  } catch (error) {\n    logError('error', context, error);\n    return fallback ?? null;\n  }\n};\n\n/**\n * Retry wrapper for potentially failing operations\n */\nexport const withRetry = async <T>(\n  operation: () => Promise<T>,\n  maxRetries: number = 3,\n  delay: number = 100\n): Promise<T> => {\n  let lastError: any;\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      if (attempt === maxRetries) {\n        throw error;\n      }\n      await new Promise(resolve => setTimeout(resolve, delay * attempt));\n    }\n  }\n  \n  throw lastError;\n};\n\n/**\n * Check if an error indicates a duplicate/conflict that can be safely ignored\n */\nexport const isDuplicateError = (error: unknown): boolean => {\n  if (error instanceof Error) {\n    return error.message.includes('already exists') || \n           error.message.includes('duplicate') ||\n           error.message.includes('unique constraint');\n  }\n  return false;\n};\n\n/**\n * Safe timeout wrapper for promises\n */\nexport const withTimeout = <T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  errorMessage: string = 'Operation timed out'\n): Promise<T> => {\n  return Promise.race([\n    promise,\n    new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error(errorMessage)), timeoutMs)\n    )\n  ]);\n};","/**\n * Status management module for localStorage-based migration tracking\n */\n\nimport {\n  MIGRATION_KEY,\n  BACKGROUND_MIGRATION_KEY,\n  MIGRATION_IN_PROGRESS_KEY,\n  CURRENT_LANGUAGE_MIGRATION_KEY,\n  BACKGROUND_MIGRATION_IN_PROGRESS_KEY,\n  MIGRATION_VERSION,\n  STALE_LOCK_TIMEOUT,\n  SUPPORTED_LANGUAGES,\n} from './constants';\nimport {\n  MigrationStatus,\n  BackgroundMigrationStatus,\n  MigrationLockStatus,\n  LanguageMigrationStatus,\n  MigrationStatusSnapshot,\n} from './types';\nimport { safeLocalStorage, logError } from './errorHandling';\n\n/**\n * Check if main migration is in progress\n */\nexport const isMigrationInProgress = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationLockStatus>(MIGRATION_IN_PROGRESS_KEY);\n  if (!status) return false;\n\n  // Auto-cleanup stale locks\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT) {\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n    return false;\n  }\n\n  return status.inProgress;\n};\n\n/**\n * Set main migration progress status\n */\nexport const setMigrationInProgress = (inProgress: boolean): void => {\n  if (inProgress) {\n    const status: MigrationLockStatus = {\n      inProgress: true,\n      startedAt: new Date().toISOString(),\n    };\n    safeLocalStorage.setJSON(MIGRATION_IN_PROGRESS_KEY, status);\n  } else {\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n  }\n};\n\n/**\n * Check if language migration is in progress\n */\nexport const isLanguageMigrationInProgress = (locale: string): boolean => {\n  const status = safeLocalStorage.getJSON<LanguageMigrationStatus>(CURRENT_LANGUAGE_MIGRATION_KEY);\n  if (!status) return false;\n\n  // Auto-cleanup stale locks\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT) {\n    safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    return false;\n  }\n\n  return status.locales && status.locales.includes(locale);\n};\n\n/**\n * Set language migration progress status\n */\nexport const setLanguageMigrationInProgress = (locale: string, inProgress: boolean): void => {\n  const status = safeLocalStorage.getJSON<LanguageMigrationStatus>(CURRENT_LANGUAGE_MIGRATION_KEY) || {\n    locales: [],\n    startedAt: new Date().toISOString(),\n  };\n\n  if (inProgress) {\n    if (!status.locales.includes(locale)) {\n      status.locales.push(locale);\n      status.startedAt = new Date().toISOString();\n    }\n  } else {\n    status.locales = status.locales.filter(l => l !== locale);\n    if (status.locales.length === 0) {\n      safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n      return;\n    }\n  }\n\n  safeLocalStorage.setJSON(CURRENT_LANGUAGE_MIGRATION_KEY, status);\n};\n\n/**\n * Check if background migration is in progress\n */\nexport const isBackgroundMigrationInProgress = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationLockStatus>(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n  if (!status) return false;\n\n  // Auto-cleanup stale locks (longer timeout for background operations)\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT * 2) {\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n    return false;\n  }\n\n  return status.inProgress;\n};\n\n/**\n * Set background migration progress status\n */\nexport const setBackgroundMigrationInProgress = (inProgress: boolean): void => {\n  if (inProgress) {\n    const status: MigrationLockStatus = {\n      inProgress: true,\n      startedAt: new Date().toISOString(),\n    };\n    safeLocalStorage.setJSON(BACKGROUND_MIGRATION_IN_PROGRESS_KEY, status);\n  } else {\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n  }\n};\n\n/**\n * Mark migration as completed\n */\nexport const markMigrationComplete = (): void => {\n  const status: MigrationStatus = {\n    version: MIGRATION_VERSION,\n    completed: true,\n    completedAt: new Date(),\n  };\n  safeLocalStorage.setJSON(MIGRATION_KEY, status);\n};\n\n/**\n * Mark a specific language as migrated in background status\n */\nexport const markLanguageMigrated = (locale: string): void => {\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(BACKGROUND_MIGRATION_KEY) || {\n    version: MIGRATION_VERSION,\n    completedLanguages: [],\n    inProgress: false,\n  };\n\n  // Use Set to ensure uniqueness and atomic update\n  const completedSet = new Set(bgStatus.completedLanguages);\n  completedSet.add(locale);\n  bgStatus.completedLanguages = Array.from(completedSet);\n\n  safeLocalStorage.setJSON(BACKGROUND_MIGRATION_KEY, bgStatus);\n};\n\n/**\n * Mark background migration as in progress\n */\nexport const markBackgroundMigrationInProgress = (inProgress: boolean): void => {\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(BACKGROUND_MIGRATION_KEY) || {\n    version: MIGRATION_VERSION,\n    completedLanguages: [],\n    inProgress: false,\n  };\n\n  bgStatus.inProgress = inProgress;\n  if (inProgress) {\n    bgStatus.startedAt = new Date();\n  } else {\n    bgStatus.completedAt = new Date();\n  }\n\n  safeLocalStorage.setJSON(BACKGROUND_MIGRATION_KEY, bgStatus);\n};\n\n/**\n * Check if migration has been completed\n */\nexport const isMigrationCompleted = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n  if (!status) return false;\n\n  return status.completed && status.version === MIGRATION_VERSION;\n};\n\n/**\n * Check if current language migration has been completed\n */\nexport const isCurrentLanguageMigrationCompleted = (locale: string): boolean => {\n  // Check background migration status for specific language\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(BACKGROUND_MIGRATION_KEY);\n  \n  if (bgStatus && bgStatus.completedLanguages.includes(locale)) {\n    return true;\n  }\n\n  // Fallback: check if full migration is complete AND all languages are done\n  const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n  if (status && status.completed && status.version === MIGRATION_VERSION) {\n    // Only return true if this is a full migration (not just current language)\n    if (bgStatus) {\n      return SUPPORTED_LANGUAGES.every(lang => bgStatus.completedLanguages.includes(lang));\n    }\n    // If no background status, assume full migration means all languages are done\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Get migration status for debugging\n */\nexport const getMigrationStatus = (): MigrationStatusSnapshot => {\n  return {\n    main: safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY),\n    background: safeLocalStorage.getJSON<BackgroundMigrationStatus>(BACKGROUND_MIGRATION_KEY),\n  };\n};\n\n/**\n * Reset migration status (for debugging/development)\n */\nexport const resetMigrationStatus = (): void => {\n  try {\n    safeLocalStorage.removeItem(MIGRATION_KEY);\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n    safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n  } catch (error) {\n    logError('error', 'resetMigrationStatus', error);\n  }\n};","/**\n * Version management module for handling version checks and updates\n */\n\nimport {\n  MIGRATION_KEY,\n  BACKGROUND_MIGRATION_KEY,\n  MIGRATION_IN_PROGRESS_KEY,\n  CURRENT_LANGUAGE_MIGRATION_KEY,\n  BACKGROUND_MIGRATION_IN_PROGRESS_KEY,\n  MIGRATION_VERSION,\n} from './constants';\nimport { MigrationStatus, VersionCheckResult } from './types';\nimport { safeLocalStorage, logError } from './errorHandling';\n\n/**\n * Check if migration version has changed and clear outdated data\n */\nexport const checkAndHandleVersionChange = (): VersionCheckResult => {\n  try {\n    const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n    if (!status) {\n      return { versionChanged: false };\n    }\n\n    const oldVersion = status.version;\n    const versionChanged = oldVersion !== MIGRATION_VERSION;\n\n    if (versionChanged) {\n      // Clear all migration-related localStorage\n      clearAllMigrationData();\n      return { versionChanged: true, oldVersion };\n    }\n\n    return { versionChanged: false, oldVersion };\n  } catch (error) {\n    logError('error', 'checkAndHandleVersionChange', error);\n    return { versionChanged: false };\n  }\n};\n\n/**\n * Clear all migration-related data from localStorage\n */\nexport const clearAllMigrationData = (): void => {\n  safeLocalStorage.removeItem(MIGRATION_KEY);\n  safeLocalStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n  safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n  safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n  safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n};\n\n/**\n * Get current migration version\n */\nexport const getCurrentMigrationVersion = (): string => {\n  return MIGRATION_VERSION;\n};\n\n/**\n * Check if a version change requires data migration\n */\nexport const requiresDataMigration = (oldVersion?: string): boolean => {\n  if (!oldVersion) return true;\n  \n  // Add logic here for version-specific migration requirements\n  // For now, any version change requires migration\n  return oldVersion !== MIGRATION_VERSION;\n};","/**\n * File discovery utilities for dynamic locale and game mode detection\n */\n\nimport { SUPPORTED_LANGUAGES, GAME_MODES } from './constants';\nimport { logError } from './errorHandling';\nimport i18n from '@/i18n';\n\n/**\n * Get current user language from i18next with fallbacks\n */\nexport const getCurrentLanguage = async (): Promise<string> => {\n  try {\n    // First try: get current language from i18next using proper API\n    const resolved = i18n.resolvedLanguage;\n    if (resolved && resolved !== 'undefined') {\n      return resolved;\n    }\n\n    // Second try: get language from i18next instance\n    const currentLang = i18n.language;\n    if (currentLang && currentLang !== 'undefined') {\n      return currentLang;\n    }\n\n    // Third try: localStorage fallback\n    const storedLanguage = localStorage.getItem('i18nextLng');\n    if (storedLanguage && storedLanguage !== 'undefined') {\n      return storedLanguage;\n    }\n\n    // Fourth try: browser language with proper validation\n    if (typeof navigator !== 'undefined' && navigator.language) {\n      const browserLang = navigator.language.split('-')[0];\n      if (SUPPORTED_LANGUAGES.includes(browserLang as typeof SUPPORTED_LANGUAGES[number])) {\n        return browserLang;\n      }\n    }\n\n    // Final fallback: English\n    return 'en';\n  } catch (error) {\n    logError('error', 'getCurrentLanguage', error);\n    return 'en'; // Safe fallback\n  }\n};\n\n/**\n * Dynamically discover available locales from the filesystem\n */\nexport const getAvailableLocales = async (): Promise<string[]> => {\n  const locales = [...SUPPORTED_LANGUAGES];\n  const existingLocales: string[] = [];\n\n  for (const locale of locales) {\n    try {\n      // Test if locale exists by trying to import translation file\n      await import(`@/locales/${locale}/translation.json`);\n      existingLocales.push(locale);\n    } catch {\n      // Locale doesn't exist, skip it\n    }\n  }\n\n  return existingLocales;\n};\n\n/**\n * Dynamically discover available game modes for a locale\n */\nexport const getAvailableGameModes = async (locale: string): Promise<string[]> => {\n  const gameModes = [...GAME_MODES];\n  const existingGameModes: string[] = [];\n\n  for (const gameMode of gameModes) {\n    try {\n      // Test if gameMode exists by trying to import any known file\n      await import(`@/locales/${locale}/${gameMode}/alcohol.json`);\n      existingGameModes.push(gameMode);\n    } catch {\n      // Game mode doesn't exist for this locale, skip it\n    }\n  }\n\n  return existingGameModes;\n};\n\n/**\n * Dynamically discover action group names for a specific locale and game mode\n * Uses Vite's import.meta.glob to automatically discover all JSON files at build time\n */\nexport const getActionGroupNames = async (locale: string, gameMode: string): Promise<string[]> => {\n  // Use Vite's glob import to get all action group files for all locales and game modes\n  // This automatically discovers files at build time, eliminating the need for hardcoded lists\n  const allActionFiles = import.meta.glob('@/locales/*/*/*.json');\n\n  const existingGroups: string[] = [];\n  const targetPath = `@/locales/${locale}/${gameMode}/`;\n\n  // Filter for files matching the current locale and game mode\n  for (const filePath of Object.keys(allActionFiles)) {\n    // Check both @/ prefixed paths and resolved paths\n    const pathVariants = [\n      targetPath, // @/locales/en/online/\n      targetPath.replace('@/', '/src/'), // /src/locales/en/online/\n      `/${locale}/${gameMode}/`, // /en/online/\n      `locales/${locale}/${gameMode}/`, // locales/en/online/\n    ];\n\n    const pathMatches = pathVariants.some(variant => filePath.includes(variant));\n    if (pathMatches) {\n      // Extract the group name from the file path\n      const fileName = filePath.split('/').pop();\n      if (fileName?.endsWith('.json')) {\n        const groupName = fileName.replace('.json', '');\n\n        try {\n          // Verify the file can be imported (additional safety check)\n          await allActionFiles[filePath]();\n          existingGroups.push(groupName);\n        } catch (error) {\n          // File exists but can't be imported, skip it\n          logError('warn', `getActionGroupNames: ${groupName} for ${locale}/${gameMode}`, error);\n        }\n      }\n    }\n  }\n\n  return existingGroups.sort(); // Sort for consistent ordering\n};","/**\n * Import operations module for handling action file imports and data conversion\n */\n\nimport { addCustomGroup, getCustomGroupByName, removeDuplicateGroups } from '@/stores/customGroups';\nimport { importCustomTiles, getTiles } from '@/stores/customTiles';\nimport { CustomGroupBase } from '@/types/customGroups';\nimport { CustomTileBase } from '@/types/customTiles';\nimport { ImportResult } from './types';\nimport { logError, withErrorHandling, isDuplicateError } from './errorHandling';\nimport { getActionGroupNames } from './fileDiscovery';\n\n/**\n * Import a single action file and convert it to a custom group with custom tiles\n */\nexport const importActionFile = async (\n  groupName: string,\n  locale: string,\n  gameMode: string\n): Promise<{ customGroup: CustomGroupBase; customTiles: CustomTileBase[] } | null> => {\n  return withErrorHandling(async () => {\n    // Import the action file\n    const actionFile = await import(`@/locales/${locale}/${gameMode}/${groupName}.json`);\n\n    // Extract data from the JSON file\n    const label = actionFile.label || groupName;\n    const type = actionFile.type || 'action';\n    const actions = actionFile.actions || {};\n\n    // Convert actions object to intensities array\n    const intensities = Object.keys(actions)\n      .filter(key => key !== 'None') // Skip 'None' as it's always included\n      .map((intensityName, index) => ({\n        id: `${groupName}-${index + 1}`,\n        label: intensityName,\n        value: index + 1,\n        isDefault: true,\n      }));\n\n    // Create the custom group\n    const customGroup: CustomGroupBase = {\n      name: groupName,\n      label,\n      intensities,\n      type,\n      isDefault: true,\n      locale,\n      gameMode,\n    };\n\n    // Create custom tiles from the actions\n    const customTiles: CustomTileBase[] = [];\n\n    for (const [intensityName, actionList] of Object.entries(actions)) {\n      if (intensityName === 'None' || !Array.isArray(actionList)) continue;\n\n      // Find the intensity value for this intensity name\n      const intensity = intensities.find(i => i.label === intensityName);\n      if (!intensity) continue;\n\n      // Create a tile for each action in this intensity\n      for (const action of actionList) {\n        if (typeof action === 'string' && action.trim()) {\n          customTiles.push({\n            group: groupName,\n            intensity: intensity.value,\n            action: action.trim(),\n            tags: ['default'], // Mark as default tiles from JSON files\n            isEnabled: 1,\n            isCustom: 0, // These are default tiles, not custom\n            gameMode,\n            locale,\n          });\n        }\n      }\n    }\n\n    return { customGroup, customTiles };\n  }, `importActionFile:${groupName}:${locale}/${gameMode}`);\n};\n\n/**\n * Add a custom group with error handling for duplicates\n */\nconst addCustomGroupSafely = async (customGroup: CustomGroupBase): Promise<boolean> => {\n  try {\n    await addCustomGroup(customGroup);\n    return true;\n  } catch (error) {\n    if (isDuplicateError(error)) {\n      // Group was already added by concurrent process, this is ok\n      return false;\n    }\n    throw error; // Re-throw other errors\n  }\n};\n\n/**\n * Filter out existing tiles to prevent duplicates\n */\nconst getNewTiles = async (\n  customTiles: CustomTileBase[],\n  locale: string,\n  gameMode: string,\n  groupName: string\n): Promise<CustomTileBase[]> => {\n  try {\n    const existingTiles = await getTiles({ locale, gameMode, group: groupName });\n    \n    if (!existingTiles || !Array.isArray(existingTiles)) {\n      return customTiles; // If no existing tiles, all tiles are new\n    }\n\n    return customTiles.filter(tile => {\n      return !existingTiles.some(existing =>\n        existing.group === tile.group &&\n        existing.intensity === tile.intensity &&\n        existing.action === tile.action &&\n        existing.gameMode === tile.gameMode &&\n        existing.locale === tile.locale\n      );\n    });\n  } catch (error) {\n    logError('warn', `getNewTiles:${groupName}:${locale}/${gameMode}`, error);\n    return customTiles; // On error, import all tiles\n  }\n};\n\n/**\n * Import custom tiles with duplicate handling\n */\nconst importCustomTilesSafely = async (tiles: CustomTileBase[]): Promise<number> => {\n  if (tiles.length === 0) return 0;\n\n  try {\n    await importCustomTiles(tiles);\n    return tiles.length;\n  } catch (error) {\n    logError('warn', 'importCustomTilesSafely', error);\n    // Continue processing, don't fail the entire migration\n    return 0;\n  }\n};\n\n/**\n * Import all action groups for a specific locale and game mode\n * Uses Dexie transactions to prevent cursor invalidation during concurrent operations\n */\nexport const importGroupsForLocaleAndGameMode = async (\n  locale: string,\n  gameMode: string\n): Promise<ImportResult> => {\n  const groupNames = await getActionGroupNames(locale, gameMode);\n  let groupsImported = 0;\n  let tilesImported = 0;\n\n  // Import Dexie database for transaction usage\n  const db = await import('@/stores/store').then(module => module.default);\n\n  // Use transaction to prevent cursor invalidation\n  return await db.transaction('rw', [db.customGroups, db.customTiles], async () => {\n    for (const groupName of groupNames) {\n      // Check if group already exists to prevent duplicates\n      const existingGroup = await getCustomGroupByName(groupName, locale, gameMode);\n      if (existingGroup) {\n        continue; // Group already exists, skip\n      }\n\n      const result = await importActionFile(groupName, locale, gameMode);\n      if (!result) continue;\n\n      const { customGroup, customTiles } = result;\n\n      try {\n        // Add the custom group with error handling for duplicates\n        const groupAdded = await addCustomGroupSafely(customGroup);\n        if (groupAdded) {\n          groupsImported++;\n        }\n\n        // Add the custom tiles if there are any\n        if (customTiles.length > 0) {\n          const newTiles = await getNewTiles(customTiles, locale, gameMode, groupName);\n          const tilesAdded = await importCustomTilesSafely(newTiles);\n          tilesImported += tilesAdded;\n        }\n      } catch (error) {\n        logError('error', `importGroupsForLocaleAndGameMode:${groupName}:${locale}/${gameMode}`, error);\n      }\n    }\n\n    return { groupsImported, tilesImported };\n  });\n};\n\n/**\n * Clean up duplicate groups across all locales and game modes\n */\nexport const cleanupDuplicateGroups = async (\n  getAvailableLocales: () => Promise<string[]>,\n  getAvailableGameModes: (locale: string) => Promise<string[]>\n): Promise<number> => {\n  const result = await withErrorHandling(async () => {\n    const locales = await getAvailableLocales();\n    let totalDuplicatesRemoved = 0;\n\n    for (const locale of locales) {\n      const gameModes = await getAvailableGameModes(locale);\n      for (const gameMode of gameModes) {\n        const duplicatesRemoved = await removeDuplicateGroups(locale, gameMode);\n        totalDuplicatesRemoved += duplicatesRemoved;\n      }\n    }\n\n    return totalDuplicatesRemoved;\n  }, 'cleanupDuplicateGroups', 0);\n  \n  return result !== null ? result : 0;\n};","/**\n * Validation utilities for integrity checks and corruption detection\n */\n\nimport { isCurrentLanguageMigrationCompleted, resetMigrationStatus } from './statusManager';\nimport { withErrorHandling, logError } from './errorHandling';\n\n/**\n * Verify that migration status matches actual database content\n * This detects corrupted migration status where localStorage says complete but Dexie is empty\n */\nexport const verifyMigrationIntegrity = async (\n  locale: string,\n  gameMode: string = 'online'\n): Promise<boolean> => {\n  const result = await withErrorHandling(async () => {\n    // Check if localStorage claims migration is complete\n    const localStorageComplete = isCurrentLanguageMigrationCompleted(locale);\n\n    if (!localStorageComplete) {\n      // If localStorage says not complete, that's fine - migration will run\n      return true;\n    }\n\n    // If localStorage says complete, verify database actually has data\n    const { getAllAvailableGroups } = await import('@/stores/customGroups');\n    const groups = await getAllAvailableGroups(locale, gameMode);\n\n    // If localStorage says complete but database is empty, we have corruption\n    if (localStorageComplete && groups.length === 0) {\n      return false;\n    }\n\n    return true;\n  }, `verifyMigrationIntegrity:${locale}:${gameMode}`, false);\n  \n  return result !== null ? result : false;\n};\n\n/**\n * Fix corrupted migration status by clearing localStorage\n */\nexport const fixMigrationStatusCorruption = (): void => {\n  try {\n    resetMigrationStatus();\n  } catch (error) {\n    logError('error', 'fixMigrationStatusCorruption', error);\n  }\n};\n\n/**\n * Validate that required dependencies are available\n */\nexport const validateDependencies = async (): Promise<{ isValid: boolean; missing: string[] }> => {\n  const missing: string[] = [];\n  \n  try {\n    // Check if we can import required stores\n    await import('@/stores/customGroups');\n  } catch {\n    missing.push('customGroups store');\n  }\n  \n  try {\n    await import('@/stores/customTiles');\n  } catch {\n    missing.push('customTiles store');\n  }\n  \n  try {\n    await import('@/stores/store');\n  } catch {\n    missing.push('main store');\n  }\n  \n  return { isValid: missing.length === 0, missing };\n};\n\n/**\n * Validate that a locale and game mode combination is supported\n */\nexport const validateLocaleGameMode = async (\n  locale: string,\n  _gameMode: string\n): Promise<boolean> => {\n  try {\n    // Try to import a known file for this combination\n    await import(`@/locales/${locale}/translation.json`);\n    // Basic validation passed, assume game mode is valid\n    return true;\n  } catch {\n    return false;\n  }\n};","/**\n * Main migration service that orchestrates all migration modules\n * \n * This is the refactored migration service broken down into focused modules:\n * - types: Type definitions and interfaces\n * - constants: Configuration and constant values\n * - errorHandling: Centralized error handling patterns\n * - statusManager: localStorage-based migration tracking\n * - versionManager: Version checking and updates\n * - fileDiscovery: Dynamic file and locale discovery\n * - importOperations: File importing and data conversion\n * - validationUtils: Integrity checks and validation\n */\n\nimport {\n  MIGRATION_TIMEOUT,\n  BACKGROUND_MIGRATION_DELAY,\n  QUEUE_BACKGROUND_MIGRATION_DELAY,\n  IDLE_CALLBACK_TIMEOUT,\n  SUPPORTED_LANGUAGES,\n} from './constants';\nimport {\n  isMigrationInProgress,\n  setMigrationInProgress,\n  isLanguageMigrationInProgress,\n  setLanguageMigrationInProgress,\n  isBackgroundMigrationInProgress,\n  setBackgroundMigrationInProgress,\n  markMigrationComplete,\n  markLanguageMigrated,\n  markBackgroundMigrationInProgress,\n  isMigrationCompleted,\n  isCurrentLanguageMigrationCompleted,\n  getMigrationStatus,\n  resetMigrationStatus,\n} from './statusManager';\nimport { checkAndHandleVersionChange } from './versionManager';\nimport { getCurrentLanguage, getAvailableLocales, getAvailableGameModes } from './fileDiscovery';\nimport { importGroupsForLocaleAndGameMode, cleanupDuplicateGroups } from './importOperations';\nimport { withErrorHandling, logError, safeLocalStorage } from './errorHandling';\n\n// Re-export types for external consumption\nexport type {\n  MigrationStatus,\n  BackgroundMigrationStatus,\n  ImportResult,\n  VersionCheckResult,\n  MigrationStatusSnapshot,\n} from './types';\n\n// Re-export key functions that are used by external components\nexport {\n  isMigrationCompleted,\n  isCurrentLanguageMigrationCompleted,\n  getMigrationStatus,\n  resetMigrationStatus,\n} from './statusManager';\n\nexport { checkAndHandleVersionChange } from './versionManager';\nexport { verifyMigrationIntegrity, fixMigrationStatusCorruption } from './validationUtils';\n\n/**\n * Main migration function with dynamic discovery\n */\nexport const migrateActionGroups = async (): Promise<boolean> => {\n  const result = await withErrorHandling(async () => {\n    // Dynamically discover available locales\n    const locales = await getAvailableLocales();\n\n    for (const locale of locales) {\n      // Dynamically discover available game modes for this locale\n      const gameModes = await getAvailableGameModes(locale);\n\n      for (const gameMode of gameModes) {\n        try {\n          await importGroupsForLocaleAndGameMode(locale, gameMode);\n        } catch (error) {\n          logError('error', `migrateActionGroups:${locale}/${gameMode}`, error);\n        }\n      }\n    }\n\n    // Clean up any duplicates that might exist from previous migrations\n    await cleanupDuplicateGroups(getAvailableLocales, getAvailableGameModes);\n\n    markMigrationComplete();\n    return true;\n  }, 'migrateActionGroups', false);\n  \n  return result !== null ? result : false;\n};\n\n/**\n * Clean up duplicate groups across all locales and game modes\n * Can be called independently of migration\n */\nexport const cleanupDuplicatesIfNeeded = async (): Promise<number> => {\n  const result = await withErrorHandling(async () => {\n    const status = getMigrationStatus();\n    if (status.main?.completed || status.background?.completedLanguages?.length) {\n      return await cleanupDuplicateGroups(getAvailableLocales, getAvailableGameModes);\n    }\n    return 0;\n  }, 'cleanupDuplicatesIfNeeded', 0);\n  \n  return result !== null ? result : 0;\n};\n\n/**\n * Migration function for current language only (fast path)\n */\nexport const migrateCurrentLanguage = async (locale?: string): Promise<boolean> => {\n  const currentLocale = locale || (await getCurrentLanguage());\n\n  try {\n    // Check if this language is already migrated\n    if (isCurrentLanguageMigrationCompleted(currentLocale)) {\n      return true;\n    }\n\n    // Prevent concurrent migrations for the same language\n    if (isLanguageMigrationInProgress(currentLocale)) {\n      // Wait for the current migration to complete with timeout\n      await waitForMigrationCompletion(\n        () => isLanguageMigrationInProgress(currentLocale),\n        `${currentLocale} migration`\n      );\n      // Re-check if migration is now completed\n      return isCurrentLanguageMigrationCompleted(currentLocale);\n    }\n\n    setLanguageMigrationInProgress(currentLocale, true);\n\n    try {\n      const gameModes = await getAvailableGameModes(currentLocale);\n\n      for (const gameMode of gameModes) {\n        try {\n          await importGroupsForLocaleAndGameMode(currentLocale, gameMode);\n        } catch (error) {\n          logError('error', `migrateCurrentLanguage:${currentLocale}/${gameMode}`, error);\n        }\n      }\n\n      // Clean up duplicates for current language\n      for (const gameMode of gameModes) {\n        try {\n          const { removeDuplicateGroups } = await import('@/stores/customGroups');\n          await removeDuplicateGroups(currentLocale, gameMode);\n        } catch (error) {\n          logError('warn', `cleanup:${currentLocale}/${gameMode}`, error);\n        }\n      }\n\n      // Mark this language as migrated\n      markLanguageMigrated(currentLocale);\n      return true;\n    } finally {\n      setLanguageMigrationInProgress(currentLocale, false);\n    }\n  } catch (error) {\n    logError('error', 'migrateCurrentLanguage', error);\n    setLanguageMigrationInProgress(currentLocale, false);\n    return false;\n  }\n};\n\n/**\n * Background migration for remaining languages\n */\nexport const migrateRemainingLanguages = async (excludeLocale?: string): Promise<void> => {\n  try {\n    // Prevent concurrent background migrations\n    if (isBackgroundMigrationInProgress()) {\n      return;\n    }\n\n    setBackgroundMigrationInProgress(true);\n    const currentLocale = excludeLocale || (await getCurrentLanguage());\n    markBackgroundMigrationInProgress(true);\n\n    const allLocales = await getAvailableLocales();\n    const remainingLocales = allLocales.filter(locale => locale !== currentLocale);\n\n    for (const locale of remainingLocales) {\n      // Check if already migrated\n      if (isCurrentLanguageMigrationCompleted(locale)) {\n        continue;\n      }\n\n      try {\n        const gameModes = await getAvailableGameModes(locale);\n\n        for (const gameMode of gameModes) {\n          await importGroupsForLocaleAndGameMode(locale, gameMode);\n          // Add small delay to prevent blocking the main thread\n          await new Promise(resolve => setTimeout(resolve, BACKGROUND_MIGRATION_DELAY));\n        }\n\n        // Clean up duplicates\n        for (const gameMode of gameModes) {\n          const { removeDuplicateGroups } = await import('@/stores/customGroups');\n          await removeDuplicateGroups(locale, gameMode);\n        }\n\n        markLanguageMigrated(locale);\n      } catch (error) {\n        logError('warn', `migrateRemainingLanguages:${locale}`, error);\n        // Continue with other languages even if one fails\n      }\n    }\n\n    markBackgroundMigrationInProgress(false);\n\n    // Check if all languages are now migrated\n    const { BACKGROUND_MIGRATION_KEY } = await import('./constants');\n    const bgStatus = safeLocalStorage.getJSON(BACKGROUND_MIGRATION_KEY);\n    const completedLanguages = new Set((bgStatus as any)?.completedLanguages || []);\n    const allLanguagesCompleted = SUPPORTED_LANGUAGES.every(lang => completedLanguages.has(lang));\n\n    if (allLanguagesCompleted) {\n      markMigrationComplete(); // Mark full migration as complete\n    }\n  } catch (error) {\n    logError('error', 'migrateRemainingLanguages', error);\n    markBackgroundMigrationInProgress(false);\n    setBackgroundMigrationInProgress(false);\n  } finally {\n    setBackgroundMigrationInProgress(false);\n  }\n};\n\n/**\n * Queue background migration for remaining languages\n */\nexport const queueBackgroundMigration = (excludeLocale?: string): void => {\n  try {\n    if (typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function') {\n      window.requestIdleCallback(\n        () => migrateRemainingLanguages(excludeLocale),\n        { timeout: IDLE_CALLBACK_TIMEOUT }\n      );\n    } else {\n      // Fallback for browsers without requestIdleCallback\n      setTimeout(() => migrateRemainingLanguages(excludeLocale), QUEUE_BACKGROUND_MIGRATION_DELAY);\n    }\n  } catch (error) {\n    logError('error', 'queueBackgroundMigration', error);\n  }\n};\n\n/**\n * Force migration for a specific language (useful when switching languages)\n */\nexport const ensureLanguageMigrated = async (locale: string): Promise<boolean> => {\n  try {\n    // Quick check first\n    const isCompleted = isCurrentLanguageMigrationCompleted(locale);\n    if (isCompleted) {\n      return true;\n    }\n\n    // If migration is in progress for this language, wait for it\n    if (isLanguageMigrationInProgress(locale)) {\n      await waitForMigrationCompletion(\n        () => isLanguageMigrationInProgress(locale),\n        `${locale} migration`\n      );\n      return isCurrentLanguageMigrationCompleted(locale);\n    }\n\n    return await migrateCurrentLanguage(locale);\n  } catch (error) {\n    logError('error', `ensureLanguageMigrated:${locale}`, error);\n    // Graceful fallback: allow the app to continue even if migration fails\n    logError('warn', 'Migration failed but app will continue', null, { locale });\n    return false;\n  }\n};\n\n/**\n * Run migration if needed (optimized for current language first)\n */\nexport const runMigrationIfNeeded = async (): Promise<boolean> => {\n  try {\n    // Check for version changes first\n    const { versionChanged } = checkAndHandleVersionChange();\n    if (versionChanged) {\n      // Version changed, force fresh migration\n    }\n\n    const currentLocale = await getCurrentLanguage();\n\n    // Check if the current language is already migrated\n    if (isCurrentLanguageMigrationCompleted(currentLocale)) {\n      return true;\n    }\n\n    // Prevent concurrent migrations\n    if (isMigrationInProgress()) {\n      await waitForMigrationCompletion(\n        () => isMigrationInProgress(),\n        'main migration'\n      );\n      // Re-check if migration is now completed\n      return isMigrationCompleted() || isCurrentLanguageMigrationCompleted(await getCurrentLanguage());\n    }\n\n    setMigrationInProgress(true);\n\n    try {\n      // Fast path: migrate current language only\n      const success = await migrateCurrentLanguage(currentLocale);\n\n      if (success) {\n        // Queue background migration for other languages\n        queueBackgroundMigration(currentLocale);\n      }\n\n      return success;\n    } finally {\n      setMigrationInProgress(false);\n    }\n  } catch (error) {\n    logError('error', 'runMigrationIfNeeded', error);\n    setMigrationInProgress(false);\n    // Graceful fallback: allow app to continue even if migration fails\n    logError('warn', 'Migration failed but app will continue with existing data', null);\n    return false;\n  }\n};\n\n/**\n * Developer utility: Force a fresh migration by clearing all data\n */\nexport const forceFreshMigration = async (): Promise<void> => {\n  try {\n    // Clear all localStorage\n    resetMigrationStatus();\n\n    // Optionally clear Dexie database too for a completely fresh start\n    const db = await import('@/stores/store');\n    await db.default.customGroups.clear();\n    await db.default.customTiles.clear();\n  } catch (error) {\n    logError('error', 'forceFreshMigration', error);\n  }\n};\n\n/**\n * Wait for a migration to complete with timeout\n */\nconst waitForMigrationCompletion = async (\n  checkInProgress: () => boolean,\n  operationName: string\n): Promise<void> => {\n  const startTime = Date.now();\n\n  while (checkInProgress()) {\n    if (Date.now() - startTime > MIGRATION_TIMEOUT) {\n      logError('warn', `Migration timeout: ${operationName} took longer than ${MIGRATION_TIMEOUT}ms`, null);\n      break;\n    }\n    await new Promise(resolve => setTimeout(resolve, 50));\n  }\n};"],"file":"js/migrationService.ts-D76R_cqn.js"}