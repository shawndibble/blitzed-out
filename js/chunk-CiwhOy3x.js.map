{"version":3,"mappings":"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","names":["logError","level","context","error","details","errorMessage","logMessage","safeLocalStorage","key","value","item","withErrorHandling","operation","fallback","isDuplicateError","isMigrationInProgress","status","MIGRATION_IN_PROGRESS_KEY","STALE_LOCK_TIMEOUT","setMigrationInProgress","inProgress","isLanguageMigrationInProgress","locale","CURRENT_LANGUAGE_MIGRATION_KEY","setLanguageMigrationInProgress","l","isBackgroundMigrationInProgress","BACKGROUND_MIGRATION_IN_PROGRESS_KEY","setBackgroundMigrationInProgress","markMigrationComplete","MIGRATION_VERSION","MIGRATION_KEY","markLanguageMigrated","bgStatus","BACKGROUND_MIGRATION_KEY","completedSet","markBackgroundMigrationInProgress","isMigrationCompleted","isCurrentLanguageMigrationCompleted","SUPPORTED_LANGUAGES","lang","getMigrationStatus","resetMigrationStatus","checkAndHandleVersionChange","oldVersion","clearAllMigrationData","getCurrentLanguage","resolved","i18n","currentLang","storedLanguage","browserLang","getAvailableLocales","locales","existingLocales","__variableDynamicImportRuntimeHelper","__vitePreload","e","getAvailableGameModes","gameModes","GAME_MODES","existingGameModes","gameMode","getActionGroupNames","allActionFiles","existingGroups","targetPath","filePath","variant","fileName","groupName","importActionFile","actionFile","label","type","actions","intensities","intensityName","index","customGroup","customTiles","actionList","intensity","i","action","addCustomGroupSafely","addCustomGroup","getNewTiles","existingTiles","getTiles","tile","existing","importCustomTilesSafely","tiles","importCustomTiles","importGroupsForLocaleAndGameMode","groupNames","groupsImported","tilesImported","db","n","module","getCustomGroupByName","result","newTiles","tilesAdded","cleanupDuplicateGroups","totalDuplicatesRemoved","duplicatesRemoved","removeDuplicateGroups","migrateActionGroups","cleanupDuplicatesIfNeeded","_a","_b","_c","migrateCurrentLanguage","currentLocale","waitForMigrationCompletion","migrateRemainingLanguages","excludeLocale","remainingLocales","resolve","BACKGROUND_MIGRATION_DELAY","completedLanguages","queueBackgroundMigration","IDLE_CALLBACK_TIMEOUT","QUEUE_BACKGROUND_MIGRATION_DELAY","ensureLanguageMigrated","runMigrationIfNeeded","versionChanged","success","forceFreshMigration","checkInProgress","operationName","startTime","MIGRATION_TIMEOUT"],"ignoreList":[],"sources":["../../src/services/migration/errorHandling.ts","../../src/services/migration/statusManager.ts","../../src/services/migration/versionManager.ts","../../src/services/migration/fileDiscovery.ts","../../src/services/migration/importOperations.ts","../../src/services/migration/index.ts"],"sourcesContent":["/**\n * Centralized error handling utilities for the migration service\n */\n\nexport type ErrorLevel = 'debug' | 'warn' | 'error';\n\n/**\n * Standardized error logging with consistent format\n */\nexport const logError = (\n  level: ErrorLevel,\n  context: string,\n  error: unknown,\n  details?: any\n): void => {\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  const logMessage = `[Migration ${context}] ${errorMessage}`;\n\n  if (details) {\n    console[level](logMessage, details);\n  } else {\n    console[level](logMessage);\n  }\n};\n\n/**\n * Safe localStorage operation wrapper\n */\nexport const safeLocalStorage = {\n  getItem: (key: string): string | null => {\n    try {\n      return localStorage.getItem(key);\n    } catch (error) {\n      logError('warn', 'localStorage.getItem', error, { key });\n      return null;\n    }\n  },\n\n  setItem: (key: string, value: string): boolean => {\n    try {\n      localStorage.setItem(key, value);\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.setItem', error, { key });\n      return false;\n    }\n  },\n\n  removeItem: (key: string): boolean => {\n    try {\n      localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.removeItem', error, { key });\n      return false;\n    }\n  },\n\n  getJSON: <T>(key: string): T | null => {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      logError('warn', 'localStorage.getJSON', error, { key });\n      return null;\n    }\n  },\n\n  setJSON: (key: string, value: any): boolean => {\n    try {\n      localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      logError('warn', 'localStorage.setJSON', error, { key });\n      return false;\n    }\n  },\n};\n\n/**\n * Async operation wrapper with consistent error handling\n */\nexport const withErrorHandling = async <T>(\n  operation: () => Promise<T>,\n  context: string,\n  fallback?: T\n): Promise<T | null> => {\n  try {\n    return await operation();\n  } catch (error) {\n    logError('error', context, error);\n    return fallback ?? null;\n  }\n};\n\n/**\n * Retry wrapper for potentially failing operations\n */\nexport const withRetry = async <T>(\n  operation: () => Promise<T>,\n  maxRetries: number = 3,\n  delay: number = 100\n): Promise<T> => {\n  let lastError: any;\n\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      if (attempt === maxRetries) {\n        throw error;\n      }\n      await new Promise((resolve) => setTimeout(resolve, delay * attempt));\n    }\n  }\n\n  throw lastError;\n};\n\n/**\n * Check if an error indicates a duplicate/conflict that can be safely ignored\n */\nexport const isDuplicateError = (error: unknown): boolean => {\n  if (error instanceof Error) {\n    return (\n      error.message.includes('already exists') ||\n      error.message.includes('duplicate') ||\n      error.message.includes('unique constraint')\n    );\n  }\n  return false;\n};\n\n/**\n * Safe timeout wrapper for promises\n */\nexport const withTimeout = <T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  errorMessage: string = 'Operation timed out'\n): Promise<T> => {\n  return Promise.race([\n    promise,\n    new Promise<never>((_, reject) => setTimeout(() => reject(new Error(errorMessage)), timeoutMs)),\n  ]);\n};\n","/**\n * Status management module for localStorage-based migration tracking\n */\n\nimport {\n  MIGRATION_KEY,\n  BACKGROUND_MIGRATION_KEY,\n  MIGRATION_IN_PROGRESS_KEY,\n  CURRENT_LANGUAGE_MIGRATION_KEY,\n  BACKGROUND_MIGRATION_IN_PROGRESS_KEY,\n  MIGRATION_VERSION,\n  STALE_LOCK_TIMEOUT,\n  SUPPORTED_LANGUAGES,\n} from './constants';\nimport {\n  MigrationStatus,\n  BackgroundMigrationStatus,\n  MigrationLockStatus,\n  LanguageMigrationStatus,\n  MigrationStatusSnapshot,\n} from './types';\nimport { safeLocalStorage, logError } from './errorHandling';\n\n/**\n * Check if main migration is in progress\n */\nexport const isMigrationInProgress = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationLockStatus>(MIGRATION_IN_PROGRESS_KEY);\n  if (!status) return false;\n\n  // Auto-cleanup stale locks\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT) {\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n    return false;\n  }\n\n  return status.inProgress;\n};\n\n/**\n * Set main migration progress status\n */\nexport const setMigrationInProgress = (inProgress: boolean): void => {\n  if (inProgress) {\n    const status: MigrationLockStatus = {\n      inProgress: true,\n      startedAt: new Date().toISOString(),\n    };\n    safeLocalStorage.setJSON(MIGRATION_IN_PROGRESS_KEY, status);\n  } else {\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n  }\n};\n\n/**\n * Check if language migration is in progress\n */\nexport const isLanguageMigrationInProgress = (locale: string): boolean => {\n  const status = safeLocalStorage.getJSON<LanguageMigrationStatus>(CURRENT_LANGUAGE_MIGRATION_KEY);\n  if (!status) return false;\n\n  // Auto-cleanup stale locks\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT) {\n    safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    return false;\n  }\n\n  return status.locales && status.locales.includes(locale);\n};\n\n/**\n * Set language migration progress status\n */\nexport const setLanguageMigrationInProgress = (locale: string, inProgress: boolean): void => {\n  const status = safeLocalStorage.getJSON<LanguageMigrationStatus>(\n    CURRENT_LANGUAGE_MIGRATION_KEY\n  ) || {\n    locales: [],\n    startedAt: new Date().toISOString(),\n  };\n\n  if (inProgress) {\n    if (!status.locales.includes(locale)) {\n      status.locales.push(locale);\n      status.startedAt = new Date().toISOString();\n    }\n  } else {\n    status.locales = status.locales.filter((l) => l !== locale);\n    if (status.locales.length === 0) {\n      safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n      return;\n    }\n  }\n\n  safeLocalStorage.setJSON(CURRENT_LANGUAGE_MIGRATION_KEY, status);\n};\n\n/**\n * Check if background migration is in progress\n */\nexport const isBackgroundMigrationInProgress = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationLockStatus>(\n    BACKGROUND_MIGRATION_IN_PROGRESS_KEY\n  );\n  if (!status) return false;\n\n  // Auto-cleanup stale locks (longer timeout for background operations)\n  if (Date.now() - new Date(status.startedAt).getTime() > STALE_LOCK_TIMEOUT * 2) {\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n    return false;\n  }\n\n  return status.inProgress;\n};\n\n/**\n * Set background migration progress status\n */\nexport const setBackgroundMigrationInProgress = (inProgress: boolean): void => {\n  if (inProgress) {\n    const status: MigrationLockStatus = {\n      inProgress: true,\n      startedAt: new Date().toISOString(),\n    };\n    safeLocalStorage.setJSON(BACKGROUND_MIGRATION_IN_PROGRESS_KEY, status);\n  } else {\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n  }\n};\n\n/**\n * Mark migration as completed\n */\nexport const markMigrationComplete = (): void => {\n  const status: MigrationStatus = {\n    version: MIGRATION_VERSION,\n    completed: true,\n    completedAt: new Date(),\n  };\n  safeLocalStorage.setJSON(MIGRATION_KEY, status);\n};\n\n/**\n * Mark a specific language as migrated in background status\n */\nexport const markLanguageMigrated = (locale: string): void => {\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(\n    BACKGROUND_MIGRATION_KEY\n  ) || {\n    version: MIGRATION_VERSION,\n    completedLanguages: [],\n    inProgress: false,\n  };\n\n  // Use Set to ensure uniqueness and atomic update\n  const completedSet = new Set(bgStatus.completedLanguages);\n  completedSet.add(locale);\n  bgStatus.completedLanguages = Array.from(completedSet);\n\n  safeLocalStorage.setJSON(BACKGROUND_MIGRATION_KEY, bgStatus);\n};\n\n/**\n * Mark background migration as in progress\n */\nexport const markBackgroundMigrationInProgress = (inProgress: boolean): void => {\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(\n    BACKGROUND_MIGRATION_KEY\n  ) || {\n    version: MIGRATION_VERSION,\n    completedLanguages: [],\n    inProgress: false,\n  };\n\n  bgStatus.inProgress = inProgress;\n  if (inProgress) {\n    bgStatus.startedAt = new Date();\n  } else {\n    bgStatus.completedAt = new Date();\n  }\n\n  safeLocalStorage.setJSON(BACKGROUND_MIGRATION_KEY, bgStatus);\n};\n\n/**\n * Check if migration has been completed\n */\nexport const isMigrationCompleted = (): boolean => {\n  const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n  if (!status) return false;\n\n  return status.completed && status.version === MIGRATION_VERSION;\n};\n\n/**\n * Check if current language migration has been completed\n */\nexport const isCurrentLanguageMigrationCompleted = (locale: string): boolean => {\n  // Check background migration status for specific language\n  const bgStatus = safeLocalStorage.getJSON<BackgroundMigrationStatus>(BACKGROUND_MIGRATION_KEY);\n\n  if (bgStatus && bgStatus.completedLanguages.includes(locale)) {\n    return true;\n  }\n\n  // Fallback: check if full migration is complete AND all languages are done\n  const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n  if (status && status.completed && status.version === MIGRATION_VERSION) {\n    // Only return true if this is a full migration (not just current language)\n    if (bgStatus) {\n      return SUPPORTED_LANGUAGES.every((lang) => bgStatus.completedLanguages.includes(lang));\n    }\n    // If no background status, assume full migration means all languages are done\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Get migration status for debugging\n */\nexport const getMigrationStatus = (): MigrationStatusSnapshot => {\n  return {\n    main: safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY),\n    background: safeLocalStorage.getJSON<BackgroundMigrationStatus>(BACKGROUND_MIGRATION_KEY),\n  };\n};\n\n/**\n * Reset migration status (for debugging/development)\n */\nexport const resetMigrationStatus = (): void => {\n  try {\n    safeLocalStorage.removeItem(MIGRATION_KEY);\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n    safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n    safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n    safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n  } catch (error) {\n    logError('error', 'resetMigrationStatus', error);\n  }\n};\n","/**\n * Version management module for handling version checks and updates\n */\n\nimport {\n  MIGRATION_KEY,\n  BACKGROUND_MIGRATION_KEY,\n  MIGRATION_IN_PROGRESS_KEY,\n  CURRENT_LANGUAGE_MIGRATION_KEY,\n  BACKGROUND_MIGRATION_IN_PROGRESS_KEY,\n  MIGRATION_VERSION,\n} from './constants';\nimport { MigrationStatus, VersionCheckResult } from './types';\nimport { safeLocalStorage, logError } from './errorHandling';\n\n/**\n * Check if migration version has changed and clear outdated data\n */\nexport const checkAndHandleVersionChange = (): VersionCheckResult => {\n  try {\n    const status = safeLocalStorage.getJSON<MigrationStatus>(MIGRATION_KEY);\n    if (!status) {\n      return { versionChanged: false };\n    }\n\n    const oldVersion = status.version;\n    const versionChanged = oldVersion !== MIGRATION_VERSION;\n\n    if (versionChanged) {\n      // Clear all migration-related localStorage\n      clearAllMigrationData();\n      return { versionChanged: true, oldVersion };\n    }\n\n    return { versionChanged: false, oldVersion };\n  } catch (error) {\n    logError('error', 'checkAndHandleVersionChange', error);\n    return { versionChanged: false };\n  }\n};\n\n/**\n * Clear all migration-related data from localStorage\n */\nexport const clearAllMigrationData = (): void => {\n  safeLocalStorage.removeItem(MIGRATION_KEY);\n  safeLocalStorage.removeItem(BACKGROUND_MIGRATION_KEY);\n  safeLocalStorage.removeItem(MIGRATION_IN_PROGRESS_KEY);\n  safeLocalStorage.removeItem(CURRENT_LANGUAGE_MIGRATION_KEY);\n  safeLocalStorage.removeItem(BACKGROUND_MIGRATION_IN_PROGRESS_KEY);\n};\n\n/**\n * Get current migration version\n */\nexport const getCurrentMigrationVersion = (): string => {\n  return MIGRATION_VERSION;\n};\n\n/**\n * Check if a version change requires data migration\n */\nexport const requiresDataMigration = (oldVersion?: string): boolean => {\n  if (!oldVersion) return true;\n\n  // Add logic here for version-specific migration requirements\n  // For now, any version change requires migration\n  return oldVersion !== MIGRATION_VERSION;\n};\n","/**\n * File discovery utilities for dynamic locale and game mode detection\n */\n\nimport { SUPPORTED_LANGUAGES, GAME_MODES } from './constants';\nimport { logError } from './errorHandling';\nimport i18n from '@/i18n';\n\n/**\n * Get current user language from i18next with fallbacks\n */\nexport const getCurrentLanguage = async (): Promise<string> => {\n  try {\n    // First try: get current language from i18next using proper API\n    const resolved = i18n.resolvedLanguage;\n    if (resolved !== undefined) {\n      return resolved;\n    }\n\n    // Second try: get language from i18next instance\n    const currentLang = i18n.language;\n    if (currentLang !== undefined) {\n      return currentLang;\n    }\n\n    // Third try: localStorage fallback\n    const storedLanguage = localStorage.getItem('i18nextLng');\n    if (storedLanguage && storedLanguage !== 'undefined') {\n      return storedLanguage;\n    }\n\n    // Fourth try: browser language with proper validation\n    if (typeof navigator !== 'undefined' && navigator.language) {\n      const browserLang = navigator.language.split('-')[0];\n      if (SUPPORTED_LANGUAGES.includes(browserLang as (typeof SUPPORTED_LANGUAGES)[number])) {\n        return browserLang;\n      }\n    }\n\n    // Final fallback: English\n    return 'en';\n  } catch (error) {\n    logError('error', 'getCurrentLanguage', error);\n    return 'en'; // Safe fallback\n  }\n};\n\n/**\n * Dynamically discover available locales from the filesystem\n */\nexport const getAvailableLocales = async (): Promise<string[]> => {\n  const locales = [...SUPPORTED_LANGUAGES];\n  const existingLocales: string[] = [];\n\n  for (const locale of locales) {\n    try {\n      // Test if locale exists by trying to import translation file\n      await import(`@/locales/${locale}/translation.json`);\n      existingLocales.push(locale);\n    } catch {\n      // Locale doesn't exist, skip it\n    }\n  }\n\n  return existingLocales;\n};\n\n/**\n * Dynamically discover available game modes for a locale\n */\nexport const getAvailableGameModes = async (locale: string): Promise<string[]> => {\n  const gameModes = [...GAME_MODES];\n  const existingGameModes: string[] = [];\n\n  for (const gameMode of gameModes) {\n    try {\n      // Test if gameMode exists by trying to import any known file\n      await import(`@/locales/${locale}/${gameMode}/alcohol.json`);\n      existingGameModes.push(gameMode);\n    } catch {\n      // Game mode doesn't exist for this locale, skip it\n    }\n  }\n\n  return existingGameModes;\n};\n\n/**\n * Dynamically discover action group names for a specific locale and game mode\n * Uses Vite's import.meta.glob to automatically discover all JSON files at build time\n */\nexport const getActionGroupNames = async (locale: string, gameMode: string): Promise<string[]> => {\n  // Use Vite's glob import to get all action group files for all locales and game modes\n  // This automatically discovers files at build time, eliminating the need for hardcoded lists\n  const allActionFiles = import.meta.glob('@/locales/*/*/*.json');\n\n  const existingGroups: string[] = [];\n  const targetPath = `@/locales/${locale}/${gameMode}/`;\n\n  // Filter for files matching the current locale and game mode\n  for (const filePath of Object.keys(allActionFiles)) {\n    // Check both @/ prefixed paths and resolved paths\n    const pathVariants = [\n      targetPath, // @/locales/en/online/\n      targetPath.replace('@/', '/src/'), // /src/locales/en/online/\n      `/${locale}/${gameMode}/`, // /en/online/\n      `locales/${locale}/${gameMode}/`, // locales/en/online/\n    ];\n\n    const pathMatches = pathVariants.some((variant) => filePath.includes(variant));\n    if (pathMatches) {\n      // Extract the group name from the file path\n      const fileName = filePath.split('/').pop();\n      if (fileName?.endsWith('.json')) {\n        const groupName = fileName.replace('.json', '');\n\n        try {\n          // Verify the file can be imported (additional safety check)\n          await allActionFiles[filePath]();\n          existingGroups.push(groupName);\n        } catch (error) {\n          // File exists but can't be imported, skip it\n          logError('warn', `getActionGroupNames: ${groupName} for ${locale}/${gameMode}`, error);\n        }\n      }\n    }\n  }\n\n  return existingGroups.sort(); // Sort for consistent ordering\n};\n","/**\n * Import operations module for handling action file imports and data conversion\n */\n\nimport { addCustomGroup, getCustomGroupByName, removeDuplicateGroups } from '@/stores/customGroups';\nimport { importCustomTiles, getTiles } from '@/stores/customTiles';\nimport { CustomGroupBase } from '@/types/customGroups';\nimport { CustomTileBase } from '@/types/customTiles';\nimport { ImportResult } from './types';\nimport { logError, withErrorHandling, isDuplicateError } from './errorHandling';\nimport { getActionGroupNames } from './fileDiscovery';\n\n/**\n * Import a single action file and convert it to a custom group with custom tiles\n */\nexport const importActionFile = async (\n  groupName: string,\n  locale: string,\n  gameMode: string\n): Promise<{ customGroup: CustomGroupBase; customTiles: CustomTileBase[] } | null> => {\n  return withErrorHandling(async () => {\n    // Import the action file\n    const actionFile = await import(`@/locales/${locale}/${gameMode}/${groupName}.json`);\n\n    // Extract data from the JSON file\n    const label = actionFile.label || groupName;\n    const type = actionFile.type || 'action';\n    const actions = actionFile.actions || {};\n\n    // Convert actions object to intensities array\n    const intensities = Object.keys(actions)\n      .filter((key) => key !== 'None') // Skip 'None' as it's always included\n      .map((intensityName, index) => ({\n        id: `${groupName}-${index + 1}`,\n        label: intensityName,\n        value: index + 1,\n        isDefault: true,\n      }));\n\n    // Create the custom group\n    const customGroup: CustomGroupBase = {\n      name: groupName,\n      label,\n      intensities,\n      type,\n      isDefault: true,\n      locale,\n      gameMode,\n    };\n\n    // Create custom tiles from the actions\n    const customTiles: CustomTileBase[] = [];\n\n    for (const [intensityName, actionList] of Object.entries(actions)) {\n      if (intensityName === 'None' || !Array.isArray(actionList)) continue;\n\n      // Find the intensity value for this intensity name\n      const intensity = intensities.find((i) => i.label === intensityName);\n      if (!intensity) continue;\n\n      // Create a tile for each action in this intensity\n      for (const action of actionList) {\n        if (typeof action === 'string' && action.trim()) {\n          customTiles.push({\n            group: groupName,\n            intensity: intensity.value,\n            action: action.trim(),\n            tags: ['default'], // Mark as default tiles from JSON files\n            isEnabled: 1,\n            isCustom: 0, // These are default tiles, not custom\n            gameMode,\n            locale,\n          });\n        }\n      }\n    }\n\n    return { customGroup, customTiles };\n  }, `importActionFile:${groupName}:${locale}/${gameMode}`);\n};\n\n/**\n * Add a custom group with error handling for duplicates\n */\nconst addCustomGroupSafely = async (customGroup: CustomGroupBase): Promise<boolean> => {\n  try {\n    await addCustomGroup(customGroup);\n    return true;\n  } catch (error) {\n    if (isDuplicateError(error)) {\n      // Group was already added by concurrent process, this is ok\n      return false;\n    }\n    throw error; // Re-throw other errors\n  }\n};\n\n/**\n * Filter out existing tiles to prevent duplicates\n */\nconst getNewTiles = async (\n  customTiles: CustomTileBase[],\n  locale: string,\n  gameMode: string,\n  groupName: string\n): Promise<CustomTileBase[]> => {\n  try {\n    const existingTiles = await getTiles({ locale, gameMode, group: groupName });\n\n    if (!existingTiles || !Array.isArray(existingTiles)) {\n      return customTiles; // If no existing tiles, all tiles are new\n    }\n\n    return customTiles.filter((tile) => {\n      return !existingTiles.some(\n        (existing) =>\n          existing.group === tile.group &&\n          existing.intensity === tile.intensity &&\n          existing.action === tile.action &&\n          existing.gameMode === tile.gameMode &&\n          existing.locale === tile.locale\n      );\n    });\n  } catch (error) {\n    logError('warn', `getNewTiles:${groupName}:${locale}/${gameMode}`, error);\n    return customTiles; // On error, import all tiles\n  }\n};\n\n/**\n * Import custom tiles with duplicate handling\n */\nconst importCustomTilesSafely = async (tiles: CustomTileBase[]): Promise<number> => {\n  if (tiles.length === 0) return 0;\n\n  try {\n    await importCustomTiles(tiles);\n    return tiles.length;\n  } catch (error) {\n    logError('warn', 'importCustomTilesSafely', error);\n    // Continue processing, don't fail the entire migration\n    return 0;\n  }\n};\n\n/**\n * Import all action groups for a specific locale and game mode\n * Uses Dexie transactions to prevent cursor invalidation during concurrent operations\n */\nexport const importGroupsForLocaleAndGameMode = async (\n  locale: string,\n  gameMode: string\n): Promise<ImportResult> => {\n  const groupNames = await getActionGroupNames(locale, gameMode);\n  let groupsImported = 0;\n  let tilesImported = 0;\n\n  // Import Dexie database for transaction usage\n  const db = await import('@/stores/store').then((module) => module.default);\n\n  // Use transaction to prevent cursor invalidation\n  return await db.transaction('rw', [db.customGroups, db.customTiles], async () => {\n    for (const groupName of groupNames) {\n      // Check if group already exists to prevent duplicates\n      const existingGroup = await getCustomGroupByName(groupName, locale, gameMode);\n      if (existingGroup) {\n        continue; // Group already exists, skip\n      }\n\n      const result = await importActionFile(groupName, locale, gameMode);\n      if (!result) continue;\n\n      const { customGroup, customTiles } = result;\n\n      try {\n        // Add the custom group with error handling for duplicates\n        const groupAdded = await addCustomGroupSafely(customGroup);\n        if (groupAdded) {\n          groupsImported++;\n        }\n\n        // Add the custom tiles if there are any\n        if (customTiles.length > 0) {\n          const newTiles = await getNewTiles(customTiles, locale, gameMode, groupName);\n          const tilesAdded = await importCustomTilesSafely(newTiles);\n          tilesImported += tilesAdded;\n        }\n      } catch (error) {\n        logError(\n          'error',\n          `importGroupsForLocaleAndGameMode:${groupName}:${locale}/${gameMode}`,\n          error\n        );\n      }\n    }\n\n    return { groupsImported, tilesImported };\n  });\n};\n\n/**\n * Clean up duplicate groups across all locales and game modes\n */\nexport const cleanupDuplicateGroups = async (\n  getAvailableLocales: () => Promise<string[]>,\n  getAvailableGameModes: (locale: string) => Promise<string[]>\n): Promise<number> => {\n  const result = await withErrorHandling(\n    async () => {\n      const locales = await getAvailableLocales();\n      let totalDuplicatesRemoved = 0;\n\n      for (const locale of locales) {\n        const gameModes = await getAvailableGameModes(locale);\n        for (const gameMode of gameModes) {\n          const duplicatesRemoved = await removeDuplicateGroups(locale, gameMode);\n          totalDuplicatesRemoved += duplicatesRemoved;\n        }\n      }\n\n      return totalDuplicatesRemoved;\n    },\n    'cleanupDuplicateGroups',\n    0\n  );\n\n  return result !== null ? result : 0;\n};\n","/**\n * Main migration service that orchestrates all migration modules\n *\n * This is the refactored migration service broken down into focused modules:\n * - types: Type definitions and interfaces\n * - constants: Configuration and constant values\n * - errorHandling: Centralized error handling patterns\n * - statusManager: localStorage-based migration tracking\n * - versionManager: Version checking and updates\n * - fileDiscovery: Dynamic file and locale discovery\n * - importOperations: File importing and data conversion\n * - validationUtils: Integrity checks and validation\n */\n\nimport {\n  MIGRATION_TIMEOUT,\n  BACKGROUND_MIGRATION_DELAY,\n  QUEUE_BACKGROUND_MIGRATION_DELAY,\n  IDLE_CALLBACK_TIMEOUT,\n  SUPPORTED_LANGUAGES,\n} from './constants';\nimport {\n  isMigrationInProgress,\n  setMigrationInProgress,\n  isLanguageMigrationInProgress,\n  setLanguageMigrationInProgress,\n  isBackgroundMigrationInProgress,\n  setBackgroundMigrationInProgress,\n  markMigrationComplete,\n  markLanguageMigrated,\n  markBackgroundMigrationInProgress,\n  isMigrationCompleted,\n  isCurrentLanguageMigrationCompleted,\n  getMigrationStatus,\n  resetMigrationStatus,\n} from './statusManager';\nimport { checkAndHandleVersionChange } from './versionManager';\nimport { getCurrentLanguage, getAvailableLocales, getAvailableGameModes } from './fileDiscovery';\nimport { importGroupsForLocaleAndGameMode, cleanupDuplicateGroups } from './importOperations';\nimport { withErrorHandling, logError, safeLocalStorage } from './errorHandling';\n\n// Re-export types for external consumption\nexport type {\n  MigrationStatus,\n  BackgroundMigrationStatus,\n  ImportResult,\n  VersionCheckResult,\n  MigrationStatusSnapshot,\n} from './types';\n\n// Re-export key functions that are used by external components\nexport {\n  isMigrationCompleted,\n  isCurrentLanguageMigrationCompleted,\n  getMigrationStatus,\n  resetMigrationStatus,\n} from './statusManager';\n\nexport { checkAndHandleVersionChange } from './versionManager';\nexport { verifyMigrationIntegrity, fixMigrationStatusCorruption } from './validationUtils';\n\n/**\n * Main migration function with dynamic discovery\n */\nexport const migrateActionGroups = async (): Promise<boolean> => {\n  const result = await withErrorHandling(\n    async () => {\n      // Dynamically discover available locales\n      const locales = await getAvailableLocales();\n\n      for (const locale of locales) {\n        // Dynamically discover available game modes for this locale\n        const gameModes = await getAvailableGameModes(locale);\n\n        for (const gameMode of gameModes) {\n          try {\n            await importGroupsForLocaleAndGameMode(locale, gameMode);\n          } catch (error) {\n            logError('error', `migrateActionGroups:${locale}/${gameMode}`, error);\n          }\n        }\n      }\n\n      // Clean up any duplicates that might exist from previous migrations\n      await cleanupDuplicateGroups(getAvailableLocales, getAvailableGameModes);\n\n      markMigrationComplete();\n      return true;\n    },\n    'migrateActionGroups',\n    false\n  );\n\n  return result !== null ? result : false;\n};\n\n/**\n * Clean up duplicate groups across all locales and game modes\n * Can be called independently of migration\n */\nexport const cleanupDuplicatesIfNeeded = async (): Promise<number> => {\n  const result = await withErrorHandling(\n    async () => {\n      const status = getMigrationStatus();\n      if (status.main?.completed || status.background?.completedLanguages?.length) {\n        return await cleanupDuplicateGroups(getAvailableLocales, getAvailableGameModes);\n      }\n      return 0;\n    },\n    'cleanupDuplicatesIfNeeded',\n    0\n  );\n\n  return result !== null ? result : 0;\n};\n\n/**\n * Migration function for current language only (fast path)\n */\nexport const migrateCurrentLanguage = async (locale?: string): Promise<boolean> => {\n  const currentLocale = locale || (await getCurrentLanguage());\n\n  try {\n    // Check if this language is already migrated\n    if (isCurrentLanguageMigrationCompleted(currentLocale)) {\n      return true;\n    }\n\n    // Prevent concurrent migrations for the same language\n    if (isLanguageMigrationInProgress(currentLocale)) {\n      // Wait for the current migration to complete with timeout\n      await waitForMigrationCompletion(\n        () => isLanguageMigrationInProgress(currentLocale),\n        `${currentLocale} migration`\n      );\n      // Re-check if migration is now completed\n      return isCurrentLanguageMigrationCompleted(currentLocale);\n    }\n\n    setLanguageMigrationInProgress(currentLocale, true);\n\n    try {\n      const gameModes = await getAvailableGameModes(currentLocale);\n\n      for (const gameMode of gameModes) {\n        try {\n          await importGroupsForLocaleAndGameMode(currentLocale, gameMode);\n        } catch (error) {\n          logError('error', `migrateCurrentLanguage:${currentLocale}/${gameMode}`, error);\n        }\n      }\n\n      // Clean up duplicates for current language\n      for (const gameMode of gameModes) {\n        try {\n          const { removeDuplicateGroups } = await import('@/stores/customGroups');\n          await removeDuplicateGroups(currentLocale, gameMode);\n        } catch (error) {\n          logError('warn', `cleanup:${currentLocale}/${gameMode}`, error);\n        }\n      }\n\n      // Mark this language as migrated\n      markLanguageMigrated(currentLocale);\n      return true;\n    } finally {\n      setLanguageMigrationInProgress(currentLocale, false);\n    }\n  } catch (error) {\n    logError('error', 'migrateCurrentLanguage', error);\n    setLanguageMigrationInProgress(currentLocale, false);\n    return false;\n  }\n};\n\n/**\n * Background migration for remaining languages\n */\nexport const migrateRemainingLanguages = async (excludeLocale?: string): Promise<void> => {\n  try {\n    // Prevent concurrent background migrations\n    if (isBackgroundMigrationInProgress()) {\n      return;\n    }\n\n    setBackgroundMigrationInProgress(true);\n    const currentLocale = excludeLocale || (await getCurrentLanguage());\n    markBackgroundMigrationInProgress(true);\n\n    const allLocales = await getAvailableLocales();\n    const remainingLocales = allLocales.filter((locale) => locale !== currentLocale);\n\n    for (const locale of remainingLocales) {\n      // Check if already migrated\n      if (isCurrentLanguageMigrationCompleted(locale)) {\n        continue;\n      }\n\n      try {\n        const gameModes = await getAvailableGameModes(locale);\n\n        for (const gameMode of gameModes) {\n          await importGroupsForLocaleAndGameMode(locale, gameMode);\n          // Add small delay to prevent blocking the main thread\n          await new Promise((resolve) => setTimeout(resolve, BACKGROUND_MIGRATION_DELAY));\n        }\n\n        // Clean up duplicates\n        for (const gameMode of gameModes) {\n          const { removeDuplicateGroups } = await import('@/stores/customGroups');\n          await removeDuplicateGroups(locale, gameMode);\n        }\n\n        markLanguageMigrated(locale);\n      } catch (error) {\n        logError('warn', `migrateRemainingLanguages:${locale}`, error);\n        // Continue with other languages even if one fails\n      }\n    }\n\n    markBackgroundMigrationInProgress(false);\n\n    // Check if all languages are now migrated\n    const { BACKGROUND_MIGRATION_KEY } = await import('./constants');\n    const bgStatus = safeLocalStorage.getJSON(BACKGROUND_MIGRATION_KEY);\n    const completedLanguages = new Set((bgStatus as any)?.completedLanguages || []);\n    const allLanguagesCompleted = SUPPORTED_LANGUAGES.every((lang) => completedLanguages.has(lang));\n\n    if (allLanguagesCompleted) {\n      markMigrationComplete(); // Mark full migration as complete\n    }\n  } catch (error) {\n    logError('error', 'migrateRemainingLanguages', error);\n    markBackgroundMigrationInProgress(false);\n    setBackgroundMigrationInProgress(false);\n  } finally {\n    setBackgroundMigrationInProgress(false);\n  }\n};\n\n/**\n * Queue background migration for remaining languages\n */\nexport const queueBackgroundMigration = (excludeLocale?: string): void => {\n  try {\n    if (typeof window !== 'undefined' && typeof window.requestIdleCallback === 'function') {\n      window.requestIdleCallback(() => migrateRemainingLanguages(excludeLocale), {\n        timeout: IDLE_CALLBACK_TIMEOUT,\n      });\n    } else {\n      // Fallback for browsers without requestIdleCallback\n      setTimeout(() => migrateRemainingLanguages(excludeLocale), QUEUE_BACKGROUND_MIGRATION_DELAY);\n    }\n  } catch (error) {\n    logError('error', 'queueBackgroundMigration', error);\n  }\n};\n\n/**\n * Force migration for a specific language (useful when switching languages)\n */\nexport const ensureLanguageMigrated = async (locale: string): Promise<boolean> => {\n  try {\n    // Quick check first\n    const isCompleted = isCurrentLanguageMigrationCompleted(locale);\n    if (isCompleted) {\n      return true;\n    }\n\n    // If migration is in progress for this language, wait for it\n    if (isLanguageMigrationInProgress(locale)) {\n      await waitForMigrationCompletion(\n        () => isLanguageMigrationInProgress(locale),\n        `${locale} migration`\n      );\n      return isCurrentLanguageMigrationCompleted(locale);\n    }\n\n    return await migrateCurrentLanguage(locale);\n  } catch (error) {\n    logError('error', `ensureLanguageMigrated:${locale}`, error);\n    // Graceful fallback: allow the app to continue even if migration fails\n    logError('warn', 'Migration failed but app will continue', null, { locale });\n    return false;\n  }\n};\n\n/**\n * Run migration if needed (optimized for current language first)\n */\nexport const runMigrationIfNeeded = async (): Promise<boolean> => {\n  try {\n    // Check for version changes first\n    const { versionChanged } = checkAndHandleVersionChange();\n    if (versionChanged) {\n      // Version changed, force fresh migration\n    }\n\n    const currentLocale = await getCurrentLanguage();\n\n    // Check if the current language is already migrated\n    if (isCurrentLanguageMigrationCompleted(currentLocale)) {\n      return true;\n    }\n\n    // Prevent concurrent migrations\n    if (isMigrationInProgress()) {\n      await waitForMigrationCompletion(() => isMigrationInProgress(), 'main migration');\n      // Re-check if migration is now completed\n      return (\n        isMigrationCompleted() || isCurrentLanguageMigrationCompleted(await getCurrentLanguage())\n      );\n    }\n\n    setMigrationInProgress(true);\n\n    try {\n      // Fast path: migrate current language only\n      const success = await migrateCurrentLanguage(currentLocale);\n\n      if (success) {\n        // Queue background migration for other languages\n        queueBackgroundMigration(currentLocale);\n      }\n\n      return success;\n    } finally {\n      setMigrationInProgress(false);\n    }\n  } catch (error) {\n    logError('error', 'runMigrationIfNeeded', error);\n    setMigrationInProgress(false);\n    // Graceful fallback: allow app to continue even if migration fails\n    logError('warn', 'Migration failed but app will continue with existing data', null);\n    return false;\n  }\n};\n\n/**\n * Developer utility: Force a fresh migration by clearing all data\n */\nexport const forceFreshMigration = async (): Promise<void> => {\n  try {\n    // Clear all localStorage\n    resetMigrationStatus();\n\n    // Optionally clear Dexie database too for a completely fresh start\n    const db = await import('@/stores/store');\n    await db.default.customGroups.clear();\n    await db.default.customTiles.clear();\n  } catch (error) {\n    logError('error', 'forceFreshMigration', error);\n  }\n};\n\n/**\n * Wait for a migration to complete with timeout\n */\nconst waitForMigrationCompletion = async (\n  checkInProgress: () => boolean,\n  operationName: string\n): Promise<void> => {\n  const startTime = Date.now();\n\n  while (checkInProgress()) {\n    if (Date.now() - startTime > MIGRATION_TIMEOUT) {\n      logError(\n        'warn',\n        `Migration timeout: ${operationName} took longer than ${MIGRATION_TIMEOUT}ms`,\n        null\n      );\n      break;\n    }\n    await new Promise((resolve) => setTimeout(resolve, 50));\n  }\n};\n"],"file":"js/chunk-CiwhOy3x.js"}