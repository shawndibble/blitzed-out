{"version":3,"file":"syncOrchestrator.ts-CbsSBZcP.js","sources":["../../src/services/sync/base.ts","../../src/services/sync/customGroupsSync.ts","../../src/services/sync/tileMatcher.ts","../../src/services/sync/customTilesSync.ts","../../src/services/sync/disabledDefaultsSync.ts","../../src/services/sync/gameBoardsSync.ts","../../src/services/sync/settingsSync.ts","../../src/services/sync/syncOrchestrator.ts"],"sourcesContent":["/**\n * Base utilities for sync operations\n */\nimport { getAuth } from 'firebase/auth';\nimport { doc, getDoc } from 'firebase/firestore';\nimport { db } from '@/services/firebase';\nimport type { SyncResult } from '@/types/sync';\n\nexport const SYNC_DELAY_MS = 50;\n\nexport class SyncBase {\n  /**\n   * Get authenticated user or throw error\n   */\n  static getAuthenticatedUser() {\n    const auth = getAuth();\n    const user = auth.currentUser;\n\n    if (!user) {\n      throw new Error('No user logged in');\n    }\n\n    return user;\n  }\n\n  /**\n   * Get user document from Firebase\n   */\n  static async getUserDocument(userId: string) {\n    const userDocRef = doc(db, 'user-data', userId);\n    return await getDoc(userDocRef);\n  }\n\n  /**\n   * Add sync delay between operations\n   */\n  static async addSyncDelay() {\n    await new Promise((resolve) => setTimeout(resolve, SYNC_DELAY_MS));\n  }\n\n  /**\n   * Safely remove ID field from object to avoid constraint errors\n   */\n  static removeId<T extends { id?: any }>(obj: T): Omit<T, 'id'> {\n    const { id, ...objWithoutId } = obj;\n    void id; // Explicitly ignore the id\n    return objWithoutId;\n  }\n\n  /**\n   * Handle sync operation errors consistently\n   */\n  static handleSyncError(operation: string, error: unknown): SyncResult {\n    console.error(`Error in ${operation}:`, error);\n    return {\n      success: false,\n      errors: [error instanceof Error ? error.message : String(error)],\n    };\n  }\n\n  /**\n   * Create success result\n   */\n  static createSuccessResult(itemsProcessed = 0): SyncResult {\n    return {\n      success: true,\n      itemsProcessed,\n    };\n  }\n}\n","import type { SyncOptions, SyncResult } from '@/types/sync';\nimport { clearUserCustomGroups, syncCustomGroupsToFirebase } from '../syncService';\n/**\n * Custom groups synchronization logic\n */\nimport { getCustomGroups, importCustomGroups } from '@/stores/customGroups';\n\nimport type { CustomGroupPull } from '@/types/customGroups';\nimport { SyncBase } from './base';\n\nexport class CustomGroupsSync extends SyncBase {\n  /**\n   * Sync custom groups from Firebase with smart conflict resolution\n   */\n  static async syncFromFirebase(\n    firebaseGroups: CustomGroupPull[],\n    options: SyncOptions\n  ): Promise<SyncResult> {\n    try {\n      const localGroups = await getCustomGroups({ isDefault: false });\n\n      // Smart conflict resolution\n      if (firebaseGroups.length === 0 && localGroups.length > 0 && !options.forceSync) {\n        await syncCustomGroupsToFirebase();\n        return this.createSuccessResult(localGroups.length);\n      }\n\n      if (firebaseGroups.length > 0 && localGroups.length > 0 && !options.forceSync) {\n        return await this.mergeConflicts(firebaseGroups, localGroups);\n      }\n\n      if (firebaseGroups.length > 0 && (localGroups.length === 0 || options.forceSync)) {\n        return await this.replaceLocal(firebaseGroups);\n      }\n\n      return this.createSuccessResult(0);\n    } catch (error) {\n      return this.handleSyncError('custom groups sync', error);\n    }\n  }\n\n  /**\n   * Merge Firebase groups with local groups (no conflicts)\n   */\n  private static async mergeConflicts(\n    firebaseGroups: CustomGroupPull[],\n    localGroups: any[]\n  ): Promise<SyncResult> {\n    let addedCount = 0;\n\n    for (const group of firebaseGroups) {\n      try {\n        const existingGroups = await getCustomGroups({\n          locale: group.locale,\n          gameMode: group.gameMode,\n          name: group.name,\n        });\n\n        if (existingGroups.length === 0) {\n          const groupWithoutId = this.removeId(group);\n          await importCustomGroups([groupWithoutId]);\n          addedCount++;\n        }\n      } catch (error) {\n        console.error('Error merging custom group:', group, error);\n      }\n    }\n\n    // Sync the merged result back to Firebase\n    await syncCustomGroupsToFirebase();\n\n    return this.createSuccessResult(addedCount + localGroups.length);\n  }\n\n  /**\n   * Replace local groups with Firebase groups\n   */\n  private static async replaceLocal(firebaseGroups: CustomGroupPull[]): Promise<SyncResult> {\n    await clearUserCustomGroups();\n    await this.addSyncDelay();\n\n    try {\n      const groupsWithoutIds = firebaseGroups.map((group) => this.removeId(group));\n      await importCustomGroups(groupsWithoutIds);\n\n      return this.createSuccessResult(firebaseGroups.length);\n    } catch (error) {\n      console.error('Error importing custom groups:', error);\n      return this.handleSyncError('groups import', error);\n    }\n  }\n}\n","/**\n * Tile Matching Service with Group ID Support\n *\n * Provides consistent tile matching logic using group_id-based keys instead of string matching\n * for improved sync reliability and performance.\n */\n\nimport { getTiles } from '@/stores/customTiles';\nimport type { CustomTilePull, CustomTileBase } from '@/types/customTiles';\n\nexport interface TileMatchKey {\n  group_id: string;\n  intensity: number;\n  action: string;\n  gameMode: string;\n  locale: string;\n}\n\nexport interface TileMatchResult {\n  existingTile: CustomTilePull | null;\n  isExactMatch: boolean;\n  matchKey: string;\n}\n\nexport class TileMatcher {\n  /**\n   * Creates a consistent matching key for tiles using group_id\n   */\n  static createKey(tile: CustomTileBase | CustomTilePull): string {\n    if (!tile.group_id) {\n      throw new Error(\n        `Tile missing group_id for matching: ${JSON.stringify({\n          id: (tile as CustomTilePull).id,\n          group_id: tile.group_id,\n          action: tile.action,\n        })}`\n      );\n    }\n\n    return `${tile.group_id}|${tile.intensity}|${tile.action}`;\n  }\n\n  /**\n   * Finds an existing tile that matches the provided tile using group_id-based matching\n   */\n  static async findExistingTile(tile: CustomTileBase): Promise<TileMatchResult> {\n    if (!tile.group_id) {\n      throw new Error(\n        `Cannot match tile without group_id: ${JSON.stringify({\n          group_id: tile.group_id,\n          action: tile.action,\n        })}`\n      );\n    }\n\n    try {\n      // Use group_id-based matching (preferred)\n      const existingTiles = await getTiles({\n        group_id: tile.group_id,\n        intensity: tile.intensity,\n        action: tile.action,\n      });\n\n      if (existingTiles.length > 0) {\n        return {\n          existingTile: existingTiles[0],\n          isExactMatch: true,\n          matchKey: this.createKey(tile),\n        };\n      }\n\n      return {\n        existingTile: null,\n        isExactMatch: false,\n        matchKey: this.createKey(tile),\n      };\n    } catch (error) {\n      console.error('Error finding existing tile:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Batch matching for multiple tiles to improve performance\n   */\n  static async batchFindExistingTiles(\n    tiles: CustomTileBase[]\n  ): Promise<Map<string, TileMatchResult>> {\n    const results = new Map<string, TileMatchResult>();\n\n    // Group tiles by group_id to optimize database queries\n    const tilesByGroupId = new Map<string, CustomTileBase[]>();\n\n    for (const tile of tiles) {\n      if (!tile.group_id) {\n        throw new Error(\n          `Tile missing group_id: ${JSON.stringify({\n            group_id: tile.group_id,\n            action: tile.action,\n          })}`\n        );\n      }\n\n      const groupTiles = tilesByGroupId.get(tile.group_id) || [];\n      groupTiles.push(tile);\n      tilesByGroupId.set(tile.group_id, groupTiles);\n    }\n\n    // Process each group\n    for (const [groupId, groupTiles] of tilesByGroupId) {\n      try {\n        // Get all existing tiles for this group\n        const existingTiles = await getTiles({ group_id: groupId });\n\n        // Create lookup map for existing tiles\n        const existingTileMap = new Map<string, CustomTilePull>();\n        for (const existing of existingTiles) {\n          const key = this.createKey(existing);\n          existingTileMap.set(key, existing);\n        }\n\n        // Match each tile in the group\n        for (const tile of groupTiles) {\n          const tileKey = this.createKey(tile);\n          const existingTile = existingTileMap.get(tileKey) || null;\n\n          results.set(tileKey, {\n            existingTile,\n            isExactMatch: existingTile !== null,\n            matchKey: tileKey,\n          });\n        }\n      } catch (error) {\n        console.error(`Error batch matching tiles for group ${groupId}:`, error);\n\n        // Fall back to individual matching for this group\n        for (const tile of groupTiles) {\n          try {\n            const result = await this.findExistingTile(tile);\n            results.set(this.createKey(tile), result);\n          } catch (individualError) {\n            console.error(`Error matching individual tile:`, individualError);\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Validates that a tile has all required fields for matching\n   */\n  static validateTileForMatching(tile: CustomTileBase): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    if (!tile.group_id || !tile.group_id.trim()) {\n      errors.push('Missing group_id');\n    }\n\n    if (tile.intensity === undefined || tile.intensity === null) {\n      errors.push('Missing intensity');\n    }\n\n    if (!tile.action || !tile.action.trim()) {\n      errors.push('Missing action');\n    }\n\n    // Note: locale and gameMode have defaults, so they're not strictly required\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Compares two tiles to determine if they represent the same tile\n   */\n  static tilesEqual(tile1: CustomTileBase, tile2: CustomTileBase): boolean {\n    // Both tiles must have group_id\n    if (!tile1.group_id || !tile2.group_id) {\n      throw new Error('Cannot compare tiles without group_id');\n    }\n\n    return (\n      tile1.group_id === tile2.group_id &&\n      tile1.intensity === tile2.intensity &&\n      tile1.action === tile2.action\n    );\n  }\n\n  /**\n   * Generates matching statistics for debugging and monitoring\n   */\n  static async generateMatchingStats(tiles: CustomTileBase[]): Promise<{\n    totalTiles: number;\n    tilesWithGroupId: number;\n    tilesMissingGroupId: number;\n    duplicateKeys: string[];\n    matchingErrors: Array<{ tile: CustomTileBase; error: string }>;\n  }> {\n    const stats = {\n      totalTiles: tiles.length,\n      tilesWithGroupId: 0,\n      tilesMissingGroupId: 0,\n      duplicateKeys: [] as string[],\n      matchingErrors: [] as Array<{ tile: CustomTileBase; error: string }>,\n    };\n\n    const keyCount = new Map<string, number>();\n\n    for (const tile of tiles) {\n      // Count tiles with/without group_id\n      if (tile.group_id && tile.group_id.trim()) {\n        stats.tilesWithGroupId++;\n      } else {\n        stats.tilesMissingGroupId++;\n      }\n\n      // Validate tile for matching\n      const validation = this.validateTileForMatching(tile);\n      if (!validation.valid) {\n        stats.matchingErrors.push({\n          tile,\n          error: validation.errors.join(', '),\n        });\n        continue;\n      }\n\n      // Check for duplicate keys\n      try {\n        const key = this.createKey(tile);\n        const count = keyCount.get(key) || 0;\n        keyCount.set(key, count + 1);\n\n        if (count > 0) {\n          stats.duplicateKeys.push(key);\n        }\n      } catch (error) {\n        stats.matchingErrors.push({\n          tile,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    return stats;\n  }\n}\n\nexport default TileMatcher;\n","import type { SyncOptions, SyncResult } from '@/types/sync';\n/**\n * Custom tiles synchronization logic\n * Updated to use group_id-based matching for improved sync reliability\n */\nimport { addCustomTile, getTiles, updateCustomTile } from '@/stores/customTiles';\nimport { deleteAllCustomTiles, syncCustomTilesToFirebase } from '../syncService';\n\nimport type { CustomTilePull } from '@/types/customTiles';\nimport { SyncBase } from './base';\nimport { TileMatcher } from './tileMatcher';\n\nexport class CustomTilesSync extends SyncBase {\n  /**\n   * Sync custom tiles from Firebase with smart conflict resolution\n   */\n  static async syncFromFirebase(\n    firebaseTiles: CustomTilePull[],\n    options: SyncOptions\n  ): Promise<SyncResult> {\n    try {\n      const localTiles = await getTiles({ isCustom: 1 });\n\n      // Smart conflict resolution\n      if (firebaseTiles.length === 0 && localTiles.length > 0 && !options.forceSync) {\n        await syncCustomTilesToFirebase();\n        return this.createSuccessResult(localTiles.length);\n      }\n\n      if (firebaseTiles.length > 0 && localTiles.length > 0 && !options.forceSync) {\n        return await this.mergeConflicts(firebaseTiles, localTiles);\n      }\n\n      if (firebaseTiles.length > 0 && (localTiles.length === 0 || options.forceSync)) {\n        return await this.replaceLocal(firebaseTiles);\n      }\n\n      return this.createSuccessResult(0);\n    } catch (error) {\n      return this.handleSyncError('custom tiles sync', error);\n    }\n  }\n\n  /**\n   * Merge Firebase tiles with local tiles using group_id-based matching\n   */\n  private static async mergeConflicts(\n    firebaseTiles: CustomTilePull[],\n    localTiles: any[]\n  ): Promise<SyncResult> {\n    let addedCount = 0;\n    let updatedCount = 0;\n\n    for (const tile of firebaseTiles) {\n      try {\n        // Only process actual custom tiles (isCustom: 1)\n        if (tile.isCustom !== 1) {\n          console.warn(`Skipping non-custom tile in custom tiles sync: ${tile.action}`);\n          continue;\n        }\n\n        // Validate tile has group_id (required for new sync system)\n        if (!tile.group_id || !tile.group_id.trim()) {\n          console.error(\n            `Tile missing group_id during sync: ${tile.action} (group_id: ${tile.group_id})`\n          );\n          throw new Error(`All tiles must have group_id for sync. Tile: ${tile.action}`);\n        }\n\n        const matchResult = await TileMatcher.findExistingTile(tile);\n\n        if (matchResult.existingTile) {\n          // Update existing tile if needed (only isEnabled can be synced)\n          if (matchResult.existingTile.isEnabled !== tile.isEnabled) {\n            await updateCustomTile(matchResult.existingTile.id!, {\n              isEnabled: tile.isEnabled,\n            });\n            updatedCount++;\n          }\n        } else {\n          // Add new tile\n          const tileWithoutId = this.removeId(tile);\n          await addCustomTile(tileWithoutId);\n          addedCount++;\n        }\n      } catch (error) {\n        console.error('Error merging custom tile:', tile, error);\n      }\n    }\n\n    // Sync the merged result back to Firebase\n    await syncCustomTilesToFirebase();\n\n    return this.createSuccessResult(addedCount + updatedCount + localTiles.length);\n  }\n\n  /**\n   * Replace local tiles with Firebase tiles using group_id-based matching\n   */\n  private static async replaceLocal(firebaseTiles: CustomTilePull[]): Promise<SyncResult> {\n    await deleteAllCustomTiles();\n    await this.addSyncDelay();\n\n    let importedCount = 0;\n\n    for (const tile of firebaseTiles) {\n      try {\n        // Only process actual custom tiles (isCustom: 1)\n        if (tile.isCustom !== 1) {\n          console.warn(`Skipping non-custom tile in custom tiles sync: ${tile.action}`);\n          continue;\n        }\n\n        // Validate tile has group_id (required for new sync system)\n        if (!tile.group_id || !tile.group_id.trim()) {\n          console.error(\n            `Tile missing group_id during import: ${tile.action} (group_id: ${tile.group_id})`\n          );\n          throw new Error(`All tiles must have group_id for sync. Tile: ${tile.action}`);\n        }\n\n        const matchResult = await TileMatcher.findExistingTile(tile);\n\n        if (!matchResult.existingTile) {\n          const tileWithoutId = this.removeId(tile);\n          await addCustomTile(tileWithoutId);\n          importedCount++;\n        }\n      } catch (error) {\n        console.error('Error importing custom tile:', tile, error);\n      }\n    }\n\n    return this.createSuccessResult(importedCount);\n  }\n}\n","/**\n * Disabled defaults synchronization logic\n */\nimport { SyncBase } from './base';\nimport { resetDisabledDefaults, applyDisabledDefaults } from '../syncService';\nimport type { SyncResult } from '@/types/sync';\n\nexport class DisabledDefaultsSync extends SyncBase {\n  /**\n   * Sync disabled defaults from Firebase\n   */\n  static async syncFromFirebase(disabledDefaults: any[]): Promise<SyncResult> {\n    try {\n      if (!disabledDefaults || disabledDefaults.length === 0) {\n        // Still reset any existing disabled defaults to clean state\n        await resetDisabledDefaults();\n        return this.createSuccessResult(0);\n      }\n\n      // Add validation to prevent applying excessive disabled defaults\n      const MAX_REASONABLE_DISABLED_DEFAULTS = 100;\n      if (disabledDefaults.length > MAX_REASONABLE_DISABLED_DEFAULTS) {\n        console.warn(\n          `⚠️ Firebase contains ${disabledDefaults.length} disabled defaults, which seems excessive.`\n        );\n        console.warn('Skipping disabled defaults sync to prevent data corruption.');\n\n        // Don't apply the disabled defaults but don't fail the sync either\n        return this.createSuccessResult(0);\n      }\n\n      await resetDisabledDefaults();\n\n      // Add sync delay\n      await this.addSyncDelay();\n\n      await applyDisabledDefaults(disabledDefaults);\n\n      return this.createSuccessResult(disabledDefaults.length);\n    } catch (error) {\n      return this.handleSyncError('disabled defaults sync', error);\n    }\n  }\n}\n","import type { DBGameBoard } from '@/types/gameBoard';\nimport { SyncBase } from './base';\nimport type { SyncResult } from '@/types/sync';\n/**\n * Game boards synchronization logic\n */\nimport { upsertBoard } from '@/stores/gameBoard';\n\nexport class GameBoardsSync extends SyncBase {\n  /**\n   * Sync game boards from Firebase\n   */\n  static async syncFromFirebase(gameBoards: DBGameBoard[]): Promise<SyncResult> {\n    if (!gameBoards || gameBoards.length === 0) {\n      return this.createSuccessResult(0);\n    }\n\n    try {\n      let importedCount = 0;\n      for (const board of gameBoards) {\n        try {\n          await upsertBoard({\n            title: board.title,\n            tiles: board.tiles || [],\n            tags: board.tags || [],\n            gameMode: board.gameMode || 'online',\n            isActive: board.isActive || 0,\n          });\n          importedCount++;\n        } catch (error) {\n          console.error('Error importing game board:', board, error);\n        }\n      }\n\n      return this.createSuccessResult(importedCount);\n    } catch (error) {\n      return this.handleSyncError('game boards sync', error);\n    }\n  }\n}\n","import { SyncBase } from './base';\nimport type { SyncResult } from '@/types/sync';\n/**\n * Settings synchronization logic\n */\nimport { useSettingsStore } from '@/stores/settingsStore';\n\nexport class SettingsSync extends SyncBase {\n  /**\n   * Sync settings from Firebase\n   */\n  static async syncFromFirebase(firebaseSettings: Record<string, any>): Promise<SyncResult> {\n    if (!firebaseSettings || Object.keys(firebaseSettings).length === 0) {\n      return this.createSuccessResult(0);\n    }\n\n    try {\n      const { updateSettings } = useSettingsStore.getState();\n\n      // Filter out any undefined values and localPlayers (which should stay local-only)\n      const cleanSettings = Object.fromEntries(\n        Object.entries(firebaseSettings).filter(\n          ([key, value]) => value !== undefined && key !== 'localPlayers'\n        )\n      );\n\n      if (Object.keys(cleanSettings).length > 0) {\n        updateSettings(cleanSettings);\n        return this.createSuccessResult(Object.keys(cleanSettings).length);\n      }\n\n      return this.createSuccessResult(0);\n    } catch (error) {\n      return this.handleSyncError('settings sync', error);\n    }\n  }\n}\n","import type { SyncOptions, SyncResult } from '@/types/sync';\nimport { cleanupDuplicateTiles, syncAllDataToFirebase } from '../syncService';\n\nimport { CustomGroupsSync } from './customGroupsSync';\n/**\n * Main sync orchestrator - coordinates all sync operations\n */\nimport { CustomTilesSync } from './customTilesSync';\nimport { DisabledDefaultsSync } from './disabledDefaultsSync';\nimport { GameBoardsSync } from './gameBoardsSync';\nimport { SettingsSync } from './settingsSync';\nimport { SyncBase } from './base';\n\nexport class SyncOrchestrator extends SyncBase {\n  /**\n   * Main sync function - refactored from the original syncDataFromFirebase\n   */\n  static async syncFromFirebase(options: SyncOptions = {}): Promise<boolean> {\n    try {\n      const user = this.getAuthenticatedUser();\n      const userDoc = await this.getUserDocument(user.uid);\n\n      if (!userDoc.exists()) {\n        return await syncAllDataToFirebase();\n      }\n\n      const userData = userDoc.data();\n\n      // Clean up any duplicate tiles first\n      await cleanupDuplicateTiles();\n\n      // Run all sync operations in parallel for better performance\n      const syncOperations = [\n        this.syncCustomTiles(userData, options),\n        this.syncCustomGroups(userData, options),\n        this.syncDisabledDefaults(userData),\n        this.syncGameBoards(userData),\n        this.syncSettings(userData),\n      ];\n\n      const results = await Promise.allSettled(syncOperations);\n\n      // Check if all operations succeeded\n      let totalSuccess = true;\n\n      results.forEach((result, index) => {\n        const operationNames = [\n          'Custom Tiles',\n          'Custom Groups',\n          'Disabled Defaults',\n          'Game Boards',\n          'Settings',\n        ];\n\n        if (result.status === 'fulfilled') {\n          const syncResult = result.value;\n          if (!syncResult.success) {\n            totalSuccess = false;\n            console.error(`❌ ${operationNames[index]} sync failed:`, syncResult.errors);\n          }\n        } else {\n          totalSuccess = false;\n          console.error(`❌ ${operationNames[index]} sync rejected:`, result.reason);\n        }\n      });\n\n      return totalSuccess;\n    } catch (error) {\n      console.error('Error in sync orchestrator:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Sync custom tiles with error handling\n   */\n  private static async syncCustomTiles(userData: any, options: SyncOptions): Promise<SyncResult> {\n    if (userData.customTiles !== undefined) {\n      const tiles = userData.customTiles || [];\n\n      // Check if any are actually disabled defaults (this shouldn't happen)\n      const invalidTiles = tiles.filter((tile: any) => tile.isCustom === 0);\n      if (invalidTiles.length > 0) {\n        console.warn(\n          `⚠️ Found ${invalidTiles.length} default tiles in customTiles field - data corruption detected`\n        );\n      }\n\n      return await CustomTilesSync.syncFromFirebase(tiles, options);\n    }\n    return this.createSuccessResult(0);\n  }\n\n  /**\n   * Sync custom groups with error handling\n   */\n  private static async syncCustomGroups(userData: any, options: SyncOptions): Promise<SyncResult> {\n    if (userData.customGroups !== undefined) {\n      return await CustomGroupsSync.syncFromFirebase(userData.customGroups || [], options);\n    }\n    return this.createSuccessResult(0);\n  }\n\n  /**\n   * Sync disabled defaults with error handling\n   */\n  private static async syncDisabledDefaults(userData: any): Promise<SyncResult> {\n    if (userData.disabledDefaults !== undefined) {\n      return await DisabledDefaultsSync.syncFromFirebase(userData.disabledDefaults || []);\n    }\n    return this.createSuccessResult(0);\n  }\n\n  /**\n   * Sync game boards with error handling\n   */\n  private static async syncGameBoards(userData: any): Promise<SyncResult> {\n    if (userData.gameBoards !== undefined) {\n      return await GameBoardsSync.syncFromFirebase(userData.gameBoards);\n    }\n    return this.createSuccessResult(0);\n  }\n\n  /**\n   * Sync settings with error handling\n   */\n  private static async syncSettings(userData: any): Promise<SyncResult> {\n    if (userData.settings !== undefined) {\n      return await SettingsSync.syncFromFirebase(userData.settings || {});\n    }\n    return this.createSuccessResult(0);\n  }\n}\n"],"names":["SyncBase","getAuthenticatedUser","user","getAuth","currentUser","Error","getUserDocument","userId","userDocRef","doc","db","getDoc","addSyncDelay","Promise","resolve","setTimeout","removeId","obj","id","objWithoutId","handleSyncError","operation","error","success","errors","message","String","createSuccessResult","itemsProcessed","CustomGroupsSync","syncFromFirebase","firebaseGroups","options","localGroups","getCustomGroups","isDefault","length","forceSync","syncCustomGroupsToFirebase","this","mergeConflicts","replaceLocal","addedCount","group","locale","gameMode","name","groupWithoutId","importCustomGroups","clearUserCustomGroups","groupsWithoutIds","map","TileMatcher","createKey","tile","group_id","JSON","stringify","action","intensity","findExistingTile","existingTiles","getTiles","existingTile","isExactMatch","matchKey","batchFindExistingTiles","tiles","results","Map","tilesByGroupId","groupTiles","get","push","set","groupId","existingTileMap","existing","key","tileKey","result","individualError","validateTileForMatching","trim","valid","tilesEqual","tile1","tile2","generateMatchingStats","stats","totalTiles","tilesWithGroupId","tilesMissingGroupId","duplicateKeys","matchingErrors","keyCount","validation","count","join","CustomTilesSync","firebaseTiles","localTiles","isCustom","syncCustomTilesToFirebase","updatedCount","matchResult","isEnabled","updateCustomTile","tileWithoutId","addCustomTile","deleteAllCustomTiles","importedCount","DisabledDefaultsSync","disabledDefaults","resetDisabledDefaults","MAX_REASONABLE_DISABLED_DEFAULTS","applyDisabledDefaults","GameBoardsSync","gameBoards","board","upsertBoard","title","tags","isActive","SettingsSync","firebaseSettings","Object","keys","updateSettings","useSettingsStore","getState","cleanSettings","fromEntries","entries","filter","value","SyncOrchestrator","userDoc","uid","exists","syncAllDataToFirebase","userData","data","cleanupDuplicateTiles","syncOperations","syncCustomTiles","syncCustomGroups","syncDisabledDefaults","syncGameBoards","syncSettings","allSettled","totalSuccess","forEach","index","status","customTiles","customGroups","settings"],"mappings":"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"}