{"version":3,"mappings":";ktBAMO,MAAMA,EAA+BC,GAAmD,CAC7F,MAAMC,EAA+B,GAErC,UAAWC,KAASF,EAAQ,CAE1B,MAAMG,EAAiB,CACrB,MAAOD,EAAM,OAASA,EAAM,KAC5B,KAAMA,EAAM,MAAQ,SACpB,QAAS,CACP,KAAM,EAAC,CACT,EAIF,GAAIA,EAAM,aAAe,MAAM,QAAQA,EAAM,WAAW,EACtD,UAAWE,KAAaF,EAAM,YAG5BC,EAAU,QAAQC,EAAU,KAAK,EAAI,GAIzCH,EAAQC,EAAM,IAAI,EAAIC,CACxB,CAEA,OAAOF,CACT,EAMaI,EAAgB,MAC3BC,EAAS,KACTC,EAAW,WACsB,CACjC,GAAI,CACF,MAAMP,EAAS,MAAMQ,EAAsBF,EAAQC,CAAQ,EAC3D,OAAOR,EAA4BC,CAAM,CAC3C,OAASS,EAAO,CACd,eAAQ,MAAM,sCAAuCA,CAAK,EACnD,EACT,CACF,EC6EaC,EAAsB,MAAOJ,EAAS,KAAMC,EAAW,WAA+B,CACjG,GAAI,CAEF,KAAM,CAACI,EAAgBC,CAAW,EAAI,MAAM,QAAQ,IAAI,CACtDP,EAAcC,EAAQC,CAAQ,EAAE,MAAM,KAAO,GAAG,EAChDC,EAAsBF,EAAQC,CAAQ,EAAE,MAAM,IAAM,EAAE,EACvD,EAEKM,EAAgB,OAAO,KAAKF,CAAc,EAAE,OAIlD,GAHmBC,EAAY,OAGdC,EACf,MAAO,GAIT,MAAMC,EAAqB,OAAO,KAAKH,CAAc,EAC/CI,EAAkB,IAAI,IAAIH,EAAY,IAAKI,GAAMA,EAAE,IAAI,CAAC,EAG9D,UAAWC,KAAaH,EACtB,GAAI,CAACC,EAAgB,IAAIE,CAAS,EAChC,MAAO,GAKX,MAAO,EACT,OAASR,EAAO,CACd,eAAQ,MAAM,gCAAiCA,CAAK,EAC7C,EACT,CACF,ECtIMS,EAAmB,+BACnBC,EAAqB,EACrBC,EAA0B,IAAS,IAKnCC,EAAiB,IAA4B,CACjD,GAAI,CACF,MAAMC,EAAS,aAAa,QAAQJ,CAAgB,EACpD,OAAOI,EAAS,KAAK,MAAMA,CAAM,EAAI,EACvC,OAASb,EAAO,CACd,eAAQ,KAAK,yCAA0CA,CAAK,EACrD,EACT,CACF,EAKMc,EAAoB,CACxBjB,EACAC,EACAiB,IACS,CACT,GAAI,CACF,MAAMC,EAAM,GAAGnB,CAAM,IAAIC,CAAQ,GAC3BmB,EAAQL,EAAA,EAEdK,EAAMD,CAAG,EAAI,CAET,aAAc,EACd,eAAgB,IAAI,OAAO,cAC3B,oBAAqB,EAEvB,GAAGC,EAAMD,CAAG,EACZ,GAAGD,CAAA,EAGL,aAAa,QAAQN,EAAkB,KAAK,UAAUQ,CAAK,CAAC,CAC9D,OAASjB,EAAO,CACd,QAAQ,KAAK,2CAA4CA,CAAK,CAChE,CACF,EAMakB,EAAuB,MAClCrB,EACAC,EAAmB,WACgB,CACnC,MAAMqB,EAAetB,GAAUuB,EAAK,kBAAoBA,EAAK,UAAY,KACnEJ,EAAM,GAAGG,CAAY,IAAIrB,CAAQ,GAEjCuB,EADcT,EAAA,EACYI,CAAG,GAAK,CACtC,aAAc,EACd,eAAgB,IAAI,KAAK,CAAC,EAAE,cAC5B,oBAAqB,GAIjBM,EAAe,CACnB,GAAGD,EACH,eAAgB,IAAI,KAAKA,EAAY,cAAc,GAG/CE,EAAgC,CACpC,UAAW,GACX,iBAAkB,GAClB,eAAgBD,EAAa,eAC7B,aAAcA,EAAa,aAC3B,QAAS,CACP,gBAAiB,aACjB,aAAc,GACd,OAAQH,EACR,SAAArB,CAAA,CACF,EAGF,GAAI,CAGF,GADgC,KAAK,MAAQwB,EAAa,eAAe,UAE7CX,GAC1BW,EAAa,sBAAwB,EAGrC,OAAAC,EAAO,UAAY,GACnBA,EAAO,QAAQ,gBAAkB,YACjCA,EAAO,QAAQ,aAAe,GACvBA,EAIT,MAAMC,EAAe,MAAMvB,EAAoBkB,EAAcrB,CAAQ,EAGrE,GAFAyB,EAAO,QAAQ,aAAeC,EAE1BA,EAEFD,EAAO,UAAY,GACnBA,EAAO,QAAQ,gBAAkB,YAGjCT,EAAkBK,EAAcrB,EAAU,CACxC,oBAAqB,EACrB,eAAgB,IAAI,OAAO,aAAY,CACxC,MACI,CAEL,MAAM2B,EAAkBC,EAAA,EACxBH,EAAO,QAAQ,gBAAkBE,EAGjC,MAAME,EAAkBL,EAAa,aAAe,EAC9CM,EAAyBN,EAAa,oBAAsB,EAElER,EAAkBK,EAAcrB,EAAU,CACxC,aAAc6B,EACd,oBAAqBC,EACrB,eAAgB,IAAI,OAAO,aAAY,CACxC,EAEDL,EAAO,aAAeI,EACtBJ,EAAO,iBAAmBK,GAA0BlB,EAEhDa,EAAO,mBACTA,EAAO,QAAQ,aAAe,oBAAoBK,CAAsB,2CAA2CT,CAAY,IAAIrB,CAAQ,IAE/I,CAEA,OAAOyB,CACT,OAASvB,EAAO,CACd,QAAQ,MAAM,iCAAkCA,CAAK,EAGrD,MAAM2B,EAAkBL,EAAa,aAAe,EAC9CM,EAAyBN,EAAa,oBAAsB,EAElE,OAAAR,EAAkBK,EAAcrB,EAAU,CACxC,aAAc6B,EACd,oBAAqBC,EACrB,eAAgB,IAAI,OAAO,aAAY,CACxC,EAEDL,EAAO,aAAeI,EACtBJ,EAAO,iBAAmBK,GAA0BlB,EACpDa,EAAO,QAAQ,gBAAkB,SACjCA,EAAO,QAAQ,aAAe,wBAAwBvB,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAAC,GAErGuB,CACT,CACF,EAKMG,EAAkC,IAA6C,CACnF,GAAI,CAEF,MAAMG,EAAa,aAAa,QAAQ,qCAAqC,EAC7E,GAAIA,EAAY,CACd,MAAMC,EAAS,KAAK,MAAMD,CAAU,EACpC,GAAIC,EAAO,WAAaA,EAAO,UAAY,QACzC,MAAO,WAEX,CAGA,MAAMC,EAAW,aAAa,QAAQ,kCAAkC,EACxE,GAAIA,EAAU,CACZ,MAAMD,EAAS,KAAK,MAAMC,CAAQ,EAClC,GAAID,EAAO,oBAAsBA,EAAO,mBAAmB,OAAS,EAClE,MAAO,WAEX,CAEA,MAAO,YACT,OAAS9B,EAAO,CACd,eAAQ,KAAK,iDAAkDA,CAAK,EAC7D,YACT,CACF,EAMagC,EAA6B,MACxCnC,EACAC,EAAmB,WACE,CACrB,MAAMqB,EAAetB,GAAUuB,EAAK,kBAAoBA,EAAK,UAAY,KAEzE,GAAI,CAEF,MAAMa,EAAe,CACnB,oCACA,yCACA,gDAGF,IAAIC,EAAY,GAChBD,EAAa,QAASjB,GAAQ,CAC5B,GAAI,CACF,aAAa,WAAWA,CAAG,CAC7B,OAAShB,EAAO,CACd,QAAQ,KAAK,oBAAoBgB,CAAG,IAAKhB,CAAK,EAC9CkC,EAAY,EACd,CACF,CAAC,EAGD,GAAI,CACFpB,EAAkBK,EAAcrB,EAAU,CACxC,aAAc,EACd,oBAAqB,EACrB,eAAgB,IAAI,KAAK,CAAC,EAAE,aAAY,CACzC,CACH,OAASE,EAAO,CACd,QAAQ,KAAK,iCAAkCA,CAAK,EACpDkC,EAAY,EACd,CAEA,MAAI,CAAAA,CAKN,OAASlC,EAAO,CACd,eAAQ,MAAM,6BAA8BA,CAAK,EAC1C,EACT,CACF,ECnOMmC,EAAmBC,gBAAiD,MAAS,EAU5E,SAASC,GAAe,CAC7B,MAAMC,EAAUC,aAAWJ,CAAgB,EAC3C,GAAIG,IAAY,OACd,MAAM,IAAI,MAAM,sDAAsD,EAExE,OAAOA,CACT,CA2CO,SAASE,EAAkB,CAAE,SAAAC,GAAoC,CACtE,KAAM,CAAE,KAAArB,CAAA,EAASsB,EAAA,EACX,CAACC,EAAuBC,CAAwB,EAAIC,WAAS,EAAK,EAClE,CAACC,EAAyBC,CAA0B,EAAIF,WAAS,EAAK,EACtE,CAACG,EAAsBC,CAAuB,EAAIJ,WAAS,EAAK,EAChE,CAAC7C,EAAOkD,CAAQ,EAAIL,WAAwB,IAAI,EAChD,CAACM,EAAWC,CAAY,EAAIP,WAAS,EAAK,EAC1C,CAACQ,EAAmBC,CAAoB,EAAIT,WAAS,EAAK,EAC1D,CAACU,EAAuBC,CAAwB,EAAIX,WAAgC,IAAI,EACxFY,EAAwBC,SAAoB,IAAI,GAAK,EAGrDC,EAAuBC,cAAY,SACd,YAAM,OAAO,mCAA6B,oCAElE,EAAE,EAGLC,YAAU,IAAM,CACd,MAAMC,EAAuB,SAAY,CACvC,GAAI,CACF,MAAMC,EAAmB,MAAMJ,EAAA,EACzBK,EAAgB5C,EAAK,UAAY,KAQvC,GAAI,CALgB,MAAM2C,EAAiB,yBACzCC,EACA,UAGgB,CAChBD,EAAiB,+BAEjBhB,EAA2B,EAAK,EAChCE,EAAwB,EAAK,EAC7B,MACF,CAEA,MAAMgB,EACJF,EAAiB,oCAAoCC,CAAa,EAC9DE,EAAgBH,EAAiB,uBAMvC,GAJAhB,EAA2BkB,CAAiB,EAC5ChB,EAAwBiB,CAAa,EAGjCD,EAAmB,CACrB,MAAME,EAAe,MAAMjD,EAAqB8C,EAAe,QAAQ,EACvEZ,EAAae,EAAa,SAAS,EAG/B,CAACA,EAAa,WAAaA,EAAa,kBAAoB,CAACd,IAC/DC,EAAqB,EAAI,EACP,MAAMtB,EAA2BgC,EAAe,QAAQ,GAIxEjB,EAA2B,EAAK,EAChCG,EAAS,IAAI,GAEbA,EAAS,kEAAkE,EAGjF,CACF,OAASlD,EAAO,CACd,QAAQ,KAAK,oCAAqCA,CAAK,EACvDkD,EAAS,kCAAkC,EAC3CE,EAAa,EAAK,CACpB,CACF,EAGIhC,EAAK,UAAYA,EAAK,WAAa,aACrC0C,EAAA,CAEJ,EAAG,CAAC1C,EAAK,SAAUuC,EAAsBN,CAAiB,CAAC,EAE3D,MAAMe,EAAgBR,cAAY,SAAY,CAC5C,MAAMI,EAAgB5C,EAAK,UAAY,KAEvC,GAAI,CAMF,GALAwB,EAAyB,EAAI,EAC7BM,EAAS,IAAI,EAEK,MAAMlB,EAA2BgC,EAAe,QAAQ,EAE3D,CACbV,EAAqB,EAAI,EACzBP,EAA2B,EAAK,EAChCK,EAAa,EAAK,EAGlB,MAAMW,EAAmB,MAAMJ,EAAA,EAG/B,GAFgB,MAAMI,EAAiB,uBAE1B,CACX,MAAMA,EAAiB,4BACvBhB,EAA2B,EAAI,EAC/BE,EAAwBc,EAAiB,sBAAsB,EAG/D,MAAMI,EAAe,MAAMjD,EAAqB8C,EAAe,QAAQ,EACvEZ,EAAae,EAAa,SAAS,CACrC,CACF,MACEjB,EAAS,wDAAwD,CAErE,OAASlD,EAAO,CACd,QAAQ,MAAM,yBAA0BA,CAAK,EAC7CkD,EAAS,wDAAwD,CACnE,SACEN,EAAyB,EAAK,CAChC,CACF,EAAG,CAACxB,EAAK,SAAUuC,CAAoB,CAAC,EAElCU,EAAmBT,cAAY,SAAY,CAC/C,GAAI,CAAAjB,EAEJ,CAAAC,EAAyB,EAAI,EAC7BM,EAAS,IAAI,EAEb,GAAI,CACF,MAAMa,EAAmB,MAAMJ,EAAA,EAG/B,GAFgB,MAAMI,EAAiB,uBAE1B,CAEX,MAAMA,EAAiB,4BAEvBhB,EAA2B,EAAI,EAC/BE,EAAwBc,EAAiB,sBAAsB,EAG/D,MAAMC,EAAgB5C,EAAK,UAAY,KACjC+C,EAAe,MAAMjD,EAAqB8C,EAAe,QAAQ,EACvEZ,EAAae,EAAa,SAAS,EAG9BA,EAAa,WAChBjB,EACE,wFAGN,MACEA,EAAS,2DAA2D,EACpEE,EAAa,EAAK,CAEtB,OAASpD,EAAO,CACd,QAAQ,MAAM,oBAAqBA,CAAK,EACxCkD,EAAS,2DAA2D,EACpEE,EAAa,EAAK,CACpB,SACER,EAAyB,EAAK,CAChC,EACF,EAAG,CAACD,EAAuBgB,EAAsBvC,EAAK,QAAQ,CAAC,EAGzDkD,EAAuBV,cAC1BW,GAAwB,CAEnBhB,GACF,aAAaA,CAAqB,EAIpC,MAAMiB,EAAU,WAAW,SAAY,CACrC,GAAI,CACF,MAAMT,EAAmB,MAAMJ,EAAA,EAG/B,GAAII,EAAiB,oCAAoCQ,CAAW,EAAG,CACrExB,EAA2B,EAAI,EAC/B,MACF,CAGAH,EAAyB,EAAI,EAC7BM,EAAS,IAAI,EAEG,MAAMa,EAAiB,uBAAuBQ,CAAW,GAGvExB,EAA2B,EAAI,EAE/BE,EAAwBc,EAAiB,sBAAsB,GAE/Db,EAAS,2DAA2D,CAExE,OAASuB,EAAK,CACZ,QAAQ,MAAM,mCAAoCA,CAAG,EACrDvB,EAAS,2DAA2D,CACtE,SACEN,EAAyB,EAAK,CAChC,CACF,EAAG,GAAG,EAENY,EAAyBgB,CAAO,CAClC,EACA,CAACjB,EAAuBI,CAAoB,GAGxCe,EAAyBd,cAC7B,MAAO/D,GAAsC,CAC3C,MAAMsB,EAAetB,GAAUuB,EAAK,UAAY,KAEhD,GAAI,CACF,MAAM2C,EAAmB,MAAMJ,EAAA,EAG/B,GAAII,EAAiB,oCAAoC5C,CAAY,EACnE,OAAA4B,EAA2B,EAAI,EACxB,GAITH,EAAyB,EAAI,EAC7B,MAAM+B,EAAU,MAAMZ,EAAiB,uBAAuB5C,CAAY,EAE1E,OAAIwD,GACF5B,EAA2B,EAAI,EAG1B4B,CACT,OAAS3E,EAAO,CACd,eAAQ,MAAM,oBAAoBmB,CAAY,cAAenB,CAAK,EAC3D,EACT,SACE4C,EAAyB,EAAK,CAChC,CACF,EACA,CAACxB,EAAK,SAAUuC,CAAoB,GAItCE,YAAU,IAAM,CACd,GAAI,CAACzC,EAAK,UAAYA,EAAK,WAAa,YAAa,OAGrD,MAAMwD,EAA0BC,GAAgB,CAC9CP,EAAqBO,CAAG,CAC1B,EAGA,OAAAzD,EAAK,GAAG,kBAAmBwD,CAAsB,GAGpB,SAAY,CACvC,GAAI,CACF,MAAMb,EAAmB,MAAMJ,EAAA,EACzBK,EAAgB5C,EAAK,UAAY,KAEjC0D,EAAcf,EAAiB,oCAAoCC,CAAa,EACtFjB,EAA2B+B,CAAW,EAGtC,MAAMC,EAAe,GAAGf,CAAa,WAEnC,CAACc,GACD,CAACnC,GACD,CAACc,EAAsB,QAAQ,IAAIsB,CAAY,IAG/CtB,EAAsB,QAAQ,IAAIsB,CAAY,EAG9CnC,EAAyB,EAAI,EAG7B,WAAW,SAAY,CACrB,GAAI,CACF,MAAMmB,EAAmB,MAAMJ,EAAA,EACf,MAAMI,EAAiB,uBAAuBC,CAAa,GAGzEjB,EAA2B,EAAI,EAC/BE,EAAwBc,EAAiB,sBAAsB,IAE/Db,EAAS,2DAA2D,EAEpEO,EAAsB,QAAQ,OAAOsB,CAAY,EAErD,OAASN,EAAK,CACZ,QAAQ,MAAM,oCAAqCA,CAAG,EACtDvB,EAAS,2DAA2D,EAEpEO,EAAsB,QAAQ,OAAOsB,CAAY,CACnD,SACEnC,EAAyB,EAAK,CAChC,CACF,EAAG,CAAC,EAER,OAAS6B,EAAK,CACZ,QAAQ,MAAM,wCAAyCA,CAAG,EAC1D7B,EAAyB,EAAK,CAChC,CACF,GAEA,EAGO,IAAM,CACXxB,EAAK,IAAI,kBAAmBwD,CAAsB,EAC9CrB,GACF,aAAaA,CAAqB,CAEtC,CACF,EAAG,CACDnC,EACAkD,EACA3B,EACAY,EACAI,CAAA,CACD,EAED,MAAMqB,EAA+B,CACnC,qBAAAhC,EACA,sBAAAL,EACA,wBAAAG,EACA,MAAA9C,EACA,UAAAmD,EACA,kBAAAE,EACA,iBAAAgB,EACA,uBAAAK,EACA,cAAAN,CAAA,EAGF,OAAOa,MAAC9C,EAAiB,SAAjB,CAA0B,MAAA6C,EAAe,SAAAvC,CAAA,CAAS,CAC5D","names":["convertDexieGroupsToActions","groups","actions","group","actionObj","intensity","importActions","locale","gameMode","getAllAvailableGroups","error","isDexieDataComplete","expectedGroups","dexieGroups","expectedCount","expectedGroupNames","dexieGroupNames","g","groupName","HEALTH_CHECK_KEY","MAX_RETRY_ATTEMPTS","MIN_VALIDATION_INTERVAL","getHealthState","stored","updateHealthState","update","key","state","checkMigrationHealth","targetLocale","i18n","storedState","currentState","report","dataComplete","migrationStatus","checkMigrationStatusFromStorage","newFailureCount","newConsecutiveFailures","mainStatus","parsed","bgStatus","recoverFromFailedMigration","keysToRemove","hasErrors","MigrationContext","createContext","useMigration","context","useContext","MigrationProvider","children","useTranslation","isMigrationInProgress","setIsMigrationInProgress","useState","currentLanguageMigrated","setCurrentLanguageMigrated","isMigrationCompleted","setIsMigrationCompleted","setError","isHealthy","setIsHealthy","recoveryAttempted","setRecoveryAttempted","languageChangeTimeout","setLanguageChangeTimeout","migrationAttemptedRef","useRef","loadMigrationService","useCallback","useEffect","checkMigrationStatus","migrationService","currentLocale","isCurrentMigrated","isAllMigrated","healthReport","forceRecovery","triggerMigration","handleLanguageChange","newLanguage","timeout","err","ensureLanguageMigrated","success","languageChangedHandler","lng","isCompleted","migrationKey","value","jsx"],"ignoreList":[],"sources":["../../src/services/dexieActionImport.ts","../../src/services/dataCompletenessChecker.ts","../../src/services/migrationHealthChecker.ts","../../src/context/migration.tsx"],"sourcesContent":["import { getAllAvailableGroups } from '@/stores/customGroups';\nimport { CustomGroupPull } from '@/types/customGroups';\n\n/**\n * Convert Dexie custom groups to the format expected by the old importActions function\n */\nexport const convertDexieGroupsToActions = (groups: CustomGroupPull[]): Record<string, any> => {\n  const actions: Record<string, any> = {};\n\n  for (const group of groups) {\n    // Convert the group to the expected format\n    const actionObj: any = {\n      label: group.label || group.name,\n      type: group.type || 'action',\n      actions: {\n        None: [], // Always include None as it's expected\n      },\n    };\n\n    // Convert intensities to actions format\n    if (group.intensities && Array.isArray(group.intensities)) {\n      for (const intensity of group.intensities) {\n        // For now, create empty arrays for each intensity\n        // The actual actions would come from custom tiles\n        actionObj.actions[intensity.label] = [];\n      }\n    }\n\n    actions[group.name] = actionObj;\n  }\n\n  return actions;\n};\n\n/**\n * Replacement for importActions from importLocales.ts\n * Gets actions from Dexie instead of JSON files\n */\nexport const importActions = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<Record<string, any>> => {\n  try {\n    const groups = await getAllAvailableGroups(locale, gameMode);\n    return convertDexieGroupsToActions(groups);\n  } catch (error) {\n    console.error('Error importing actions from Dexie:', error);\n    return {};\n  }\n};\n","import { getAllAvailableGroups } from '@/stores/customGroups';\nimport { importActions } from '@/services/dexieActionImport';\n\nexport interface DataCompletenessReport {\n  isComplete: boolean;\n  missingGroups: string[];\n  corruptedGroups: string[];\n  totalExpectedGroups: number;\n  totalDexieGroups: number;\n  details: {\n    [groupName: string]: {\n      exists: boolean;\n      hasIntensities: boolean;\n      hasLabel: boolean;\n      expectedIntensities: number;\n      actualIntensities: number;\n    };\n  };\n}\n\n/**\n * Check if Dexie contains complete and valid data for a given locale and game mode\n * by comparing against the expected JSON structure\n */\nexport const checkDataCompleteness = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<DataCompletenessReport> => {\n  const report: DataCompletenessReport = {\n    isComplete: false,\n    missingGroups: [],\n    corruptedGroups: [],\n    totalExpectedGroups: 0,\n    totalDexieGroups: 0,\n    details: {},\n  };\n\n  try {\n    // Get expected groups from JSON files\n    let expectedGroups: any = {};\n    try {\n      expectedGroups = await importActions(locale, gameMode);\n    } catch (error) {\n      console.warn(`Could not load expected actions for ${locale}/${gameMode}:`, error);\n      // If we can't load expected data, we can't validate completeness\n      return report;\n    }\n\n    const expectedGroupNames = Object.keys(expectedGroups);\n    report.totalExpectedGroups = expectedGroupNames.length;\n\n    // Get actual groups from Dexie\n    let dexieGroups: any[] = [];\n    try {\n      dexieGroups = await getAllAvailableGroups(locale, gameMode);\n    } catch (error) {\n      console.warn(`Could not load Dexie groups for ${locale}/${gameMode}:`, error);\n      return report;\n    }\n\n    report.totalDexieGroups = dexieGroups.length;\n\n    // Create a map of Dexie groups by name for quick lookup\n    const dexieGroupsMap = new Map(dexieGroups.map((group) => [group.name, group]));\n\n    // Check each expected group\n    for (const groupName of expectedGroupNames) {\n      const expectedGroup = expectedGroups[groupName];\n      const dexieGroup = dexieGroupsMap.get(groupName);\n\n      const groupDetail = {\n        exists: !!dexieGroup,\n        hasIntensities: false,\n        hasLabel: false,\n        expectedIntensities: 0,\n        actualIntensities: 0,\n      };\n\n      if (expectedGroup?.actions) {\n        // Count expected intensities (excluding 'None')\n        const expectedIntensityKeys = Object.keys(expectedGroup.actions).filter(\n          (key) => key !== 'None'\n        );\n        groupDetail.expectedIntensities = expectedIntensityKeys.length;\n      }\n\n      if (dexieGroup) {\n        groupDetail.hasLabel = !!dexieGroup.label;\n        groupDetail.hasIntensities =\n          Array.isArray(dexieGroup.intensities) && dexieGroup.intensities.length > 0;\n        groupDetail.actualIntensities = dexieGroup.intensities?.length || 0;\n\n        // Check if group is corrupted (missing essential data or incorrect intensity count)\n        const isCorrupted =\n          !groupDetail.hasLabel ||\n          !groupDetail.hasIntensities ||\n          (groupDetail.expectedIntensities > 0 &&\n            groupDetail.actualIntensities !== groupDetail.expectedIntensities);\n\n        if (isCorrupted) {\n          report.corruptedGroups.push(groupName);\n        }\n      } else {\n        report.missingGroups.push(groupName);\n      }\n\n      report.details[groupName] = groupDetail;\n    }\n\n    // Check if data is complete (no missing or corrupted groups)\n    report.isComplete =\n      report.missingGroups.length === 0 &&\n      report.corruptedGroups.length === 0 &&\n      report.totalDexieGroups >= report.totalExpectedGroups;\n\n    return report;\n  } catch (error) {\n    console.error('Error in checkDataCompleteness:', error);\n    return report;\n  }\n};\n\n/**\n * Quick check if Dexie data is complete without detailed analysis\n * This is optimized for performance and can be used for frequent checks\n */\nexport const isDexieDataComplete = async (locale = 'en', gameMode = 'online'): Promise<boolean> => {\n  try {\n    // Quick check: compare group counts first\n    const [expectedGroups, dexieGroups] = await Promise.all([\n      importActions(locale, gameMode).catch(() => ({})),\n      getAllAvailableGroups(locale, gameMode).catch(() => []),\n    ]);\n\n    const expectedCount = Object.keys(expectedGroups).length;\n    const dexieCount = dexieGroups.length;\n\n    // If counts don't match, definitely incomplete\n    if (dexieCount < expectedCount) {\n      return false;\n    }\n\n    // If counts match, do a quick validation of a few key groups\n    const expectedGroupNames = Object.keys(expectedGroups);\n    const dexieGroupNames = new Set(dexieGroups.map((g) => g.name));\n\n    // Check if all expected groups exist in Dexie\n    for (const groupName of expectedGroupNames) {\n      if (!dexieGroupNames.has(groupName)) {\n        return false;\n      }\n    }\n\n    // Basic validation passed\n    return true;\n  } catch (error) {\n    console.error('Error in isDexieDataComplete:', error);\n    return false;\n  }\n};\n\n/**\n * Get a summary of data completeness for debugging and monitoring\n */\nexport const getDataCompletenessSummary = async (\n  locale = 'en',\n  gameMode = 'online'\n): Promise<string> => {\n  try {\n    const report = await checkDataCompleteness(locale, gameMode);\n\n    let summary = `Data Completeness for ${locale}/${gameMode}:\\n`;\n    summary += `Overall: ${report.isComplete ? 'COMPLETE' : 'INCOMPLETE'}\\n`;\n    summary += `Expected groups: ${report.totalExpectedGroups}\\n`;\n    summary += `Dexie groups: ${report.totalDexieGroups}\\n`;\n\n    if (report.missingGroups.length > 0) {\n      summary += `Missing groups: ${report.missingGroups.join(', ')}\\n`;\n    }\n\n    if (report.corruptedGroups.length > 0) {\n      summary += `Corrupted groups: ${report.corruptedGroups.join(', ')}\\n`;\n    }\n\n    return summary;\n  } catch (error) {\n    return `Error generating completeness summary: ${error}`;\n  }\n};\n","import { isDexieDataComplete } from '@/services/dataCompletenessChecker';\nimport i18n from '@/i18n';\n\nexport interface MigrationHealthReport {\n  isHealthy: boolean;\n  requiresRecovery: boolean;\n  lastValidation: Date;\n  failureCount: number;\n  details: {\n    migrationStatus: 'completed' | 'failed' | 'incomplete';\n    dataComplete: boolean;\n    locale: string;\n    gameMode: string;\n    errorMessage?: string;\n  };\n}\n\ninterface MigrationHealthState {\n  [localeGameMode: string]: {\n    failureCount: number;\n    lastValidation: string; // ISO string for JSON serialization\n    consecutiveFailures: number;\n  };\n}\n\nconst HEALTH_CHECK_KEY = 'blitzed-out-migration-health';\nconst MAX_RETRY_ATTEMPTS = 3;\nconst MIN_VALIDATION_INTERVAL = 5 * 60 * 1000; // 5 minutes\n\n/**\n * Get stored health state from localStorage\n */\nconst getHealthState = (): MigrationHealthState => {\n  try {\n    const stored = localStorage.getItem(HEALTH_CHECK_KEY);\n    return stored ? JSON.parse(stored) : {};\n  } catch (error) {\n    console.warn('Failed to load migration health state:', error);\n    return {};\n  }\n};\n\n/**\n * Update health state in localStorage\n */\nconst updateHealthState = (\n  locale: string,\n  gameMode: string,\n  update: Partial<MigrationHealthState[string]>\n): void => {\n  try {\n    const key = `${locale}-${gameMode}`;\n    const state = getHealthState();\n\n    state[key] = {\n      ...{\n        failureCount: 0,\n        lastValidation: new Date().toISOString(),\n        consecutiveFailures: 0,\n      },\n      ...state[key],\n      ...update,\n    };\n\n    localStorage.setItem(HEALTH_CHECK_KEY, JSON.stringify(state));\n  } catch (error) {\n    console.warn('Failed to update migration health state:', error);\n  }\n};\n\n/**\n * Check if migration is healthy for the given locale and game mode\n * This performs a comprehensive check of migration status and data integrity\n */\nexport const checkMigrationHealth = async (\n  locale?: string,\n  gameMode: string = 'online'\n): Promise<MigrationHealthReport> => {\n  const targetLocale = locale || i18n.resolvedLanguage || i18n.language || 'en';\n  const key = `${targetLocale}-${gameMode}`;\n  const healthState = getHealthState();\n  const storedState = healthState[key] || {\n    failureCount: 0,\n    lastValidation: new Date(0).toISOString(),\n    consecutiveFailures: 0,\n  };\n\n  // Ensure lastValidation is a Date object for calculations\n  const currentState = {\n    ...storedState,\n    lastValidation: new Date(storedState.lastValidation),\n  };\n\n  const report: MigrationHealthReport = {\n    isHealthy: false,\n    requiresRecovery: false,\n    lastValidation: currentState.lastValidation,\n    failureCount: currentState.failureCount,\n    details: {\n      migrationStatus: 'incomplete',\n      dataComplete: false,\n      locale: targetLocale,\n      gameMode,\n    },\n  };\n\n  try {\n    // Skip validation if we just validated recently (unless we have failures)\n    const timeSinceLastValidation = Date.now() - currentState.lastValidation.getTime();\n    if (\n      timeSinceLastValidation < MIN_VALIDATION_INTERVAL &&\n      currentState.consecutiveFailures === 0\n    ) {\n      // Return cached result if we validated recently and had no failures\n      report.isHealthy = true;\n      report.details.migrationStatus = 'completed';\n      report.details.dataComplete = true;\n      return report;\n    }\n\n    // Check if data is complete in Dexie\n    const dataComplete = await isDexieDataComplete(targetLocale, gameMode);\n    report.details.dataComplete = dataComplete;\n\n    if (dataComplete) {\n      // Data is complete, migration is healthy\n      report.isHealthy = true;\n      report.details.migrationStatus = 'completed';\n\n      // Reset failure counters on success\n      updateHealthState(targetLocale, gameMode, {\n        consecutiveFailures: 0,\n        lastValidation: new Date().toISOString(),\n      });\n    } else {\n      // Data is incomplete, check migration status\n      const migrationStatus = checkMigrationStatusFromStorage();\n      report.details.migrationStatus = migrationStatus;\n\n      // Increment failure count\n      const newFailureCount = currentState.failureCount + 1;\n      const newConsecutiveFailures = currentState.consecutiveFailures + 1;\n\n      updateHealthState(targetLocale, gameMode, {\n        failureCount: newFailureCount,\n        consecutiveFailures: newConsecutiveFailures,\n        lastValidation: new Date().toISOString(),\n      });\n\n      report.failureCount = newFailureCount;\n      report.requiresRecovery = newConsecutiveFailures >= MAX_RETRY_ATTEMPTS;\n\n      if (report.requiresRecovery) {\n        report.details.errorMessage = `Migration failed ${newConsecutiveFailures} consecutive times. Data incomplete for ${targetLocale}/${gameMode}.`;\n      }\n    }\n\n    return report;\n  } catch (error) {\n    console.error('Migration health check failed:', error);\n\n    // Increment failure count\n    const newFailureCount = currentState.failureCount + 1;\n    const newConsecutiveFailures = currentState.consecutiveFailures + 1;\n\n    updateHealthState(targetLocale, gameMode, {\n      failureCount: newFailureCount,\n      consecutiveFailures: newConsecutiveFailures,\n      lastValidation: new Date().toISOString(),\n    });\n\n    report.failureCount = newFailureCount;\n    report.requiresRecovery = newConsecutiveFailures >= MAX_RETRY_ATTEMPTS;\n    report.details.migrationStatus = 'failed';\n    report.details.errorMessage = `Health check failed: ${error instanceof Error ? error.message : String(error)}`;\n\n    return report;\n  }\n};\n\n/**\n * Check migration status from localStorage\n */\nconst checkMigrationStatusFromStorage = (): 'completed' | 'failed' | 'incomplete' => {\n  try {\n    // Check main migration status\n    const mainStatus = localStorage.getItem('blitzed-out-action-groups-migration');\n    if (mainStatus) {\n      const parsed = JSON.parse(mainStatus);\n      if (parsed.completed && parsed.version === '2.1.1') {\n        return 'completed';\n      }\n    }\n\n    // Check background migration status\n    const bgStatus = localStorage.getItem('blitzed-out-background-migration');\n    if (bgStatus) {\n      const parsed = JSON.parse(bgStatus);\n      if (parsed.completedLanguages && parsed.completedLanguages.length > 0) {\n        return 'completed';\n      }\n    }\n\n    return 'incomplete';\n  } catch (error) {\n    console.warn('Failed to check migration status from storage:', error);\n    return 'incomplete';\n  }\n};\n\n/**\n * Attempt to recover from a failed migration\n * This clears migration locks and status, forcing a fresh migration attempt\n */\nexport const recoverFromFailedMigration = async (\n  locale?: string,\n  gameMode: string = 'online'\n): Promise<boolean> => {\n  const targetLocale = locale || i18n.resolvedLanguage || i18n.language || 'en';\n\n  try {\n    // Clear migration locks and status to force fresh migration\n    const keysToRemove = [\n      'blitzed-out-migration-in-progress',\n      'blitzed-out-current-language-migration',\n      'blitzed-out-background-migration-in-progress',\n    ];\n\n    let hasErrors = false;\n    keysToRemove.forEach((key) => {\n      try {\n        localStorage.removeItem(key);\n      } catch (error) {\n        console.warn(`Failed to remove ${key}:`, error);\n        hasErrors = true;\n      }\n    });\n\n    // Reset health state for this locale/gameMode\n    try {\n      updateHealthState(targetLocale, gameMode, {\n        failureCount: 0,\n        consecutiveFailures: 0,\n        lastValidation: new Date(0).toISOString(), // Force revalidation\n      });\n    } catch (error) {\n      console.warn('Failed to update health state:', error);\n      hasErrors = true;\n    }\n\n    if (hasErrors) {\n      return false;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Migration recovery failed:', error);\n    return false;\n  }\n};\n\n/**\n * Force a complete migration reset (nuclear option)\n * This removes all migration status and forces a complete re-migration\n */\nexport const forceCompleteMigrationReset = (): boolean => {\n  try {\n    const keysToRemove = [\n      'blitzed-out-action-groups-migration',\n      'blitzed-out-background-migration',\n      'blitzed-out-migration-in-progress',\n      'blitzed-out-current-language-migration',\n      'blitzed-out-background-migration-in-progress',\n      HEALTH_CHECK_KEY,\n    ];\n\n    keysToRemove.forEach((key) => {\n      try {\n        localStorage.removeItem(key);\n      } catch (error) {\n        console.warn(`Failed to remove ${key}:`, error);\n      }\n    });\n\n    return true;\n  } catch (error) {\n    console.error('Complete migration reset failed:', error);\n    return false;\n  }\n};\n\n/**\n * Get a summary of migration health across all locales and game modes\n */\nexport const getMigrationHealthSummary = async (): Promise<string> => {\n  try {\n    const locales = ['en', 'es', 'fr', 'zh', 'hi'];\n    const gameModes = ['online', 'local'];\n\n    let summary = 'Migration Health Summary:\\n';\n    let totalChecked = 0;\n    let totalHealthy = 0;\n    let totalRequireRecovery = 0;\n\n    for (const locale of locales) {\n      for (const gameMode of gameModes) {\n        try {\n          const report = await checkMigrationHealth(locale, gameMode);\n          totalChecked++;\n\n          if (report.isHealthy) {\n            totalHealthy++;\n          }\n\n          if (report.requiresRecovery) {\n            totalRequireRecovery++;\n            summary += `âŒ ${locale}/${gameMode}: REQUIRES RECOVERY (${report.failureCount} failures)\\n`;\n          } else if (!report.isHealthy) {\n            summary += `âš ï¸  ${locale}/${gameMode}: UNHEALTHY (${report.failureCount} failures)\\n`;\n          }\n        } catch (error) {\n          totalChecked++;\n          summary += `ðŸ’¥ ${locale}/${gameMode}: CHECK FAILED - ${error}\\n`;\n        }\n      }\n    }\n\n    summary += `\\nOverall: ${totalHealthy}/${totalChecked} healthy`;\n    if (totalRequireRecovery > 0) {\n      summary += `, ${totalRequireRecovery} require recovery`;\n    }\n\n    return summary;\n  } catch (error) {\n    return `Error generating migration health summary: ${error}`;\n  }\n};\n","import React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport {\n  checkMigrationHealth,\n  recoverFromFailedMigration,\n} from '@/services/migrationHealthChecker';\n\n/**\n * Context value interface for migration state management.\n * Provides centralized migration control and status tracking.\n */\ninterface MigrationContextValue {\n  /** Whether all supported languages have been migrated */\n  isMigrationCompleted: boolean;\n  /** Whether any migration operation is currently in progress */\n  isMigrationInProgress: boolean;\n  /** Whether the current language has been successfully migrated */\n  currentLanguageMigrated: boolean;\n  /** Any error that occurred during migration (non-blocking) */\n  error: string | null;\n  /** Whether the migration system is healthy and data is complete */\n  isHealthy: boolean;\n  /** Whether automatic recovery has been attempted */\n  recoveryAttempted: boolean;\n  /** Trigger migration for the current language */\n  triggerMigration: () => Promise<void>;\n  /** Ensure a specific language is migrated */\n  ensureLanguageMigrated: (locale?: string) => Promise<boolean>;\n  /** Force recovery from failed migration */\n  forceRecovery: () => Promise<void>;\n}\n\nconst MigrationContext = createContext<MigrationContextValue | undefined>(undefined);\n\n/**\n * Hook to access migration context.\n * Must be used within a MigrationProvider.\n *\n * @throws {Error} When used outside of MigrationProvider\n * @returns Migration context value with state and control functions\n */\n// eslint-disable-next-line react-refresh/only-export-components\nexport function useMigration() {\n  const context = useContext(MigrationContext);\n  if (context === undefined) {\n    throw new Error('useMigration must be used within a MigrationProvider');\n  }\n  return context;\n}\n\ninterface MigrationProviderProps {\n  children: React.ReactNode;\n}\n\n/**\n * Migration context provider that manages language file migration state.\n * Handles automatic migration on language changes with intelligent debouncing.\n *\n * ## Migration Lifecycle:\n * 1. **Initialization**: Checks migration status for current language\n * 2. **Language Change Detection**: Listens for i18next language changes\n * 3. **Debounced Migration**: Prevents duplicate migrations during rapid language switches\n * 4. **Status Updates**: Broadcasts migration state to all consuming components\n * 5. **Error Handling**: Graceful fallbacks when migration fails\n *\n * ## Key Features:\n * - **Lazy Loading**: Migration service loaded only when needed\n * - **Debouncing**: 300ms debounce prevents unnecessary migration attempts\n * - **Automatic Triggers**: Migrates new languages automatically\n * - **Status Tracking**: Comprehensive state management for all components\n * - **Error Resilience**: App continues functioning even if migration fails\n *\n * ## Usage:\n * Wrap your app with MigrationProvider at the root level, above all other providers\n * that might need access to migrated data.\n *\n * @example\n * ```tsx\n * function App() {\n *   return (\n *     <MigrationProvider>\n *       <AuthProvider>\n *         <Router>\n *           <AppRoutes />\n *         </Router>\n *       </AuthProvider>\n *     </MigrationProvider>\n *   );\n * }\n * ```\n */\nexport function MigrationProvider({ children }: MigrationProviderProps) {\n  const { i18n } = useTranslation();\n  const [isMigrationInProgress, setIsMigrationInProgress] = useState(false);\n  const [currentLanguageMigrated, setCurrentLanguageMigrated] = useState(false);\n  const [isMigrationCompleted, setIsMigrationCompleted] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [isHealthy, setIsHealthy] = useState(false);\n  const [recoveryAttempted, setRecoveryAttempted] = useState(false);\n  const [languageChangeTimeout, setLanguageChangeTimeout] = useState<NodeJS.Timeout | null>(null);\n  const migrationAttemptedRef = useRef<Set<string>>(new Set());\n\n  // Lazy load migration service to avoid blocking main bundle\n  const loadMigrationService = useCallback(async () => {\n    const migrationService = await import('@/services/migrationService');\n    return migrationService;\n  }, []);\n\n  // Check migration status and health on mount\n  useEffect(() => {\n    const checkMigrationStatus = async () => {\n      try {\n        const migrationService = await loadMigrationService();\n        const currentLocale = i18n.language || 'en';\n\n        // First check if migration status is corrupted\n        const integrityOk = await migrationService.verifyMigrationIntegrity(\n          currentLocale,\n          'online'\n        );\n\n        if (!integrityOk) {\n          migrationService.fixMigrationStatusCorruption();\n          // After reset, re-check status\n          setCurrentLanguageMigrated(false);\n          setIsMigrationCompleted(false);\n          return;\n        }\n\n        const isCurrentMigrated =\n          migrationService.isCurrentLanguageMigrationCompleted(currentLocale);\n        const isAllMigrated = migrationService.isMigrationCompleted();\n\n        setCurrentLanguageMigrated(isCurrentMigrated);\n        setIsMigrationCompleted(isAllMigrated);\n\n        // Perform health check if migration appears complete but we want to verify data integrity\n        if (isCurrentMigrated) {\n          const healthReport = await checkMigrationHealth(currentLocale, 'online');\n          setIsHealthy(healthReport.isHealthy);\n\n          // If migration claims to be complete but health check fails, attempt recovery\n          if (!healthReport.isHealthy && healthReport.requiresRecovery && !recoveryAttempted) {\n            setRecoveryAttempted(true);\n            const recovered = await recoverFromFailedMigration(currentLocale, 'online');\n\n            if (recovered) {\n              // Trigger a fresh migration attempt after recovery\n              setCurrentLanguageMigrated(false);\n              setError(null);\n            } else {\n              setError('Migration recovery failed. Some features may not work correctly.');\n            }\n          }\n        }\n      } catch (error) {\n        console.warn('Failed to check migration status:', error);\n        setError('Failed to check migration status');\n        setIsHealthy(false);\n      }\n    };\n\n    // Only check status after i18n is initialized\n    if (i18n.language && i18n.language !== 'undefined') {\n      checkMigrationStatus();\n    }\n  }, [i18n.language, loadMigrationService, recoveryAttempted]);\n\n  const forceRecovery = useCallback(async () => {\n    const currentLocale = i18n.language || 'en';\n\n    try {\n      setIsMigrationInProgress(true);\n      setError(null);\n\n      const recovered = await recoverFromFailedMigration(currentLocale, 'online');\n\n      if (recovered) {\n        setRecoveryAttempted(true);\n        setCurrentLanguageMigrated(false);\n        setIsHealthy(false);\n\n        // Trigger fresh migration after recovery\n        const migrationService = await loadMigrationService();\n        const success = await migrationService.runMigrationIfNeeded();\n\n        if (success) {\n          await migrationService.cleanupDuplicatesIfNeeded();\n          setCurrentLanguageMigrated(true);\n          setIsMigrationCompleted(migrationService.isMigrationCompleted());\n\n          // Re-check health after successful migration\n          const healthReport = await checkMigrationHealth(currentLocale, 'online');\n          setIsHealthy(healthReport.isHealthy);\n        }\n      } else {\n        setError('Force recovery failed. Please try refreshing the page.');\n      }\n    } catch (error) {\n      console.error('Force recovery failed:', error);\n      setError('Force recovery failed. Please try refreshing the page.');\n    } finally {\n      setIsMigrationInProgress(false);\n    }\n  }, [i18n.language, loadMigrationService]);\n\n  const triggerMigration = useCallback(async () => {\n    if (isMigrationInProgress) return;\n\n    setIsMigrationInProgress(true);\n    setError(null);\n\n    try {\n      const migrationService = await loadMigrationService();\n      const success = await migrationService.runMigrationIfNeeded();\n\n      if (success) {\n        // Clean up any duplicates\n        await migrationService.cleanupDuplicatesIfNeeded();\n\n        setCurrentLanguageMigrated(true);\n        setIsMigrationCompleted(migrationService.isMigrationCompleted());\n\n        // Perform health check after successful migration\n        const currentLocale = i18n.language || 'en';\n        const healthReport = await checkMigrationHealth(currentLocale, 'online');\n        setIsHealthy(healthReport.isHealthy);\n\n        // If health check fails immediately after migration, something is wrong\n        if (!healthReport.isHealthy) {\n          setError(\n            'Migration completed but data validation failed. Some features may not work correctly.'\n          );\n        }\n      } else {\n        setError('Migration failed but app will continue with existing data');\n        setIsHealthy(false);\n      }\n    } catch (error) {\n      console.error('Migration failed:', error);\n      setError('Migration failed but app will continue with existing data');\n      setIsHealthy(false);\n    } finally {\n      setIsMigrationInProgress(false);\n    }\n  }, [isMigrationInProgress, loadMigrationService, i18n.language]);\n\n  // Debounced language change handler\n  const handleLanguageChange = useCallback(\n    (newLanguage: string) => {\n      // Clear any existing timeout\n      if (languageChangeTimeout) {\n        clearTimeout(languageChangeTimeout);\n      }\n\n      // Debounce language changes by 300ms to handle rapid switches\n      const timeout = setTimeout(async () => {\n        try {\n          const migrationService = await loadMigrationService();\n\n          // Check if this language is already migrated\n          if (migrationService.isCurrentLanguageMigrationCompleted(newLanguage)) {\n            setCurrentLanguageMigrated(true);\n            return;\n          }\n\n          // Trigger migration for the new language\n          setIsMigrationInProgress(true);\n          setError(null);\n\n          const success = await migrationService.ensureLanguageMigrated(newLanguage);\n\n          if (success) {\n            setCurrentLanguageMigrated(true);\n            // Update overall migration status\n            setIsMigrationCompleted(migrationService.isMigrationCompleted());\n          } else {\n            setError('Migration failed but app will continue with existing data');\n          }\n        } catch (err) {\n          console.error('Error during language migration:', err);\n          setError('Migration failed but app will continue with existing data');\n        } finally {\n          setIsMigrationInProgress(false);\n        }\n      }, 300);\n\n      setLanguageChangeTimeout(timeout);\n    },\n    [languageChangeTimeout, loadMigrationService]\n  );\n\n  const ensureLanguageMigrated = useCallback(\n    async (locale?: string): Promise<boolean> => {\n      const targetLocale = locale || i18n.language || 'en';\n\n      try {\n        const migrationService = await loadMigrationService();\n\n        // Check if already migrated\n        if (migrationService.isCurrentLanguageMigrationCompleted(targetLocale)) {\n          setCurrentLanguageMigrated(true);\n          return true;\n        }\n\n        // Trigger migration if needed\n        setIsMigrationInProgress(true);\n        const success = await migrationService.ensureLanguageMigrated(targetLocale);\n\n        if (success) {\n          setCurrentLanguageMigrated(true);\n        }\n\n        return success;\n      } catch (error) {\n        console.error(`Failed to ensure ${targetLocale} migration:`, error);\n        return false;\n      } finally {\n        setIsMigrationInProgress(false);\n      }\n    },\n    [i18n.language, loadMigrationService]\n  );\n\n  // Listen for i18next language changes\n  useEffect(() => {\n    if (!i18n.language || i18n.language === 'undefined') return;\n\n    // Set up language change listener\n    const languageChangedHandler = (lng: string) => {\n      handleLanguageChange(lng);\n    };\n\n    // Subscribe to language change events\n    i18n.on('languageChanged', languageChangedHandler);\n\n    // Initial migration check for current language\n    const checkInitialLanguage = async () => {\n      try {\n        const migrationService = await loadMigrationService();\n        const currentLocale = i18n.language || 'en';\n\n        const isCompleted = migrationService.isCurrentLanguageMigrationCompleted(currentLocale);\n        setCurrentLanguageMigrated(isCompleted);\n\n        // SAFETY: Only trigger migration if not already in progress, not completed, and not attempted\n        const migrationKey = `${currentLocale}-initial`;\n        if (\n          !isCompleted &&\n          !isMigrationInProgress &&\n          !migrationAttemptedRef.current.has(migrationKey)\n        ) {\n          // Mark as attempted to prevent React Strict Mode double-invoke\n          migrationAttemptedRef.current.add(migrationKey);\n\n          // Set in progress IMMEDIATELY to prevent infinite loop\n          setIsMigrationInProgress(true);\n\n          // Use setTimeout to break out of the current execution cycle\n          setTimeout(async () => {\n            try {\n              const migrationService = await loadMigrationService();\n              const success = await migrationService.ensureLanguageMigrated(currentLocale);\n\n              if (success) {\n                setCurrentLanguageMigrated(true);\n                setIsMigrationCompleted(migrationService.isMigrationCompleted());\n              } else {\n                setError('Migration failed but app will continue with existing data');\n                // Remove from attempted set if failed so it can be retried\n                migrationAttemptedRef.current.delete(migrationKey);\n              }\n            } catch (err) {\n              console.error('Error during migration execution:', err);\n              setError('Migration failed but app will continue with existing data');\n              // Remove from attempted set if failed so it can be retried\n              migrationAttemptedRef.current.delete(migrationKey);\n            } finally {\n              setIsMigrationInProgress(false);\n            }\n          }, 0);\n        }\n      } catch (err) {\n        console.error('Error during initial migration check:', err);\n        setIsMigrationInProgress(false);\n      }\n    };\n\n    checkInitialLanguage();\n\n    // Cleanup subscription on unmount\n    return () => {\n      i18n.off('languageChanged', languageChangedHandler);\n      if (languageChangeTimeout) {\n        clearTimeout(languageChangeTimeout);\n      }\n    };\n  }, [\n    i18n,\n    handleLanguageChange,\n    isMigrationInProgress,\n    languageChangeTimeout,\n    loadMigrationService,\n  ]);\n\n  const value: MigrationContextValue = {\n    isMigrationCompleted,\n    isMigrationInProgress,\n    currentLanguageMigrated,\n    error,\n    isHealthy,\n    recoveryAttempted,\n    triggerMigration,\n    ensureLanguageMigrated,\n    forceRecovery,\n  };\n\n  return <MigrationContext.Provider value={value}>{children}</MigrationContext.Provider>;\n}\n"],"file":"js/chunk-DdqCdLjH.js"}