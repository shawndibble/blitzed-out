import{s as y,a as b,b as d,d as m,u as T,e as f,i as _,j as p,k as F,l as $,m as M,n as v}from"../assets/index-CkzIFlXA.js";import{X as C,g as w,Y as S,u as R}from"./chunk-p4pxY8Oa.js";import{a as x,n as D,o as A}from"./chunk-BiwsK_3v.js";import"./chunk-yoN304NG.js";import"./chunk-4cS4U0wq.js";import"./chunk-CXoKBXvA.js";(function(){try{var n=typeof window!="undefined"?window:typeof global!="undefined"?global:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:{};n.SENTRY_RELEASE={id:"95c5b929dfa5d4a23daf998c8c04f95694a33293"}}catch(t){}})();try{(function(){var n=typeof window!="undefined"?window:typeof global!="undefined"?global:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:{},t=new n.Error().stack;t&&(n._sentryDebugIds=n._sentryDebugIds||{},n._sentryDebugIds[t]="36ef4933-eb1a-43f5-8c83-56a3c640f8c6",n._sentryDebugIdIdentifier="sentry-dbid-36ef4933-eb1a-43f5-8c83-56a3c640f8c6")})()}catch(n){}const I=50;class u{static getAuthenticatedUser(){const e=x().currentUser;if(!e)throw new Error("No user logged in");return e}static async getUserDocument(t){const e=D(C,"user-data",t);return await A(e)}static async addSyncDelay(){await new Promise(t=>setTimeout(t,I))}static removeId(t){const{id:e,...s}=t;return s}static handleSyncError(t,e){return console.error(`Error in ${t}:`,e),{success:!1,errors:[e instanceof Error?e.message:String(e)]}}static createSuccessResult(t=0){return{success:!0,itemsProcessed:t}}}class L extends u{static async syncFromFirebase(t,e){try{const s=await w({isDefault:!1});return t.length===0&&s.length>0&&!e.forceSync?(console.log("Preserving local custom groups - Firebase is empty but local has data"),await y(),this.createSuccessResult(s.length)):t.length>0&&s.length>0&&!e.forceSync?await this.mergeConflicts(t,s):t.length>0&&(s.length===0||e.forceSync)?await this.replaceLocal(t):this.createSuccessResult(0)}catch(s){return this.handleSyncError("custom groups sync",s)}}static async mergeConflicts(t,e){console.log(`Merging groups: Local has ${e.length}, Firebase has ${t.length}`);let s=0;for(const r of t)try{if((await w({locale:r.locale,gameMode:r.gameMode,name:r.name})).length===0){const o=this.removeId(r);await S([o]),s++}}catch(i){console.error("Error merging custom group:",r,i)}return console.log(`Merged groups: Added ${s} new groups from Firebase, preserved ${e.length} local groups`),await y(),this.createSuccessResult(s+e.length)}static async replaceLocal(t){console.log(`Syncing ${t.length} custom groups from Firebase`),await b(),await this.addSyncDelay();try{const e=t.map(s=>this.removeId(s));return await S(e),console.log(`Successfully imported ${t.length} custom groups from Firebase`),this.createSuccessResult(t.length)}catch(e){return console.error("Error importing custom groups:",e),this.handleSyncError("groups import",e)}}}class E{static createKey(t){if(!t.group_id)throw new Error(`Tile missing group_id for matching: ${JSON.stringify({id:t.id,group:t.group,action:t.action})}`);return`${t.group_id}|${t.intensity}|${t.action}|${t.gameMode||"online"}|${t.locale||"en"}`}static async findExistingTile(t){if(!t.group_id)throw new Error(`Cannot match tile without group_id: ${JSON.stringify({group:t.group,action:t.action})}`);try{const e=await d({group_id:t.group_id,intensity:t.intensity,action:t.action,gameMode:t.gameMode||"online",locale:t.locale||"en"});return e.length>0?{existingTile:e[0],isExactMatch:!0,matchKey:this.createKey(t)}:{existingTile:null,isExactMatch:!1,matchKey:this.createKey(t)}}catch(e){throw console.error("Error finding existing tile:",e),e}}static async batchFindExistingTiles(t){const e=new Map,s=new Map;for(const r of t){if(!r.group_id)throw new Error(`Tile missing group_id: ${JSON.stringify({group:r.group,action:r.action})}`);const i=s.get(r.group_id)||[];i.push(r),s.set(r.group_id,i)}for(const[r,i]of s)try{const o=await d({group_id:r}),c=new Map;for(const a of o){const l=this.createKey(a);c.set(l,a)}for(const a of i){const l=this.createKey(a),g=c.get(l)||null;e.set(l,{existingTile:g,isExactMatch:g!==null,matchKey:l})}}catch(o){console.error(`Error batch matching tiles for group ${r}:`,o);for(const c of i)try{const a=await this.findExistingTile(c);e.set(this.createKey(c),a)}catch(a){console.error("Error matching individual tile:",a)}}return e}static validateTileForMatching(t){const e=[];return(!t.group_id||!t.group_id.trim())&&e.push("Missing group_id"),(!t.group||!t.group.trim())&&e.push("Missing group name"),(t.intensity===void 0||t.intensity===null)&&e.push("Missing intensity"),(!t.action||!t.action.trim())&&e.push("Missing action"),{valid:e.length===0,errors:e}}static tilesEqual(t,e){if(!t.group_id||!e.group_id)throw new Error("Cannot compare tiles without group_id");return t.group_id===e.group_id&&t.intensity===e.intensity&&t.action===e.action&&(t.gameMode||"online")===(e.gameMode||"online")&&(t.locale||"en")===(e.locale||"en")}static async generateMatchingStats(t){const e={totalTiles:t.length,tilesWithGroupId:0,tilesMissingGroupId:0,duplicateKeys:[],matchingErrors:[]},s=new Map;for(const r of t){r.group_id&&r.group_id.trim()?e.tilesWithGroupId++:e.tilesMissingGroupId++;const i=this.validateTileForMatching(r);if(!i.valid){e.matchingErrors.push({tile:r,error:i.errors.join(", ")});continue}try{const o=this.createKey(r),c=s.get(o)||0;s.set(o,c+1),c>0&&e.duplicateKeys.push(o)}catch(o){e.matchingErrors.push({tile:r,error:o instanceof Error?o.message:String(o)})}}return e}}class K extends u{static async syncFromFirebase(t,e){try{const s=await d({isCustom:1});return t.length===0&&s.length>0&&!e.forceSync?(console.log("Preserving local custom tiles - Firebase is empty but local has data"),await m(),this.createSuccessResult(s.length)):t.length>0&&s.length>0&&!e.forceSync?await this.mergeConflicts(t,s):t.length>0&&(s.length===0||e.forceSync)?await this.replaceLocal(t):this.createSuccessResult(0)}catch(s){return this.handleSyncError("custom tiles sync",s)}}static async mergeConflicts(t,e){console.log(`Merging tiles: Local has ${e.length}, Firebase has ${t.length}`);let s=0,r=0;for(const i of t)try{if(i.isCustom!==1){console.warn(`Skipping non-custom tile in custom tiles sync: ${i.action}`);continue}if(!i.group_id||!i.group_id.trim())throw console.error(`Tile missing group_id during sync: ${i.action} (group: ${i.group})`),new Error(`All tiles must have group_id for sync. Tile: ${i.action}`);const o=await E.findExistingTile(i);if(o.existingTile)o.existingTile.isEnabled!==i.isEnabled&&(await T(o.existingTile.id,{isEnabled:i.isEnabled}),r++);else{const c=this.removeId(i);await f(c),s++}}catch(o){console.error("Error merging custom tile:",i,o)}return console.log(`Merged tiles: Added ${s} new tiles, updated ${r} tiles from Firebase, preserved ${e.length} local tiles`),await m(),this.createSuccessResult(s+r+e.length)}static async replaceLocal(t){console.log(`Syncing ${t.length} custom tiles from Firebase`),await _(),await this.addSyncDelay();let e=0;for(const s of t)try{if(s.isCustom!==1){console.warn(`Skipping non-custom tile in custom tiles sync: ${s.action}`);continue}if(!s.group_id||!s.group_id.trim())throw console.error(`Tile missing group_id during import: ${s.action} (group: ${s.group})`),new Error(`All tiles must have group_id for sync. Tile: ${s.action}`);if(!(await E.findExistingTile(s)).existingTile){const i=this.removeId(s);await f(i),e++}}catch(r){console.error("Error importing custom tile:",s,r)}return console.log(`Successfully imported ${e} custom tiles from Firebase`),this.createSuccessResult(e)}}class G extends u{static async syncFromFirebase(t){try{return!t||t.length===0?(await p(),this.createSuccessResult(0)):t.length>100?(console.warn(`⚠️ Firebase contains ${t.length} disabled defaults, which seems excessive.`),console.warn("Skipping disabled defaults sync to prevent data corruption."),this.createSuccessResult(0)):(await p(),await this.addSyncDelay(),await F(t),this.createSuccessResult(t.length))}catch(e){return this.handleSyncError("disabled defaults sync",e)}}}class O extends u{static async syncFromFirebase(t){if(!t||t.length===0)return this.createSuccessResult(0);try{let e=0;for(const s of t)try{await $({title:s.title,tiles:s.tiles||[],tags:s.tags||[],gameMode:s.gameMode||"online",isActive:s.isActive||0}),e++}catch(r){console.error("Error importing game board:",s,r)}return this.createSuccessResult(e)}catch(e){return this.handleSyncError("game boards sync",e)}}}class k extends u{static async syncFromFirebase(t){if(!t||Object.keys(t).length===0)return this.createSuccessResult(0);try{const{updateSettings:e}=R.getState(),s=Object.fromEntries(Object.entries(t).filter(([r,i])=>i!==void 0&&r!=="localPlayers"));return Object.keys(s).length>0?(e(s),this.createSuccessResult(Object.keys(s).length)):this.createSuccessResult(0)}catch(e){return this.handleSyncError("settings sync",e)}}}class Y extends u{static async syncFromFirebase(t={}){try{const e=this.getAuthenticatedUser(),s=await this.getUserDocument(e.uid);if(!s.exists())return await M();const r=s.data();await v();const i=[this.syncCustomTiles(r,t),this.syncCustomGroups(r,t),this.syncDisabledDefaults(r),this.syncGameBoards(r),this.syncSettings(r)],o=await Promise.allSettled(i);let c=!0;return o.forEach((a,l)=>{const g=["Custom Tiles","Custom Groups","Disabled Defaults","Game Boards","Settings"];if(a.status==="fulfilled"){const h=a.value;h.success||(c=!1,console.error(`❌ ${g[l]} sync failed:`,h.errors))}else c=!1,console.error(`❌ ${g[l]} sync rejected:`,a.reason)}),c}catch(e){return console.error("Error in sync orchestrator:",e),!1}}static async syncCustomTiles(t,e){if(t.customTiles!==void 0){const s=t.customTiles||[],r=s.filter(i=>i.isCustom===0);return r.length>0&&console.warn(`⚠️ Found ${r.length} default tiles in customTiles field - data corruption detected`),await K.syncFromFirebase(s,e)}return this.createSuccessResult(0)}static async syncCustomGroups(t,e){return t.customGroups!==void 0?await L.syncFromFirebase(t.customGroups||[],e):this.createSuccessResult(0)}static async syncDisabledDefaults(t){return t.disabledDefaults!==void 0?await G.syncFromFirebase(t.disabledDefaults||[]):this.createSuccessResult(0)}static async syncGameBoards(t){return t.gameBoards!==void 0?await O.syncFromFirebase(t.gameBoards):this.createSuccessResult(0)}static async syncSettings(t){return t.settings!==void 0?await k.syncFromFirebase(t.settings||{}):this.createSuccessResult(0)}}export{Y as SyncOrchestrator};
//# sourceMappingURL=syncOrchestrator.ts-fpcngqET.js.map
